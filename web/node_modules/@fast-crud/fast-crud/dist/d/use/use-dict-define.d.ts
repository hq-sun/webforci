import { UnwrapNestedRefs } from "vue";
declare const UnMergeable: {
    new (): {
        cloneable: boolean;
        setCloneable(cloneable: any): void;
    };
};
export type DictRequest = (req: {
    url: string;
    dict: Dict;
}) => Promise<any[]>;
declare function setDictRequest(request: DictRequest): void;
export type DictGetUrl = (context?: any) => string;
export type DictGetData<T> = (context?: any) => Promise<T[]>;
/**
 * Dict参数
 */
export interface DictOptions<T = any> {
    /**
     * dict请求url
     */
    url?: string | DictGetUrl;
    /**
     * 自定义获取data远程方法
     */
    getData?: DictGetData<T>;
    /**
     * 字典项value字段名称
     */
    value?: string;
    /**
     * 字典项label字段名称
     */
    label?: string;
    labelBuilder?: (item: any) => string;
    /**
     * 字典项children字段名称
     */
    children?: string;
    /**
     * 字典项color字段名称
     */
    color?: string;
    /**
     * 是否是树形
     */
    isTree?: boolean;
    /**
     * 是否全局缓存， 建议将dict()实例放到全局文件中引用，相当于store，也可达到全局缓存的效果
     */
    cache?: boolean;
    /**
     * 是否将本dict当做原型，所有组件引用后将clone一个实例
     */
    prototype?: boolean;
    /**
     * 是否分发时复制
     */
    cloneable?: boolean;
    /**
     * dict创建后是否立即请求
     */
    immediate?: boolean;
    /**
     * 根据values 远程获取字典
     * @param values
     */
    getNodesByValues?: (values: any[], options?: LoadDictOpts) => Promise<T[]>;
    /**
     * dict数据远程加载完后触发
     */
    onReady?: (context: any) => void;
    /**
     * 自定义参数
     */
    custom?: any;
    /**
     * 本地字典数据，无需远程请求
     */
    data?: T[];
}
export type LoadDictOpts = {
    reload?: boolean;
    value?: any;
    [key: string]: any;
};
export type DictOnReadyContext = {
    dict: Dict;
    [key: string]: any;
};
/**
 *
 * @param url
 * @param context = {dict, scope}
 * @returns {Promise<*>}
 */
export declare class Dict<T = any> extends UnMergeable implements DictOptions<T> {
    cache: boolean;
    prototype: boolean;
    immediate: boolean;
    url?: string | DictGetUrl;
    getData?: DictGetData<T>;
    value: string;
    label: string;
    labelBuilder?: (item: any) => string;
    children: string;
    color: string;
    isTree: boolean;
    _data: null | T[];
    get data(): T[];
    set data(data: T[]);
    originalData?: T[];
    dataMap: any;
    loading: boolean;
    custom: {};
    getNodesByValues?: (values: any, options?: LoadDictOpts) => Promise<T[]>;
    onReady?: (context: DictOnReadyContext) => void;
    notifies: Array<any>;
    constructor(dict: DictOptions<T>);
    isDynamic(): boolean;
    setData(data: any[]): void;
    /**
     * 加载字典
     */
    _loadDict(context: LoadDictOpts): Promise<any[]>;
    _triggerNotify(): void;
    _registerNotify(): Promise<any[]>;
    /**
     * 加载字典
     * @param context 当prototype=true时会传入
     */
    loadDict(context?: LoadDictOpts): Promise<any[]>;
    reloadDict(context?: LoadDictOpts): Promise<any[]>;
    _unfetchValues: Record<any, {
        loading: boolean;
        value: any;
    }>;
    /**
     * 根据value获取nodes 追加数据
     * @param values
     */
    appendByValues(values: any[]): Promise<any[]>;
    clear(): void;
    getRemoteDictData(context?: any): Promise<any>;
    toMap(): void;
    buildMap(map: any, list: any): void;
    getValue(item: any): any;
    getLabel(item: any): any;
    getChildren(item: any): any;
    getColor(item: any): any;
    getDictData(): T[];
    getDictMap(): any;
    getNodeByValue(value: any): any;
    getNodesFromDataMap(value: any): any[];
}
/**
 * 创建Dict对象
 * 注意：这里只能定义返回<any>,否则build结果会缺失index.d.ts
 * @param config
 */
export declare function dict<T = any>(config: DictOptions<T>): UnwrapNestedRefs<Dict<any>>;
export declare function useDictDefine(): {
    dict: typeof dict;
    setDictRequest: typeof setDictRequest;
    Dict: typeof Dict;
};
export {};
