import cs from "lodash-es";
import { b as Hc, u as jc } from "./index-d86da30d.mjs";
import zc from "axios";
import { a as _n } from "./_commonjsHelpers-2f131a27.mjs";
import "vue";
import "@fast-crud/fast-crud";
const qc = (e) => {
  let t = e.httpHandler;
  return {
    setHttpHandler(r) {
      t = r;
    },
    httpHandler() {
      return t;
    },
    updateHttpClientConfig(r, n) {
      t.updateHttpClientConfig(r, n);
    },
    httpHandlerConfigs() {
      return t.httpHandlerConfigs();
    }
  };
}, Wc = (e) => ({
  httpHandler: e.httpHandler()
});
var us;
(function(e) {
  e.HEADER = "header", e.QUERY = "query";
})(us || (us = {}));
var ds;
(function(e) {
  e.HEADER = "header", e.QUERY = "query";
})(ds || (ds = {}));
var Ft;
(function(e) {
  e.HTTP = "http", e.HTTPS = "https";
})(Ft || (Ft = {}));
var Yt;
(function(e) {
  e.MD5 = "md5", e.CRC32 = "crc32", e.CRC32C = "crc32c", e.SHA1 = "sha1", e.SHA256 = "sha256";
})(Yt || (Yt = {}));
var ls;
(function(e) {
  e[e.HEADER = 0] = "HEADER", e[e.TRAILER = 1] = "TRAILER";
})(ls || (ls = {}));
const un = "__smithy_context";
var fs;
(function(e) {
  e.PROFILE = "profile", e.SSO_SESSION = "sso-session", e.SERVICES = "services";
})(fs || (fs = {}));
var hs;
(function(e) {
  e.HTTP_0_9 = "http/0.9", e.HTTP_1_0 = "http/1.0", e.TDS_8_0 = "tds/8.0";
})(hs || (hs = {}));
class ge {
  constructor(t) {
    this.method = t.method || "GET", this.hostname = t.hostname || "localhost", this.port = t.port, this.query = t.query || {}, this.headers = t.headers || {}, this.body = t.body, this.protocol = t.protocol ? t.protocol.slice(-1) !== ":" ? `${t.protocol}:` : t.protocol : "https:", this.path = t.path ? t.path.charAt(0) !== "/" ? `/${t.path}` : t.path : "/", this.username = t.username, this.password = t.password, this.fragment = t.fragment;
  }
  static isInstance(t) {
    if (!t)
      return !1;
    const r = t;
    return "method" in r && "protocol" in r && "hostname" in r && "path" in r && typeof r.query == "object" && typeof r.headers == "object";
  }
  clone() {
    const t = new ge({
      ...this,
      headers: { ...this.headers }
    });
    return t.query && (t.query = Gc(t.query)), t;
  }
}
function Gc(e) {
  return Object.keys(e).reduce((t, r) => {
    const n = e[r];
    return {
      ...t,
      [r]: Array.isArray(n) ? [...n] : n
    };
  }, {});
}
class Qt {
  constructor(t) {
    this.statusCode = t.statusCode, this.reason = t.reason, this.headers = t.headers || {}, this.body = t.body;
  }
  static isInstance(t) {
    if (!t)
      return !1;
    const r = t;
    return typeof r.statusCode == "number" && typeof r.headers == "object";
  }
}
function Vc(e) {
  return (t) => async (r) => {
    var s, i;
    const { request: n } = r;
    return ge.isInstance(n) && n.body && e.runtime === "node" && ((i = (s = e.requestHandler) == null ? void 0 : s.constructor) == null ? void 0 : i.name) !== "FetchHttpHandler" && (n.headers = {
      ...n.headers,
      Expect: "100-continue"
    }), t({
      ...r,
      request: n
    });
  };
}
const Kc = {
  step: "build",
  tags: ["SET_EXPECT_HEADER", "EXPECT_HEADER"],
  name: "addExpectContinueMiddleware",
  override: !0
}, Xc = (e) => ({
  applyToStack: (t) => {
    t.add(Vc(e), Kc);
  }
});
const Zc = (e) => (t) => async (r) => {
  if (!ge.isInstance(r.request))
    return t(r);
  const { request: n } = r, { handlerProtocol: s = "" } = e.requestHandler.metadata || {};
  if (s.indexOf("h2") >= 0 && !n.headers[":authority"])
    delete n.headers.host, n.headers[":authority"] = n.hostname + (n.port ? ":" + n.port : "");
  else if (!n.headers.host) {
    let i = n.hostname;
    n.port != null && (i += `:${n.port}`), n.headers.host = i;
  }
  return t(r);
}, Yc = {
  name: "hostHeaderMiddleware",
  step: "build",
  priority: "low",
  tags: ["HOST"],
  override: !0
}, Qc = (e) => ({
  applyToStack: (t) => {
    t.add(Zc(e), Yc);
  }
}), Jc = () => (e, t) => async (r) => {
  var n, s;
  try {
    const i = await e(r), { clientName: o, commandName: a, logger: c, dynamoDbDocumentClientOptions: u = {} } = t, { overrideInputFilterSensitiveLog: l, overrideOutputFilterSensitiveLog: h } = u, p = l ?? t.inputFilterSensitiveLog, g = h ?? t.outputFilterSensitiveLog, { $metadata: b, ...A } = i.output;
    return (n = c == null ? void 0 : c.info) == null || n.call(c, {
      clientName: o,
      commandName: a,
      input: p(r.input),
      output: g(A),
      metadata: b
    }), i;
  } catch (i) {
    const { clientName: o, commandName: a, logger: c, dynamoDbDocumentClientOptions: u = {} } = t, { overrideInputFilterSensitiveLog: l } = u, h = l ?? t.inputFilterSensitiveLog;
    throw (s = c == null ? void 0 : c.error) == null || s.call(c, {
      clientName: o,
      commandName: a,
      input: h(r.input),
      error: i,
      metadata: i.$metadata
    }), i;
  }
}, eu = {
  name: "loggerMiddleware",
  tags: ["LOGGER"],
  step: "initialize",
  override: !0
}, tu = (e) => ({
  applyToStack: (t) => {
    t.add(Jc(), eu);
  }
}), ps = "X-Amzn-Trace-Id", ru = "AWS_LAMBDA_FUNCTION_NAME", nu = "_X_AMZN_TRACE_ID", su = (e) => (t) => async (r) => {
  const { request: n } = r;
  if (!ge.isInstance(n) || e.runtime !== "node" || n.headers.hasOwnProperty(ps))
    return t(r);
  const s = process.env[ru], i = process.env[nu], o = (a) => typeof a == "string" && a.length > 0;
  return o(s) && o(i) && (n.headers[ps] = i), t({
    ...r,
    request: n
  });
}, iu = {
  step: "build",
  tags: ["RECURSION_DETECTION"],
  name: "recursionDetectionMiddleware",
  override: !0,
  priority: "low"
}, ou = (e) => ({
  applyToStack: (t) => {
    t.add(su(e), iu);
  }
});
class Tn {
  trace() {
  }
  debug() {
  }
  info() {
  }
  warn() {
  }
  error() {
  }
}
const Ge = (e, t) => {
  const r = [];
  if (e && r.push(e), t)
    for (const n of t)
      r.push(n);
  return r;
}, Ie = (e, t) => `${e || "anonymous"}${t && t.length > 0 ? ` (a.k.a. ${t.join(",")})` : ""}`, Jt = () => {
  let e = [], t = [], r = !1;
  const n = /* @__PURE__ */ new Set(), s = (h) => h.sort((p, g) => gs[g.step] - gs[p.step] || ms[g.priority || "normal"] - ms[p.priority || "normal"]), i = (h) => {
    let p = !1;
    const g = (b) => {
      const A = Ge(b.name, b.aliases);
      if (A.includes(h)) {
        p = !0;
        for (const R of A)
          n.delete(R);
        return !1;
      }
      return !0;
    };
    return e = e.filter(g), t = t.filter(g), p;
  }, o = (h) => {
    let p = !1;
    const g = (b) => {
      if (b.middleware === h) {
        p = !0;
        for (const A of Ge(b.name, b.aliases))
          n.delete(A);
        return !1;
      }
      return !0;
    };
    return e = e.filter(g), t = t.filter(g), p;
  }, a = (h) => {
    var p;
    return e.forEach((g) => {
      h.add(g.middleware, { ...g });
    }), t.forEach((g) => {
      h.addRelativeTo(g.middleware, { ...g });
    }), (p = h.identifyOnResolve) == null || p.call(h, l.identifyOnResolve()), h;
  }, c = (h) => {
    const p = [];
    return h.before.forEach((g) => {
      g.before.length === 0 && g.after.length === 0 ? p.push(g) : p.push(...c(g));
    }), p.push(h), h.after.reverse().forEach((g) => {
      g.before.length === 0 && g.after.length === 0 ? p.push(g) : p.push(...c(g));
    }), p;
  }, u = (h = !1) => {
    const p = [], g = [], b = {};
    return e.forEach((R) => {
      const T = {
        ...R,
        before: [],
        after: []
      };
      for (const I of Ge(T.name, T.aliases))
        b[I] = T;
      p.push(T);
    }), t.forEach((R) => {
      const T = {
        ...R,
        before: [],
        after: []
      };
      for (const I of Ge(T.name, T.aliases))
        b[I] = T;
      g.push(T);
    }), g.forEach((R) => {
      if (R.toMiddleware) {
        const T = b[R.toMiddleware];
        if (T === void 0) {
          if (h)
            return;
          throw new Error(`${R.toMiddleware} is not found when adding ${Ie(R.name, R.aliases)} middleware ${R.relation} ${R.toMiddleware}`);
        }
        R.relation === "after" && T.after.push(R), R.relation === "before" && T.before.push(R);
      }
    }), s(p).map(c).reduce((R, T) => (R.push(...T), R), []);
  }, l = {
    add: (h, p = {}) => {
      const { name: g, override: b, aliases: A } = p, R = {
        step: "initialize",
        priority: "normal",
        middleware: h,
        ...p
      }, T = Ge(g, A);
      if (T.length > 0) {
        if (T.some((I) => n.has(I))) {
          if (!b)
            throw new Error(`Duplicate middleware name '${Ie(g, A)}'`);
          for (const I of T) {
            const $ = e.findIndex((Z) => {
              var Oe;
              return Z.name === I || ((Oe = Z.aliases) == null ? void 0 : Oe.some((et) => et === I));
            });
            if ($ === -1)
              continue;
            const X = e[$];
            if (X.step !== R.step || R.priority !== X.priority)
              throw new Error(`"${Ie(X.name, X.aliases)}" middleware with ${X.priority} priority in ${X.step} step cannot be overridden by "${Ie(g, A)}" middleware with ${R.priority} priority in ${R.step} step.`);
            e.splice($, 1);
          }
        }
        for (const I of T)
          n.add(I);
      }
      e.push(R);
    },
    addRelativeTo: (h, p) => {
      const { name: g, override: b, aliases: A } = p, R = {
        middleware: h,
        ...p
      }, T = Ge(g, A);
      if (T.length > 0) {
        if (T.some((I) => n.has(I))) {
          if (!b)
            throw new Error(`Duplicate middleware name '${Ie(g, A)}'`);
          for (const I of T) {
            const $ = t.findIndex((Z) => {
              var Oe;
              return Z.name === I || ((Oe = Z.aliases) == null ? void 0 : Oe.some((et) => et === I));
            });
            if ($ === -1)
              continue;
            const X = t[$];
            if (X.toMiddleware !== R.toMiddleware || X.relation !== R.relation)
              throw new Error(`"${Ie(X.name, X.aliases)}" middleware ${X.relation} "${X.toMiddleware}" middleware cannot be overridden by "${Ie(g, A)}" middleware ${R.relation} "${R.toMiddleware}" middleware.`);
            t.splice($, 1);
          }
        }
        for (const I of T)
          n.add(I);
      }
      t.push(R);
    },
    clone: () => a(Jt()),
    use: (h) => {
      h.applyToStack(l);
    },
    remove: (h) => typeof h == "string" ? i(h) : o(h),
    removeByTag: (h) => {
      let p = !1;
      const g = (b) => {
        const { tags: A, name: R, aliases: T } = b;
        if (A && A.includes(h)) {
          const I = Ge(R, T);
          for (const $ of I)
            n.delete($);
          return p = !0, !1;
        }
        return !0;
      };
      return e = e.filter(g), t = t.filter(g), p;
    },
    concat: (h) => {
      var g;
      const p = a(Jt());
      return p.use(h), p.identifyOnResolve(r || p.identifyOnResolve() || (((g = h.identifyOnResolve) == null ? void 0 : g.call(h)) ?? !1)), p;
    },
    applyToStack: a,
    identify: () => u(!0).map((h) => {
      const p = h.step ?? h.relation + " " + h.toMiddleware;
      return Ie(h.name, h.aliases) + " - " + p;
    }),
    identifyOnResolve(h) {
      return typeof h == "boolean" && (r = h), r;
    },
    resolve: (h, p) => {
      for (const g of u().map((b) => b.middleware).reverse())
        h = g(h, p);
      return h;
    }
  };
  return l;
}, gs = {
  initialize: 5,
  serialize: 4,
  build: 3,
  finalizeRequest: 2,
  deserialize: 1
}, ms = {
  high: 3,
  normal: 2,
  low: 1
};
class au {
  constructor(t) {
    this.middlewareStack = Jt(), this.config = t;
  }
  send(t, r, n) {
    const s = typeof r != "function" ? r : void 0, i = typeof r == "function" ? r : n, o = t.resolveMiddleware(this.middlewareStack, this.config, s);
    if (i)
      o(t).then((a) => i(null, a.output), (a) => i(a)).catch(() => {
      });
    else
      return o(t).then((a) => a.output);
  }
  destroy() {
    this.config.requestHandler.destroy && this.config.requestHandler.destroy();
  }
}
const je = {}, ut = new Array(64);
for (let e = 0, t = "A".charCodeAt(0), r = "Z".charCodeAt(0); e + t <= r; e++) {
  const n = String.fromCharCode(e + t);
  je[n] = e, ut[e] = n;
}
for (let e = 0, t = "a".charCodeAt(0), r = "z".charCodeAt(0); e + t <= r; e++) {
  const n = String.fromCharCode(e + t), s = e + 26;
  je[n] = s, ut[s] = n;
}
for (let e = 0; e < 10; e++) {
  je[e.toString(10)] = e + 52;
  const t = e.toString(10), r = e + 52;
  je[t] = r, ut[r] = t;
}
je["+"] = 62;
ut[62] = "+";
je["/"] = 63;
ut[63] = "/";
const it = 6, Pt = 8, cu = 63, Bn = (e) => {
  let t = e.length / 4 * 3;
  e.slice(-2) === "==" ? t -= 2 : e.slice(-1) === "=" && t--;
  const r = new ArrayBuffer(t), n = new DataView(r);
  for (let s = 0; s < e.length; s += 4) {
    let i = 0, o = 0;
    for (let u = s, l = s + 3; u <= l; u++)
      if (e[u] !== "=") {
        if (!(e[u] in je))
          throw new TypeError(`Invalid character ${e[u]} in base64 string.`);
        i |= je[e[u]] << (l - u) * it, o += it;
      } else
        i >>= it;
    const a = s / 4 * 3;
    i >>= o % Pt;
    const c = Math.floor(o / Pt);
    for (let u = 0; u < c; u++) {
      const l = (c - u - 1) * Pt;
      n.setUint8(a + u, (i & 255 << l) >> l);
    }
  }
  return new Uint8Array(r);
}, Qe = (e) => new TextEncoder().encode(e), ot = (e) => typeof e == "string" ? Qe(e) : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(e), kn = (e) => {
  if (typeof e == "string")
    return e;
  if (typeof e != "object" || typeof e.byteOffset != "number" || typeof e.byteLength != "number")
    throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
  return new TextDecoder("utf-8").decode(e);
};
function Nn(e) {
  let t;
  typeof e == "string" ? t = Qe(e) : t = e;
  const r = typeof t == "object" && typeof t.length == "number", n = typeof t == "object" && typeof t.byteOffset == "number" && typeof t.byteLength == "number";
  if (!r && !n)
    throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
  let s = "";
  for (let i = 0; i < t.length; i += 3) {
    let o = 0, a = 0;
    for (let u = i, l = Math.min(i + 3, t.length); u < l; u++)
      o |= t[u] << (l - u - 1) * Pt, a += Pt;
    const c = Math.ceil(a / it);
    o <<= c * it - a;
    for (let u = 1; u <= c; u++) {
      const l = (c - u) * it;
      s += ut[(o & cu << l) >> l];
    }
    s += "==".slice(0, 4 - c);
  }
  return s;
}
function uu(e, t = "utf-8") {
  return t === "base64" ? Nn(e) : kn(e);
}
function du(e, t) {
  return t === "base64" ? Ze.mutate(Bn(e)) : Ze.mutate(Qe(e));
}
class Ze extends Uint8Array {
  static fromString(t, r = "utf-8") {
    switch (typeof t) {
      case "string":
        return du(t, r);
      default:
        throw new Error(`Unsupported conversion from ${typeof t} to Uint8ArrayBlobAdapter.`);
    }
  }
  static mutate(t) {
    return Object.setPrototypeOf(t, Ze.prototype), t;
  }
  transformToString(t = "utf-8") {
    return uu(this, t);
  }
}
const lu = (e, t) => {
  const { base64Encoder: r, bodyLengthChecker: n, checksumAlgorithmFn: s, checksumLocationName: i, streamHasher: o } = t, a = r !== void 0 && n !== void 0 && s !== void 0 && i !== void 0 && o !== void 0, c = a ? o(s, e) : void 0, u = e.getReader();
  return new ReadableStream({
    async pull(l) {
      const { value: h, done: p } = await u.read();
      if (p) {
        if (l.enqueue(`0\r
`), a) {
          const g = r(await c);
          l.enqueue(`${i}:${g}\r
`), l.enqueue(`\r
`);
        }
        l.close();
      } else
        l.enqueue(`${(n(h) || 0).toString(16)}\r
${h}\r
`);
    }
  });
}, He = (e) => encodeURIComponent(e).replace(/[!'()*]/g, fu), fu = (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`;
function hu(e) {
  const t = [];
  for (let r of Object.keys(e).sort()) {
    const n = e[r];
    if (r = He(r), Array.isArray(n))
      for (let s = 0, i = n.length; s < i; s++)
        t.push(`${r}=${He(n[s])}`);
    else {
      let s = r;
      (n || typeof n == "string") && (s += `=${He(n)}`), t.push(s);
    }
  }
  return t.join("&");
}
function pu(e = 0) {
  return new Promise((t, r) => {
    e && setTimeout(() => {
      const n = new Error(`Request did not complete within ${e} ms`);
      n.name = "TimeoutError", r(n);
    }, e);
  });
}
const gu = {
  supported: typeof Request < "u" && "keepalive" in new Request("https://[::1]")
};
class Pn {
  static create(t) {
    return typeof (t == null ? void 0 : t.handle) == "function" ? t : new Pn(t);
  }
  constructor(t) {
    typeof t == "function" ? this.configProvider = t().then((r) => r || {}) : (this.config = t ?? {}, this.configProvider = Promise.resolve(this.config));
  }
  destroy() {
  }
  async handle(t, { abortSignal: r } = {}) {
    this.config || (this.config = await this.configProvider);
    const n = this.config.requestTimeout, s = this.config.keepAlive === !0;
    if (r != null && r.aborted) {
      const A = new Error("Request aborted");
      return A.name = "AbortError", Promise.reject(A);
    }
    let i = t.path;
    const o = hu(t.query || {});
    o && (i += `?${o}`), t.fragment && (i += `#${t.fragment}`);
    let a = "";
    if (t.username != null || t.password != null) {
      const A = t.username ?? "", R = t.password ?? "";
      a = `${A}:${R}@`;
    }
    const { port: c, method: u } = t, l = `${t.protocol}//${a}${t.hostname}${c ? `:${c}` : ""}${i}`, h = u === "GET" || u === "HEAD" ? void 0 : t.body, p = {
      body: h,
      headers: new Headers(t.headers),
      method: u
    };
    h && (p.duplex = "half"), typeof AbortController < "u" && (p.signal = r), gu.supported && (p.keepalive = s);
    const g = new Request(l, p), b = [
      fetch(g).then((A) => {
        const R = A.headers, T = {};
        for (const $ of R.entries())
          T[$[0]] = $[1];
        return A.body != null ? {
          response: new Qt({
            headers: T,
            reason: A.statusText,
            statusCode: A.status,
            body: A.body
          })
        } : A.blob().then(($) => ({
          response: new Qt({
            headers: T,
            reason: A.statusText,
            statusCode: A.status,
            body: $
          })
        }));
      }),
      pu(n)
    ];
    return r && b.push(new Promise((A, R) => {
      r.onabort = () => {
        const T = new Error("Request aborted");
        T.name = "AbortError", R(T);
      };
    })), Promise.race(b);
  }
  updateHttpClientConfig(t, r) {
    this.config = void 0, this.configProvider = this.configProvider.then((n) => (n[t] = r, n));
  }
  httpHandlerConfigs() {
    return this.config ?? {};
  }
}
const Ho = (e) => typeof Blob == "function" && e instanceof Blob ? mu(e) : yu(e);
async function mu(e) {
  const t = await bu(e), r = Bn(t);
  return new Uint8Array(r);
}
async function yu(e) {
  const t = [], r = e.getReader();
  let n = !1, s = 0;
  for (; !n; ) {
    const { done: a, value: c } = await r.read();
    c && (t.push(c), s += c.length), n = a;
  }
  const i = new Uint8Array(s);
  let o = 0;
  for (const a of t)
    i.set(a, o), o += a.length;
  return i;
}
function bu(e) {
  return new Promise((t, r) => {
    const n = new FileReader();
    n.onloadend = () => {
      if (n.readyState !== 2)
        return r(new Error("Reader aborted too early"));
      const s = n.result ?? "", i = s.indexOf(","), o = i > -1 ? i + 1 : s.length;
      t(s.substring(o));
    }, n.onabort = () => r(new Error("Read aborted")), n.onerror = () => r(n.error), n.readAsDataURL(e);
  });
}
const jo = {}, dn = {};
for (let e = 0; e < 256; e++) {
  let t = e.toString(16).toLowerCase();
  t.length === 1 && (t = `0${t}`), jo[e] = t, dn[t] = e;
}
function zo(e) {
  if (e.length % 2 !== 0)
    throw new Error("Hex encoded strings must have an even number length");
  const t = new Uint8Array(e.length / 2);
  for (let r = 0; r < e.length; r += 2) {
    const n = e.slice(r, r + 2).toLowerCase();
    if (n in dn)
      t[r / 2] = dn[n];
    else
      throw new Error(`Cannot decode unrecognized sequence ${n} as hexadecimal`);
  }
  return t;
}
function he(e) {
  let t = "";
  for (let r = 0; r < e.byteLength; r++)
    t += jo[e[r]];
  return t;
}
const ys = "The stream has already been transformed.", wu = (e) => {
  var s, i;
  if (!bs(e) && !ws(e)) {
    const o = ((i = (s = e == null ? void 0 : e.__proto__) == null ? void 0 : s.constructor) == null ? void 0 : i.name) || e;
    throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${o}`);
  }
  let t = !1;
  const r = async () => {
    if (t)
      throw new Error(ys);
    return t = !0, await Ho(e);
  }, n = (o) => {
    if (typeof o.stream != "function")
      throw new Error(`Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.
If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body`);
    return o.stream();
  };
  return Object.assign(e, {
    transformToByteArray: r,
    transformToString: async (o) => {
      const a = await r();
      if (o === "base64")
        return Nn(a);
      if (o === "hex")
        return he(a);
      if (o === void 0 || o === "utf8" || o === "utf-8")
        return kn(a);
      if (typeof TextDecoder == "function")
        return new TextDecoder(o).decode(a);
      throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
    },
    transformToWebStream: () => {
      if (t)
        throw new Error(ys);
      if (t = !0, bs(e))
        return n(e);
      if (ws(e))
        return e;
      throw new Error(`Cannot transform payload to web stream, got ${e}`);
    }
  });
}, bs = (e) => typeof Blob == "function" && e instanceof Blob, ws = (e) => typeof ReadableStream == "function" && e instanceof ReadableStream, qo = async (e = new Uint8Array(), t) => {
  if (e instanceof Uint8Array)
    return Ze.mutate(e);
  if (!e)
    return Ze.mutate(new Uint8Array());
  const r = t.streamCollector(e);
  return Ze.mutate(await r);
};
class On {
  constructor() {
    this.middlewareStack = Jt();
  }
  static classBuilder() {
    return new xu();
  }
  resolveMiddlewareWithContext(t, r, n, { middlewareFn: s, clientName: i, commandName: o, inputFilterSensitiveLog: a, outputFilterSensitiveLog: c, smithyContext: u, additionalContext: l, CommandCtor: h }) {
    for (const R of s.bind(this)(h, t, r, n))
      this.middlewareStack.use(R);
    const p = t.concat(this.middlewareStack), { logger: g } = r, b = {
      logger: g,
      clientName: i,
      commandName: o,
      inputFilterSensitiveLog: a,
      outputFilterSensitiveLog: c,
      [un]: {
        ...u
      },
      ...l
    }, { requestHandler: A } = r;
    return p.resolve((R) => A.handle(R.request, n || {}), b);
  }
}
class xu {
  constructor() {
    this._init = () => {
    }, this._ep = {}, this._middlewareFn = () => [], this._commandName = "", this._clientName = "", this._additionalContext = {}, this._smithyContext = {}, this._inputFilterSensitiveLog = (t) => t, this._outputFilterSensitiveLog = (t) => t, this._serializer = null, this._deserializer = null;
  }
  init(t) {
    this._init = t;
  }
  ep(t) {
    return this._ep = t, this;
  }
  m(t) {
    return this._middlewareFn = t, this;
  }
  s(t, r, n = {}) {
    return this._smithyContext = {
      service: t,
      operation: r,
      ...n
    }, this;
  }
  c(t = {}) {
    return this._additionalContext = t, this;
  }
  n(t, r) {
    return this._clientName = t, this._commandName = r, this;
  }
  f(t = (n) => n, r = (n) => n) {
    return this._inputFilterSensitiveLog = t, this._outputFilterSensitiveLog = r, this;
  }
  ser(t) {
    return this._serializer = t, this;
  }
  de(t) {
    return this._deserializer = t, this;
  }
  build() {
    const t = this;
    let r;
    return r = class extends On {
      static getEndpointParameterInstructions() {
        return t._ep;
      }
      constructor(...[n]) {
        super(), this.serialize = t._serializer, this.deserialize = t._deserializer, this.input = n ?? {}, t._init(this);
      }
      resolveMiddleware(n, s, i) {
        return this.resolveMiddlewareWithContext(n, s, i, {
          CommandCtor: r,
          middlewareFn: t._middlewareFn,
          clientName: t._clientName,
          commandName: t._commandName,
          inputFilterSensitiveLog: t._inputFilterSensitiveLog,
          outputFilterSensitiveLog: t._outputFilterSensitiveLog,
          smithyContext: t._smithyContext,
          additionalContext: t._additionalContext
        });
      }
    };
  }
}
const Ye = "***SensitiveInformation***", Eu = (e) => {
  switch (e) {
    case "true":
      return !0;
    case "false":
      return !1;
    default:
      throw new Error(`Unable to parse boolean value "${e}"`);
  }
}, Au = (e) => {
  if (e != null) {
    if (typeof e == "string") {
      const t = parseFloat(e);
      if (!Number.isNaN(t))
        return String(t) !== String(e) && Ko.warn(Vo(`Expected number but observed string: ${e}`)), t;
    }
    if (typeof e == "number")
      return e;
    throw new TypeError(`Expected number, got ${typeof e}: ${e}`);
  }
}, Su = Math.ceil(2 ** 127 * (2 - 2 ** -23)), xs = (e) => {
  const t = Au(e);
  if (t !== void 0 && !Number.isNaN(t) && t !== 1 / 0 && t !== -1 / 0 && Math.abs(t) > Su)
    throw new TypeError(`Expected 32-bit float, got ${e}`);
  return t;
}, Cu = (e) => {
  if (e != null) {
    if (Number.isInteger(e) && !Number.isNaN(e))
      return e;
    throw new TypeError(`Expected integer, got ${typeof e}: ${e}`);
  }
}, Es = (e) => Wo(e, 16), As = (e) => Wo(e, 8), Wo = (e, t) => {
  const r = Cu(e);
  if (r !== void 0 && vu(r, t) !== r)
    throw new TypeError(`Expected ${t}-bit integer, got ${e}`);
  return r;
}, vu = (e, t) => {
  switch (t) {
    case 32:
      return Int32Array.of(e)[0];
    case 16:
      return Int16Array.of(e)[0];
    case 8:
      return Int8Array.of(e)[0];
  }
}, Go = (e, t) => {
  if (e == null)
    throw t ? new TypeError(`Expected a non-null value for ${t}`) : new TypeError("Expected a non-null value");
  return e;
}, Ru = (e) => {
  if (e == null)
    return;
  if (typeof e == "object" && !Array.isArray(e))
    return e;
  const t = Array.isArray(e) ? "array" : typeof e;
  throw new TypeError(`Expected object, got ${t}: ${e}`);
}, Ot = (e) => {
  if (e != null) {
    if (typeof e == "string")
      return e;
    if (["boolean", "number", "bigint"].includes(typeof e))
      return Ko.warn(Vo(`Expected string, got ${typeof e}: ${e}`)), String(e);
    throw new TypeError(`Expected string, got ${typeof e}: ${e}`);
  }
}, _u = (e) => xs(typeof e == "string" ? Mn(e) : e), Tu = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g, Mn = (e) => {
  const t = e.match(Tu);
  if (t === null || t[0].length !== e.length)
    throw new TypeError("Expected real number, got implicit NaN");
  return parseFloat(e);
}, Bu = (e) => Es(typeof e == "string" ? Mn(e) : e), ku = (e) => As(typeof e == "string" ? Mn(e) : e), Vo = (e) => String(new TypeError(e).stack || e).split(`
`).slice(0, 5).filter((t) => !t.includes("stackTraceWarning")).join(`
`), Ko = {
  warn: console.warn
}, Nu = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], Xo = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function Pu(e) {
  const t = e.getUTCFullYear(), r = e.getUTCMonth(), n = e.getUTCDay(), s = e.getUTCDate(), i = e.getUTCHours(), o = e.getUTCMinutes(), a = e.getUTCSeconds(), c = s < 10 ? `0${s}` : `${s}`, u = i < 10 ? `0${i}` : `${i}`, l = o < 10 ? `0${o}` : `${o}`, h = a < 10 ? `0${a}` : `${a}`;
  return `${Nu[n]}, ${c} ${Xo[r]} ${t} ${u}:${l}:${h} GMT`;
}
const Ou = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/), Mu = (e) => {
  if (e == null)
    return;
  if (typeof e != "string")
    throw new TypeError("RFC-3339 date-times must be expressed as strings");
  const t = Ou.exec(e);
  if (!t)
    throw new TypeError("Invalid RFC-3339 date-time value");
  const [r, n, s, i, o, a, c, u, l] = t, h = Bu(Zo(n)), p = Mt(s, "month", 1, 12), g = Mt(i, "day", 1, 31), b = Iu(h, p, g, { hours: o, minutes: a, seconds: c, fractionalMilliseconds: u });
  return l.toUpperCase() != "Z" && b.setTime(b.getTime() - Lu(l)), b;
}, Iu = (e, t, r, n) => {
  const s = t - 1;
  return Du(e, s, r), new Date(Date.UTC(e, s, r, Mt(n.hours, "hour", 0, 23), Mt(n.minutes, "minute", 0, 59), Mt(n.seconds, "seconds", 0, 60), $u(n.fractionalMilliseconds)));
}, Fu = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], Du = (e, t, r) => {
  let n = Fu[t];
  if (t === 1 && Uu(e) && (n = 29), r > n)
    throw new TypeError(`Invalid day for ${Xo[t]} in ${e}: ${r}`);
}, Uu = (e) => e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0), Mt = (e, t, r, n) => {
  const s = ku(Zo(e));
  if (s < r || s > n)
    throw new TypeError(`${t} must be between ${r} and ${n}, inclusive`);
  return s;
}, $u = (e) => e == null ? 0 : _u("0." + e) * 1e3, Lu = (e) => {
  const t = e[0];
  let r = 1;
  if (t == "+")
    r = 1;
  else if (t == "-")
    r = -1;
  else
    throw new TypeError(`Offset direction, ${t}, must be "+" or "-"`);
  const n = Number(e.substring(1, 3)), s = Number(e.substring(4, 6));
  return r * (n * 60 + s) * 60 * 1e3;
}, Zo = (e) => {
  let t = 0;
  for (; t < e.length - 1 && e.charAt(t) === "0"; )
    t++;
  return t === 0 ? e : e.slice(t);
};
class In extends Error {
  constructor(t) {
    super(t.message), Object.setPrototypeOf(this, In.prototype), this.name = t.name, this.$fault = t.$fault, this.$metadata = t.$metadata;
  }
}
const Ne = (e, t = {}) => {
  Object.entries(t).filter(([, n]) => n !== void 0).forEach(([n, s]) => {
    (e[n] == null || e[n] === "") && (e[n] = s);
  });
  const r = e.message || e.Message || "UnknownError";
  return e.message = r, delete e.Message, e;
}, Hu = ({ output: e, parsedBody: t, exceptionCtor: r, errorCode: n }) => {
  const s = zu(e), i = s.httpStatusCode ? s.httpStatusCode + "" : void 0, o = new r({
    name: (t == null ? void 0 : t.code) || (t == null ? void 0 : t.Code) || n || i || "UnknownError",
    $fault: "client",
    $metadata: s
  });
  throw Ne(o, t);
}, ju = (e) => ({ output: t, parsedBody: r, errorCode: n }) => {
  Hu({ output: t, parsedBody: r, exceptionCtor: e, errorCode: n });
}, zu = (e) => ({
  httpStatusCode: e.statusCode,
  requestId: e.headers["x-amzn-requestid"] ?? e.headers["x-amzn-request-id"] ?? e.headers["x-amz-request-id"],
  extendedRequestId: e.headers["x-amz-id-2"],
  cfId: e.headers["x-amz-cf-id"]
}), qu = (e) => {
  switch (e) {
    case "standard":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "in-region":
      return {
        retryMode: "standard",
        connectionTimeout: 1100
      };
    case "cross-region":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "mobile":
      return {
        retryMode: "standard",
        connectionTimeout: 3e4
      };
    default:
      return {};
  }
}, Wu = (e) => {
  const t = [];
  for (const r in Yt) {
    const n = Yt[r];
    e[n] !== void 0 && t.push({
      algorithmId: () => n,
      checksumConstructor: () => e[n]
    });
  }
  return {
    _checksumAlgorithms: t,
    addChecksumAlgorithm(r) {
      this._checksumAlgorithms.push(r);
    },
    checksumAlgorithms() {
      return this._checksumAlgorithms;
    }
  };
}, Gu = (e) => {
  const t = {};
  return e.checksumAlgorithms().forEach((r) => {
    t[r.algorithmId()] = r.checksumConstructor();
  }), t;
}, Vu = (e) => {
  let t = e.retryStrategy;
  return {
    setRetryStrategy(r) {
      t = r;
    },
    retryStrategy() {
      return t;
    }
  };
}, Ku = (e) => {
  const t = {};
  return t.retryStrategy = e.retryStrategy(), t;
}, Xu = (e) => ({
  ...Wu(e),
  ...Vu(e)
}), Zu = (e) => ({
  ...Gu(e),
  ...Ku(e)
});
function Ss(e) {
  return encodeURIComponent(e).replace(/[!'()*]/g, function(t) {
    return "%" + t.charCodeAt(0).toString(16).toUpperCase();
  });
}
const Yo = (e) => {
  const t = "#text";
  for (const r in e)
    e.hasOwnProperty(r) && e[r][t] !== void 0 ? e[r] = e[r][t] : typeof e[r] == "object" && e[r] !== null && (e[r] = Yo(e[r]));
  return e;
}, ln = function() {
  const e = Object.getPrototypeOf(this).constructor, t = Function.bind.apply(String, [null, ...arguments]), r = new t();
  return Object.setPrototypeOf(r, e.prototype), r;
};
ln.prototype = Object.create(String.prototype, {
  constructor: {
    value: ln,
    enumerable: !1,
    writable: !0,
    configurable: !0
  }
});
Object.setPrototypeOf(ln, String);
function ae(e, t, r) {
  let n, s, i;
  if (typeof t > "u" && typeof r > "u")
    n = {}, i = e;
  else {
    if (n = e, typeof t == "function")
      return s = t, i = r, Yu(n, s, i);
    i = t;
  }
  for (const o of Object.keys(i)) {
    if (!Array.isArray(i[o])) {
      n[o] = i[o];
      continue;
    }
    Qu(n, null, i, o);
  }
  return n;
}
const Yu = (e, t, r) => ae(e, Object.entries(r).reduce((n, [s, i]) => (Array.isArray(i) ? n[s] = i : typeof i == "function" ? n[s] = [t, i()] : n[s] = [t, i], n), {})), Qu = (e, t, r, n) => {
  if (t !== null) {
    let o = r[n];
    typeof o == "function" && (o = [, o]);
    const [a = Ju, c = ed, u = n] = o;
    (typeof a == "function" && a(t[u]) || typeof a != "function" && a) && (e[n] = c(t[u]));
    return;
  }
  let [s, i] = r[n];
  if (typeof i == "function") {
    let o;
    const a = s === void 0 && (o = i()) != null, c = typeof s == "function" && !!s(void 0) || typeof s != "function" && !!s;
    a ? e[n] = o : c && (e[n] = i());
  } else {
    const o = s === void 0 && i != null, a = typeof s == "function" && !!s(i) || typeof s != "function" && !!s;
    (o || a) && (e[n] = i);
  }
}, Ju = (e) => e != null, ed = (e) => e, td = (e, t, r, n, s, i) => {
  if (t != null && t[r] !== void 0) {
    const o = n();
    if (o.length <= 0)
      throw new Error("Empty value provided for input HTTP label: " + r + ".");
    e = e.replace(s, i ? o.split("/").map((a) => Ss(a)).join("/") : Ss(o));
  } else
    throw new Error("No value provided for input HTTP label: " + r + ".");
  return e;
}, rd = (e) => e.toISOString().replace(".000Z", "Z"), nd = "content-length";
function sd() {
  return (e, t) => async (r) => {
    var s;
    const { request: n } = r;
    if (ge.isInstance(n) && !(nd in n.headers)) {
      const i = "Are you using a Stream of unknown length as the Body of a PutObject request? Consider using Upload instead from @aws-sdk/lib-storage.";
      typeof ((s = t == null ? void 0 : t.logger) == null ? void 0 : s.warn) == "function" && !(t.logger instanceof Tn) && t.logger.warn(i);
    }
    return e({ ...r });
  };
}
const id = {
  step: "finalizeRequest",
  tags: ["CHECK_CONTENT_LENGTH_HEADER"],
  name: "getCheckContentLengthHeaderPlugin",
  override: !0
}, od = (e) => ({
  applyToStack: (t) => {
    t.add(sd(), id);
  }
}), ad = (e) => (t, r) => async (n) => {
  const s = await e.region(), i = e.region;
  r.__s3RegionRedirect && (e.region = async () => (e.region = i, r.__s3RegionRedirect));
  const o = await t(n);
  if (r.__s3RegionRedirect) {
    const a = await e.region();
    if (s !== a)
      throw new Error("Region was not restored following S3 region redirect.");
  }
  return o;
}, cd = {
  tags: ["REGION_REDIRECT", "S3"],
  name: "regionRedirectEndpointMiddleware",
  override: !0,
  relation: "before",
  toMiddleware: "endpointV2Middleware"
};
function ud(e) {
  return (t, r) => async (n) => {
    var s, i;
    try {
      return await t(n);
    } catch (o) {
      if (e.followRegionRedirects && ((s = o == null ? void 0 : o.$metadata) == null ? void 0 : s.httpStatusCode) === 301) {
        try {
          const a = o.$response.headers["x-amz-bucket-region"];
          (i = r.logger) == null || i.debug(`Redirecting from ${await e.region()} to ${a}`), r.__s3RegionRedirect = a;
        } catch (a) {
          throw new Error("Region redirect failed: " + a);
        }
        return t(n);
      } else
        throw o;
    }
  };
}
const dd = {
  step: "initialize",
  tags: ["REGION_REDIRECT", "S3"],
  name: "regionRedirectMiddleware",
  override: !0
}, ld = (e) => ({
  applyToStack: (t) => {
    t.add(ud(e), dd), t.addRelativeTo(ad(e), cd);
  }
});
class or {
  constructor(t = {}) {
    this.data = t, this.lastPurgeTime = Date.now();
  }
  get(t) {
    const r = this.data[t];
    if (r)
      return r;
  }
  set(t, r) {
    return this.data[t] = r, r;
  }
  delete(t) {
    delete this.data[t];
  }
  async purgeExpired() {
    const t = Date.now();
    if (!(this.lastPurgeTime + or.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS > t))
      for (const r in this.data) {
        const n = this.data[r];
        if (!n.isRefreshing) {
          const s = await n.identity;
          s.expiration && s.expiration.getTime() < t && delete this.data[r];
        }
      }
  }
}
or.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS = 3e4;
class fr {
  constructor(t, r = !1, n = Date.now()) {
    this._identity = t, this.isRefreshing = r, this.accessed = n;
  }
  get identity() {
    return this.accessed = Date.now(), this._identity;
  }
}
class ar {
  constructor(t, r = new or()) {
    this.createSessionFn = t, this.cache = r;
  }
  async getS3ExpressIdentity(t, r) {
    const n = r.Bucket, { cache: s } = this, i = s.get(n);
    return i ? i.identity.then((o) => {
      var u, l;
      return (((u = o.expiration) == null ? void 0 : u.getTime()) ?? 0) < Date.now() ? s.set(n, new fr(this.getIdentity(n))).identity : ((((l = o.expiration) == null ? void 0 : l.getTime()) ?? 0) < Date.now() + ar.REFRESH_WINDOW_MS && !i.isRefreshing && (i.isRefreshing = !0, this.getIdentity(n).then((h) => {
        s.set(n, new fr(Promise.resolve(h)));
      })), o);
    }) : s.set(n, new fr(this.getIdentity(n))).identity;
  }
  async getIdentity(t) {
    var s, i;
    await this.cache.purgeExpired().catch((o) => {
    });
    const r = await this.createSessionFn(t);
    if (!((s = r.Credentials) != null && s.AccessKeyId) || !((i = r.Credentials) != null && i.SecretAccessKey))
      throw new Error("s3#createSession response credential missing AccessKeyId or SecretAccessKey.");
    return {
      accessKeyId: r.Credentials.AccessKeyId,
      secretAccessKey: r.Credentials.SecretAccessKey,
      sessionToken: r.Credentials.SessionToken,
      expiration: r.Credentials.Expiration ? new Date(r.Credentials.Expiration) : void 0
    };
  }
}
ar.REFRESH_WINDOW_MS = 6e4;
const fd = (e) => e[un] || (e[un] = {}), ve = (e) => {
  if (typeof e == "function")
    return e;
  const t = Promise.resolve(e);
  return () => t;
}, hd = "X-Amz-Algorithm", pd = "X-Amz-Credential", Qo = "X-Amz-Date", gd = "X-Amz-SignedHeaders", md = "X-Amz-Expires", Jo = "X-Amz-Signature", ea = "X-Amz-Security-Token", ta = "authorization", ra = Qo.toLowerCase(), yd = "date", bd = [ta, ra, yd], wd = Jo.toLowerCase(), fn = "x-amz-content-sha256", xd = ea.toLowerCase(), Ed = {
  authorization: !0,
  "cache-control": !0,
  connection: !0,
  expect: !0,
  from: !0,
  "keep-alive": !0,
  "max-forwards": !0,
  pragma: !0,
  referer: !0,
  te: !0,
  trailer: !0,
  "transfer-encoding": !0,
  upgrade: !0,
  "user-agent": !0,
  "x-amzn-trace-id": !0
}, Ad = /^proxy-/, Sd = /^sec-/, hr = "AWS4-HMAC-SHA256", Cd = "AWS4-HMAC-SHA256-PAYLOAD", vd = "UNSIGNED-PAYLOAD", Rd = 50, na = "aws4_request", _d = 60 * 60 * 24 * 7, Lt = {}, pr = [], gr = (e, t, r) => `${e}/${t}/${r}/${na}`, Td = async (e, t, r, n, s) => {
  const i = await Cs(e, t.secretAccessKey, t.accessKeyId), o = `${r}:${n}:${s}:${he(i)}:${t.sessionToken}`;
  if (o in Lt)
    return Lt[o];
  for (pr.push(o); pr.length > Rd; )
    delete Lt[pr.shift()];
  let a = `AWS4${t.secretAccessKey}`;
  for (const c of [r, n, s, na])
    a = await Cs(e, a, c);
  return Lt[o] = a;
}, Cs = (e, t, r) => {
  const n = new e(t);
  return n.update(ot(r)), n.digest();
}, vs = ({ headers: e }, t, r) => {
  const n = {};
  for (const s of Object.keys(e).sort()) {
    if (e[s] == null)
      continue;
    const i = s.toLowerCase();
    (i in Ed || t != null && t.has(i) || Ad.test(i) || Sd.test(i)) && (!r || r && !r.has(i)) || (n[i] = e[s].trim().replace(/\s+/g, " "));
  }
  return n;
}, Bd = ({ query: e = {} }) => {
  const t = [], r = {};
  for (const n of Object.keys(e).sort()) {
    if (n.toLowerCase() === wd)
      continue;
    t.push(n);
    const s = e[n];
    typeof s == "string" ? r[n] = `${He(n)}=${He(s)}` : Array.isArray(s) && (r[n] = s.slice(0).reduce((i, o) => i.concat([`${He(n)}=${He(o)}`]), []).sort().join("&"));
  }
  return t.map((n) => r[n]).filter((n) => n).join("&");
}, sa = (e) => typeof ArrayBuffer == "function" && e instanceof ArrayBuffer || Object.prototype.toString.call(e) === "[object ArrayBuffer]", mr = async ({ headers: e, body: t }, r) => {
  for (const n of Object.keys(e))
    if (n.toLowerCase() === fn)
      return e[n];
  if (t == null)
    return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
  if (typeof t == "string" || ArrayBuffer.isView(t) || sa(t)) {
    const n = new r();
    return n.update(ot(t)), he(await n.digest());
  }
  return vd;
};
class kd {
  format(t) {
    const r = [];
    for (const i of Object.keys(t)) {
      const o = Qe(i);
      r.push(Uint8Array.from([o.byteLength]), o, this.formatHeaderValue(t[i]));
    }
    const n = new Uint8Array(r.reduce((i, o) => i + o.byteLength, 0));
    let s = 0;
    for (const i of r)
      n.set(i, s), s += i.byteLength;
    return n;
  }
  formatHeaderValue(t) {
    switch (t.type) {
      case "boolean":
        return Uint8Array.from([t.value ? 0 : 1]);
      case "byte":
        return Uint8Array.from([2, t.value]);
      case "short":
        const r = new DataView(new ArrayBuffer(3));
        return r.setUint8(0, 3), r.setInt16(1, t.value, !1), new Uint8Array(r.buffer);
      case "integer":
        const n = new DataView(new ArrayBuffer(5));
        return n.setUint8(0, 4), n.setInt32(1, t.value, !1), new Uint8Array(n.buffer);
      case "long":
        const s = new Uint8Array(9);
        return s[0] = 5, s.set(t.value.bytes, 1), s;
      case "binary":
        const i = new DataView(new ArrayBuffer(3 + t.value.byteLength));
        i.setUint8(0, 6), i.setUint16(1, t.value.byteLength, !1);
        const o = new Uint8Array(i.buffer);
        return o.set(t.value, 3), o;
      case "string":
        const a = Qe(t.value), c = new DataView(new ArrayBuffer(3 + a.byteLength));
        c.setUint8(0, 7), c.setUint16(1, a.byteLength, !1);
        const u = new Uint8Array(c.buffer);
        return u.set(a, 3), u;
      case "timestamp":
        const l = new Uint8Array(9);
        return l[0] = 8, l.set(Pd.fromNumber(t.value.valueOf()).bytes, 1), l;
      case "uuid":
        if (!Nd.test(t.value))
          throw new Error(`Invalid UUID received: ${t.value}`);
        const h = new Uint8Array(17);
        return h[0] = 9, h.set(zo(t.value.replace(/\-/g, "")), 1), h;
    }
  }
}
var Rs;
(function(e) {
  e[e.boolTrue = 0] = "boolTrue", e[e.boolFalse = 1] = "boolFalse", e[e.byte = 2] = "byte", e[e.short = 3] = "short", e[e.integer = 4] = "integer", e[e.long = 5] = "long", e[e.byteArray = 6] = "byteArray", e[e.string = 7] = "string", e[e.timestamp = 8] = "timestamp", e[e.uuid = 9] = "uuid";
})(Rs || (Rs = {}));
const Nd = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
let Pd = class ia {
  constructor(t) {
    if (this.bytes = t, t.byteLength !== 8)
      throw new Error("Int64 buffers must be exactly 8 bytes");
  }
  static fromNumber(t) {
    if (t > 9223372036854776e3 || t < -9223372036854776e3)
      throw new Error(`${t} is too large (or, if negative, too small) to represent as an Int64`);
    const r = new Uint8Array(8);
    for (let n = 7, s = Math.abs(Math.round(t)); n > -1 && s > 0; n--, s /= 256)
      r[n] = s;
    return t < 0 && _s(r), new ia(r);
  }
  valueOf() {
    const t = this.bytes.slice(0), r = t[0] & 128;
    return r && _s(t), parseInt(he(t), 16) * (r ? -1 : 1);
  }
  toString() {
    return String(this.valueOf());
  }
};
function _s(e) {
  for (let t = 0; t < 8; t++)
    e[t] ^= 255;
  for (let t = 7; t > -1 && (e[t]++, e[t] === 0); t--)
    ;
}
const Od = (e, t) => {
  e = e.toLowerCase();
  for (const r of Object.keys(t))
    if (e === r.toLowerCase())
      return !0;
  return !1;
}, oa = ({ headers: e, query: t, ...r }) => ({
  ...r,
  headers: { ...e },
  query: t ? Md(t) : void 0
}), Md = (e) => Object.keys(e).reduce((t, r) => {
  const n = e[r];
  return {
    ...t,
    [r]: Array.isArray(n) ? [...n] : n
  };
}, {}), Id = (e, t = {}) => {
  var s;
  const { headers: r, query: n = {} } = typeof e.clone == "function" ? e.clone() : oa(e);
  for (const i of Object.keys(r)) {
    const o = i.toLowerCase();
    o.slice(0, 6) === "x-amz-" && !((s = t.unhoistableHeaders) != null && s.has(o)) && (n[i] = r[i], delete r[i]);
  }
  return {
    ...e,
    headers: r,
    query: n
  };
}, Ts = (e) => {
  e = typeof e.clone == "function" ? e.clone() : oa(e);
  for (const t of Object.keys(e.headers))
    bd.indexOf(t.toLowerCase()) > -1 && delete e.headers[t];
  return e;
}, Fd = (e) => Dd(e).toISOString().replace(/\.\d{3}Z$/, "Z"), Dd = (e) => typeof e == "number" ? new Date(e * 1e3) : typeof e == "string" ? Number(e) ? new Date(Number(e) * 1e3) : new Date(e) : e;
class hn {
  constructor({ applyChecksum: t, credentials: r, region: n, service: s, sha256: i, uriEscapePath: o = !0 }) {
    this.headerFormatter = new kd(), this.service = s, this.sha256 = i, this.uriEscapePath = o, this.applyChecksum = typeof t == "boolean" ? t : !0, this.regionProvider = ve(n), this.credentialProvider = ve(r);
  }
  async presign(t, r = {}) {
    const { signingDate: n = /* @__PURE__ */ new Date(), expiresIn: s = 3600, unsignableHeaders: i, unhoistableHeaders: o, signableHeaders: a, signingRegion: c, signingService: u } = r, l = await this.credentialProvider();
    this.validateResolvedCredentials(l);
    const h = c ?? await this.regionProvider(), { longDate: p, shortDate: g } = Ht(n);
    if (s > _d)
      return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
    const b = gr(g, h, u ?? this.service), A = Id(Ts(t), { unhoistableHeaders: o });
    l.sessionToken && (A.query[ea] = l.sessionToken), A.query[hd] = hr, A.query[pd] = `${l.accessKeyId}/${b}`, A.query[Qo] = p, A.query[md] = s.toString(10);
    const R = vs(A, i, a);
    return A.query[gd] = Bs(R), A.query[Jo] = await this.getSignature(p, b, this.getSigningKey(l, h, g, u), this.createCanonicalRequest(A, R, await mr(t, this.sha256))), A;
  }
  async sign(t, r) {
    return typeof t == "string" ? this.signString(t, r) : t.headers && t.payload ? this.signEvent(t, r) : t.message ? this.signMessage(t, r) : this.signRequest(t, r);
  }
  async signEvent({ headers: t, payload: r }, { signingDate: n = /* @__PURE__ */ new Date(), priorSignature: s, signingRegion: i, signingService: o }) {
    const a = i ?? await this.regionProvider(), { shortDate: c, longDate: u } = Ht(n), l = gr(c, a, o ?? this.service), h = await mr({ headers: {}, body: r }, this.sha256), p = new this.sha256();
    p.update(t);
    const g = he(await p.digest()), b = [
      Cd,
      u,
      l,
      s,
      g,
      h
    ].join(`
`);
    return this.signString(b, { signingDate: n, signingRegion: a, signingService: o });
  }
  async signMessage(t, { signingDate: r = /* @__PURE__ */ new Date(), signingRegion: n, signingService: s }) {
    return this.signEvent({
      headers: this.headerFormatter.format(t.message.headers),
      payload: t.message.body
    }, {
      signingDate: r,
      signingRegion: n,
      signingService: s,
      priorSignature: t.priorSignature
    }).then((o) => ({ message: t.message, signature: o }));
  }
  async signString(t, { signingDate: r = /* @__PURE__ */ new Date(), signingRegion: n, signingService: s } = {}) {
    const i = await this.credentialProvider();
    this.validateResolvedCredentials(i);
    const o = n ?? await this.regionProvider(), { shortDate: a } = Ht(r), c = new this.sha256(await this.getSigningKey(i, o, a, s));
    return c.update(ot(t)), he(await c.digest());
  }
  async signRequest(t, { signingDate: r = /* @__PURE__ */ new Date(), signableHeaders: n, unsignableHeaders: s, signingRegion: i, signingService: o } = {}) {
    const a = await this.credentialProvider();
    this.validateResolvedCredentials(a);
    const c = i ?? await this.regionProvider(), u = Ts(t), { longDate: l, shortDate: h } = Ht(r), p = gr(h, c, o ?? this.service);
    u.headers[ra] = l, a.sessionToken && (u.headers[xd] = a.sessionToken);
    const g = await mr(u, this.sha256);
    !Od(fn, u.headers) && this.applyChecksum && (u.headers[fn] = g);
    const b = vs(u, s, n), A = await this.getSignature(l, p, this.getSigningKey(a, c, h, o), this.createCanonicalRequest(u, b, g));
    return u.headers[ta] = `${hr} Credential=${a.accessKeyId}/${p}, SignedHeaders=${Bs(b)}, Signature=${A}`, u;
  }
  createCanonicalRequest(t, r, n) {
    const s = Object.keys(r).sort();
    return `${t.method}
${this.getCanonicalPath(t)}
${Bd(t)}
${s.map((i) => `${i}:${r[i]}`).join(`
`)}

${s.join(";")}
${n}`;
  }
  async createStringToSign(t, r, n) {
    const s = new this.sha256();
    s.update(ot(n));
    const i = await s.digest();
    return `${hr}
${t}
${r}
${he(i)}`;
  }
  getCanonicalPath({ path: t }) {
    if (this.uriEscapePath) {
      const r = [];
      for (const i of t.split("/"))
        (i == null ? void 0 : i.length) !== 0 && i !== "." && (i === ".." ? r.pop() : r.push(i));
      const n = `${t != null && t.startsWith("/") ? "/" : ""}${r.join("/")}${r.length > 0 && (t != null && t.endsWith("/")) ? "/" : ""}`;
      return He(n).replace(/%2F/g, "/");
    }
    return t;
  }
  async getSignature(t, r, n, s) {
    const i = await this.createStringToSign(t, r, s), o = new this.sha256(await n);
    return o.update(ot(i)), he(await o.digest());
  }
  getSigningKey(t, r, n, s) {
    return Td(this.sha256, t, n, r, s || this.service);
  }
  validateResolvedCredentials(t) {
    if (typeof t != "object" || typeof t.accessKeyId != "string" || typeof t.secretAccessKey != "string")
      throw new Error("Resolved credential object is not valid");
  }
}
const Ht = (e) => {
  const t = Fd(e).replace(/[\-:]/g, "");
  return {
    longDate: t,
    shortDate: t.slice(0, 8)
  };
}, Bs = (e) => Object.keys(e).sort().join(";");
var ks;
(function(e) {
  e.ENV = "env", e.CONFIG = "shared config entry";
})(ks || (ks = {}));
const Ud = "Directory", $d = "S3Express", Ld = "sigv4-s3express", pn = "X-Amz-S3session-Token", gn = pn.toLowerCase();
class Hd extends hn {
  async signWithCredentials(t, r, n) {
    const s = Ns(r);
    t.headers[gn] = r.sessionToken;
    const i = this;
    return Ps(i, s), i.signRequest(t, n ?? {});
  }
  async presignWithCredentials(t, r, n) {
    const s = Ns(r);
    return delete t.headers[gn], t.headers[pn] = r.sessionToken, t.query = t.query ?? {}, t.query[pn] = r.sessionToken, Ps(this, s), this.presign(t, n);
  }
}
function Ns(e) {
  return {
    accessKeyId: e.accessKeyId,
    secretAccessKey: e.secretAccessKey,
    expiration: e.expiration
  };
}
function Ps(e, t) {
  const r = setTimeout(() => {
    throw new Error("SignatureV4S3Express credential override was created but not called.");
  }, 10), n = e.credentialProvider, s = () => (clearTimeout(r), e.credentialProvider = n, Promise.resolve(t));
  e.credentialProvider = s;
}
const jd = (e) => (t, r) => async (n) => {
  var s, i, o, a, c;
  if (r.endpointV2) {
    const u = r.endpointV2, l = ((o = (i = (s = u.properties) == null ? void 0 : s.authSchemes) == null ? void 0 : i[0]) == null ? void 0 : o.name) === Ld;
    if ((((a = u.properties) == null ? void 0 : a.backend) === $d || ((c = u.properties) == null ? void 0 : c.bucketType) === Ud) && (r.isS3ExpressBucket = !0), l) {
      const p = n.input.Bucket;
      if (p) {
        const g = await e.s3ExpressIdentityProvider.getS3ExpressIdentity(await e.credentials(), {
          Bucket: p
        });
        r.s3ExpressIdentity = g, ge.isInstance(n.request) && g.sessionToken && (n.request.headers[gn] = g.sessionToken);
      }
    }
  }
  return t(n);
}, zd = {
  name: "s3ExpressMiddleware",
  step: "build",
  tags: ["S3", "S3_EXPRESS"],
  override: !0
}, qd = (e) => ({
  applyToStack: (t) => {
    t.add(jd(e), zd);
  }
}), Wd = (e, { session: t }) => {
  const [r, n] = t;
  return {
    ...e,
    forcePathStyle: e.forcePathStyle ?? !1,
    useAccelerateEndpoint: e.useAccelerateEndpoint ?? !1,
    disableMultiregionAccessPoints: e.disableMultiregionAccessPoints ?? !1,
    followRegionRedirects: e.followRegionRedirects ?? !1,
    s3ExpressIdentityProvider: e.s3ExpressIdentityProvider ?? new ar(async (s) => r().send(new n({
      Bucket: s,
      SessionMode: "ReadWrite"
    }))),
    bucketEndpoint: e.bucketEndpoint ?? !1
  };
}, Gd = (e) => typeof e == "string" && e.indexOf("arn:") === 0 && e.split(":").length >= 6;
function Vd(e) {
  return (t, r) => async (n) => {
    var s, i, o, a;
    if (e.bucketEndpoint) {
      const c = r.endpointV2;
      if (c) {
        const u = n.input.Bucket;
        if (typeof u == "string")
          try {
            const l = new URL(u);
            c.url = l;
          } catch (l) {
            const h = `@aws-sdk/middleware-sdk-s3: bucketEndpoint=true was set but Bucket=${u} could not be parsed as URL.`;
            throw ((i = (s = r.logger) == null ? void 0 : s.constructor) == null ? void 0 : i.name) === "NoOpLogger" || (a = (o = r.logger) == null ? void 0 : o.warn) == null || a.call(o, h), l;
          }
      }
    }
    return t(n);
  };
}
const Kd = {
  name: "bucketEndpointMiddleware",
  override: !0,
  relation: "after",
  toMiddleware: "endpointV2Middleware"
};
function Xd({ bucketEndpoint: e }) {
  return (t) => async (r) => {
    const { input: { Bucket: n } } = r;
    if (!e && typeof n == "string" && !Gd(n) && n.indexOf("/") >= 0) {
      const s = new Error(`Bucket name shouldn't contain '/', received '${n}'`);
      throw s.name = "InvalidBucketName", s;
    }
    return t({ ...r });
  };
}
const Zd = {
  step: "initialize",
  tags: ["VALIDATE_BUCKET_NAME"],
  name: "validateBucketNameMiddleware",
  override: !0
}, Yd = (e) => ({
  applyToStack: (t) => {
    t.add(Xd(e), Zd), t.addRelativeTo(Vd(e), Kd);
  }
}), aa = (e, t, r) => {
  let n, s, i, o = !1;
  const a = async () => {
    s || (s = e());
    try {
      n = await s, i = !0, o = !1;
    } finally {
      s = void 0;
    }
    return n;
  };
  return t === void 0 ? async (c) => ((!i || c != null && c.forceRefresh) && (n = await a()), n) : async (c) => ((!i || c != null && c.forceRefresh) && (n = await a()), o ? n : r && !r(n) ? (o = !0, n) : (t(n) && await a(), n));
}, Qd = 3e5, Jd = (e) => {
  const t = e.credentials ? el(e.credentials) : e.credentialDefaultProvider(Object.assign({}, e, {
    parentClientConfig: e
  })), { signingEscapePath: r = !0, systemClockOffset: n = e.systemClockOffset || 0, sha256: s } = e;
  let i;
  return e.signer ? i = ve(e.signer) : e.regionInfoProvider ? i = () => ve(e.region)().then(async (o) => [
    await e.regionInfoProvider(o, {
      useFipsEndpoint: await e.useFipsEndpoint(),
      useDualstackEndpoint: await e.useDualstackEndpoint()
    }) || {},
    o
  ]).then(([o, a]) => {
    const { signingRegion: c, signingService: u } = o;
    e.signingRegion = e.signingRegion || c || a, e.signingName = e.signingName || u || e.serviceId;
    const l = {
      ...e,
      credentials: t,
      region: e.signingRegion,
      service: e.signingName,
      sha256: s,
      uriEscapePath: r
    }, h = e.signerConstructor || hn;
    return new h(l);
  }) : i = async (o) => {
    o = Object.assign({}, {
      name: "sigv4",
      signingName: e.signingName || e.defaultSigningName,
      signingRegion: await ve(e.region)(),
      properties: {}
    }, o);
    const a = (o == null ? void 0 : o.name) === "sigv4a", c = o.signingRegion, u = o.signingName;
    let l;
    a ? l = e.signingRegion || c : (e.signingRegion = e.signingRegion || c, l = e.signingRegion), e.signingName = e.signingName || u || e.serviceId;
    const h = {
      ...e,
      credentials: t,
      region: l,
      service: e.signingName,
      sha256: s,
      uriEscapePath: r
    }, p = e.signerConstructor || hn;
    return new p(h);
  }, {
    ...e,
    systemClockOffset: n,
    signingEscapePath: r,
    credentials: t,
    signer: i
  };
}, el = (e) => typeof e == "function" ? aa(e, (t) => t.expiration !== void 0 && t.expiration.getTime() - Date.now() < Qd, (t) => t.expiration !== void 0) : ve(e), ca = (e) => new Date(Date.now() + e), tl = (e, t) => Math.abs(ca(t).getTime() - e) >= 3e5, Os = (e, t) => {
  const r = Date.parse(e);
  return tl(r, t) ? r - Date.now() : t;
}, rl = (e) => (t, r) => async function(n) {
  var b, A, R, T, I, $, X;
  if (!ge.isInstance(n.request))
    return t(n);
  let s, i;
  const o = (R = (A = (b = r.endpointV2) == null ? void 0 : b.properties) == null ? void 0 : A.authSchemes) == null ? void 0 : R[0], a = ($ = (I = (T = r.endpointV2) == null ? void 0 : T.properties) == null ? void 0 : I.authSchemes) == null ? void 0 : $[1];
  if ((o == null ? void 0 : o.name) === "sigv4a" && a) {
    i = await e.signer(s = o);
    const Z = i;
    (() => {
      var et;
      if (typeof (Z == null ? void 0 : Z.getSigv4aSigner) == "function") {
        if (((et = Z == null ? void 0 : Z.signerOptions) == null ? void 0 : et.runtime) !== "node")
          return !1;
        try {
          return Z.getSigv4aSigner(), !0;
        } catch {
        }
      }
      return !1;
    })() || (i = await e.signer(s = a));
  } else
    i = await e.signer(s = o);
  let u;
  const l = (s == null ? void 0 : s.name) === "sigv4a" ? (X = s == null ? void 0 : s.signingRegionSet) == null ? void 0 : X.join(",") : void 0, h = {
    signingDate: ca(e.systemClockOffset),
    signingRegion: l || r.signing_region,
    signingService: r.signing_service
  };
  if (r.s3ExpressIdentity) {
    if (u = await i.signWithCredentials(n.request, r.s3ExpressIdentity, h), u.headers["X-Amz-Security-Token"] || u.headers["x-amz-security-token"])
      throw new Error("X-Amz-Security-Token must not be set for s3-express requests.");
  } else
    u = await i.sign(n.request, h);
  const p = await t({
    ...n,
    request: u
  }).catch((Z) => {
    const Oe = Z.ServerTime ?? Ms(Z.$response);
    throw Oe && (e.systemClockOffset = Os(Oe, e.systemClockOffset)), Z;
  }), g = Ms(p.response);
  return g && (e.systemClockOffset = Os(g, e.systemClockOffset)), p;
}, Ms = (e) => {
  var t, r;
  return Qt.isInstance(e) ? ((t = e.headers) == null ? void 0 : t.date) ?? ((r = e.headers) == null ? void 0 : r.Date) : void 0;
}, nl = {
  name: "awsAuthMiddleware",
  tags: ["SIGNATURE", "AWSAUTH"],
  relation: "after",
  toMiddleware: "retryMiddleware",
  override: !0
}, sl = (e) => ({
  applyToStack: (t) => {
    t.addRelativeTo(rl(e), nl);
  }
});
function il(e) {
  return {
    ...e,
    customUserAgent: typeof e.customUserAgent == "string" ? [[e.customUserAgent]] : e.customUserAgent
  };
}
const ol = new RegExp("^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$"), ua = (e) => ol.test(e) || e.startsWith("[") && e.endsWith("]"), al = new RegExp("^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$"), Fn = (e, t = !1) => {
  if (!t)
    return al.test(e);
  const r = e.split(".");
  for (const n of r)
    if (!Fn(n))
      return !1;
  return !0;
}, er = {}, Dt = "endpoints";
function ze(e) {
  return typeof e != "object" || e == null ? e : "ref" in e ? `$${ze(e.ref)}` : "fn" in e ? `${e.fn}(${(e.argv || []).map(ze).join(", ")})` : JSON.stringify(e, null, 2);
}
class ye extends Error {
  constructor(t) {
    super(t), this.name = "EndpointError";
  }
}
const cl = (e, t) => e === t, ul = (e) => {
  const t = e.split("."), r = [];
  for (const n of t) {
    const s = n.indexOf("[");
    if (s !== -1) {
      if (n.indexOf("]") !== n.length - 1)
        throw new ye(`Path: '${e}' does not end with ']'`);
      const i = n.slice(s + 1, -1);
      if (Number.isNaN(parseInt(i)))
        throw new ye(`Invalid array index: '${i}' in path: '${e}'`);
      s !== 0 && r.push(n.slice(0, s)), r.push(i);
    } else
      r.push(n);
  }
  return r;
}, da = (e, t) => ul(t).reduce((r, n) => {
  if (typeof r != "object")
    throw new ye(`Index '${n}' in '${t}' not found in '${JSON.stringify(e)}'`);
  return Array.isArray(r) ? r[parseInt(n)] : r[n];
}, e), dl = (e) => e != null, ll = (e) => !e, yr = {
  [Ft.HTTP]: 80,
  [Ft.HTTPS]: 443
}, fl = (e) => {
  const t = (() => {
    try {
      if (e instanceof URL)
        return e;
      if (typeof e == "object" && "hostname" in e) {
        const { hostname: p, port: g, protocol: b = "", path: A = "", query: R = {} } = e, T = new URL(`${b}//${p}${g ? `:${g}` : ""}${A}`);
        return T.search = Object.entries(R).map(([I, $]) => `${I}=${$}`).join("&"), T;
      }
      return new URL(e);
    } catch {
      return null;
    }
  })();
  if (!t)
    return null;
  const r = t.href, { host: n, hostname: s, pathname: i, protocol: o, search: a } = t;
  if (a)
    return null;
  const c = o.slice(0, -1);
  if (!Object.values(Ft).includes(c))
    return null;
  const u = ua(s), l = r.includes(`${n}:${yr[c]}`) || typeof e == "string" && e.includes(`${n}:${yr[c]}`), h = `${n}${l ? `:${yr[c]}` : ""}`;
  return {
    scheme: c,
    authority: h,
    path: i,
    normalizedPath: i.endsWith("/") ? i : `${i}/`,
    isIp: u
  };
}, hl = (e, t) => e === t, pl = (e, t, r, n) => t >= r || e.length < r ? null : n ? e.substring(e.length - r, e.length - t) : e.substring(t, r), gl = (e) => encodeURIComponent(e).replace(/[!*'()]/g, (t) => `%${t.charCodeAt(0).toString(16).toUpperCase()}`), ml = {
  booleanEquals: cl,
  getAttr: da,
  isSet: dl,
  isValidHostLabel: Fn,
  not: ll,
  parseURL: fl,
  stringEquals: hl,
  substring: pl,
  uriEncode: gl
}, la = (e, t) => {
  const r = [], n = {
    ...t.endpointParams,
    ...t.referenceRecord
  };
  let s = 0;
  for (; s < e.length; ) {
    const i = e.indexOf("{", s);
    if (i === -1) {
      r.push(e.slice(s));
      break;
    }
    r.push(e.slice(s, i));
    const o = e.indexOf("}", i);
    if (o === -1) {
      r.push(e.slice(i));
      break;
    }
    e[i + 1] === "{" && e[o + 1] === "}" && (r.push(e.slice(i + 1, o)), s = o + 2);
    const a = e.substring(i + 1, o);
    if (a.includes("#")) {
      const [c, u] = a.split("#");
      r.push(da(n[c], u));
    } else
      r.push(n[a]);
    s = o + 1;
  }
  return r.join("");
}, yl = ({ ref: e }, t) => ({
  ...t.endpointParams,
  ...t.referenceRecord
})[e], cr = (e, t, r) => {
  if (typeof e == "string")
    return la(e, r);
  if (e.fn)
    return fa(e, r);
  if (e.ref)
    return yl(e, r);
  throw new ye(`'${t}': ${String(e)} is not a string, function or reference.`);
}, fa = ({ fn: e, argv: t }, r) => {
  const n = t.map((i) => ["boolean", "number"].includes(typeof i) ? i : cr(i, "arg", r)), s = e.split(".");
  return s[0] in er && s[1] != null ? er[s[0]][s[1]](...n) : ml[e](...n);
}, bl = ({ assign: e, ...t }, r) => {
  var s, i;
  if (e && e in r.referenceRecord)
    throw new ye(`'${e}' is already defined in Reference Record.`);
  const n = fa(t, r);
  return (i = (s = r.logger) == null ? void 0 : s.debug) == null || i.call(s, `${Dt} evaluateCondition: ${ze(t)} = ${ze(n)}`), {
    result: n === "" ? !0 : !!n,
    ...e != null && { toAssign: { name: e, value: n } }
  };
}, Dn = (e = [], t) => {
  var n, s;
  const r = {};
  for (const i of e) {
    const { result: o, toAssign: a } = bl(i, {
      ...t,
      referenceRecord: {
        ...t.referenceRecord,
        ...r
      }
    });
    if (!o)
      return { result: o };
    a && (r[a.name] = a.value, (s = (n = t.logger) == null ? void 0 : n.debug) == null || s.call(n, `${Dt} assign: ${a.name} := ${ze(a.value)}`));
  }
  return { result: !0, referenceRecord: r };
}, wl = (e, t) => Object.entries(e).reduce((r, [n, s]) => ({
  ...r,
  [n]: s.map((i) => {
    const o = cr(i, "Header value entry", t);
    if (typeof o != "string")
      throw new ye(`Header '${n}' value '${o}' is not a string`);
    return o;
  })
}), {}), ha = (e, t) => {
  if (Array.isArray(e))
    return e.map((r) => ha(r, t));
  switch (typeof e) {
    case "string":
      return la(e, t);
    case "object":
      if (e === null)
        throw new ye(`Unexpected endpoint property: ${e}`);
      return pa(e, t);
    case "boolean":
      return e;
    default:
      throw new ye(`Unexpected endpoint property type: ${typeof e}`);
  }
}, pa = (e, t) => Object.entries(e).reduce((r, [n, s]) => ({
  ...r,
  [n]: ha(s, t)
}), {}), xl = (e, t) => {
  const r = cr(e, "Endpoint URL", t);
  if (typeof r == "string")
    try {
      return new URL(r);
    } catch (n) {
      throw n;
    }
  throw new ye(`Endpoint URL must be a string, got ${typeof r}`);
}, El = (e, t) => {
  var l, h;
  const { conditions: r, endpoint: n } = e, { result: s, referenceRecord: i } = Dn(r, t);
  if (!s)
    return;
  const o = {
    ...t,
    referenceRecord: { ...t.referenceRecord, ...i }
  }, { url: a, properties: c, headers: u } = n;
  return (h = (l = t.logger) == null ? void 0 : l.debug) == null || h.call(l, `${Dt} Resolving endpoint from template: ${ze(n)}`), {
    ...u != null && {
      headers: wl(u, o)
    },
    ...c != null && {
      properties: pa(c, o)
    },
    url: xl(a, o)
  };
}, Al = (e, t) => {
  const { conditions: r, error: n } = e, { result: s, referenceRecord: i } = Dn(r, t);
  if (s)
    throw new ye(cr(n, "Error", {
      ...t,
      referenceRecord: { ...t.referenceRecord, ...i }
    }));
}, Sl = (e, t) => {
  const { conditions: r, rules: n } = e, { result: s, referenceRecord: i } = Dn(r, t);
  if (s)
    return ga(n, {
      ...t,
      referenceRecord: { ...t.referenceRecord, ...i }
    });
}, ga = (e, t) => {
  for (const r of e)
    if (r.type === "endpoint") {
      const n = El(r, t);
      if (n)
        return n;
    } else if (r.type === "error")
      Al(r, t);
    else if (r.type === "tree") {
      const n = Sl(r, t);
      if (n)
        return n;
    } else
      throw new ye(`Unknown endpoint rule: ${r}`);
  throw new ye("Rules evaluation failed");
}, Cl = (e, t) => {
  var u, l, h, p, g;
  const { endpointParams: r, logger: n } = t, { parameters: s, rules: i } = e;
  (l = (u = t.logger) == null ? void 0 : u.debug) == null || l.call(u, `${Dt} Initial EndpointParams: ${ze(r)}`);
  const o = Object.entries(s).filter(([, b]) => b.default != null).map(([b, A]) => [b, A.default]);
  if (o.length > 0)
    for (const [b, A] of o)
      r[b] = r[b] ?? A;
  const a = Object.entries(s).filter(([, b]) => b.required).map(([b]) => b);
  for (const b of a)
    if (r[b] == null)
      throw new ye(`Missing required parameter: '${b}'`);
  const c = ga(i, { endpointParams: r, logger: n, referenceRecord: {} });
  if ((h = t.endpointParams) != null && h.Endpoint)
    try {
      const b = new URL(t.endpointParams.Endpoint), { protocol: A, port: R } = b;
      c.url.protocol = A, c.url.port = R;
    } catch {
    }
  return (g = (p = t.logger) == null ? void 0 : p.debug) == null || g.call(p, `${Dt} Resolved endpoint: ${ze(c)}`), c;
}, ma = (e, t = !1) => {
  if (t) {
    for (const r of e.split("."))
      if (!ma(r))
        return !1;
    return !0;
  }
  return !(!Fn(e) || e.length < 3 || e.length > 63 || e !== e.toLowerCase() || ua(e));
}, vl = (e) => {
  const t = e.split(":");
  if (t.length < 6)
    return null;
  const [r, n, s, i, o, ...a] = t;
  return r !== "arn" || n === "" || s === "" || a[0] === "" ? null : {
    partition: n,
    service: s,
    region: i,
    accountId: o,
    resourceId: a[0].includes("/") ? a[0].split("/") : a
  };
}, Rl = [
  {
    id: "aws",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      implicitGlobalRegion: "us-east-1",
      name: "aws",
      supportsDualStack: !0,
      supportsFIPS: !0
    },
    regionRegex: "^(us|eu|ap|sa|ca|me|af|il)\\-\\w+\\-\\d+$",
    regions: {
      "af-south-1": {
        description: "Africa (Cape Town)"
      },
      "ap-east-1": {
        description: "Asia Pacific (Hong Kong)"
      },
      "ap-northeast-1": {
        description: "Asia Pacific (Tokyo)"
      },
      "ap-northeast-2": {
        description: "Asia Pacific (Seoul)"
      },
      "ap-northeast-3": {
        description: "Asia Pacific (Osaka)"
      },
      "ap-south-1": {
        description: "Asia Pacific (Mumbai)"
      },
      "ap-south-2": {
        description: "Asia Pacific (Hyderabad)"
      },
      "ap-southeast-1": {
        description: "Asia Pacific (Singapore)"
      },
      "ap-southeast-2": {
        description: "Asia Pacific (Sydney)"
      },
      "ap-southeast-3": {
        description: "Asia Pacific (Jakarta)"
      },
      "ap-southeast-4": {
        description: "Asia Pacific (Melbourne)"
      },
      "aws-global": {
        description: "AWS Standard global region"
      },
      "ca-central-1": {
        description: "Canada (Central)"
      },
      "ca-west-1": {
        description: "Canada West (Calgary)"
      },
      "eu-central-1": {
        description: "Europe (Frankfurt)"
      },
      "eu-central-2": {
        description: "Europe (Zurich)"
      },
      "eu-north-1": {
        description: "Europe (Stockholm)"
      },
      "eu-south-1": {
        description: "Europe (Milan)"
      },
      "eu-south-2": {
        description: "Europe (Spain)"
      },
      "eu-west-1": {
        description: "Europe (Ireland)"
      },
      "eu-west-2": {
        description: "Europe (London)"
      },
      "eu-west-3": {
        description: "Europe (Paris)"
      },
      "il-central-1": {
        description: "Israel (Tel Aviv)"
      },
      "me-central-1": {
        description: "Middle East (UAE)"
      },
      "me-south-1": {
        description: "Middle East (Bahrain)"
      },
      "sa-east-1": {
        description: "South America (Sao Paulo)"
      },
      "us-east-1": {
        description: "US East (N. Virginia)"
      },
      "us-east-2": {
        description: "US East (Ohio)"
      },
      "us-west-1": {
        description: "US West (N. California)"
      },
      "us-west-2": {
        description: "US West (Oregon)"
      }
    }
  },
  {
    id: "aws-cn",
    outputs: {
      dnsSuffix: "amazonaws.com.cn",
      dualStackDnsSuffix: "api.amazonwebservices.com.cn",
      implicitGlobalRegion: "cn-northwest-1",
      name: "aws-cn",
      supportsDualStack: !0,
      supportsFIPS: !0
    },
    regionRegex: "^cn\\-\\w+\\-\\d+$",
    regions: {
      "aws-cn-global": {
        description: "AWS China global region"
      },
      "cn-north-1": {
        description: "China (Beijing)"
      },
      "cn-northwest-1": {
        description: "China (Ningxia)"
      }
    }
  },
  {
    id: "aws-us-gov",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      implicitGlobalRegion: "us-gov-west-1",
      name: "aws-us-gov",
      supportsDualStack: !0,
      supportsFIPS: !0
    },
    regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
    regions: {
      "aws-us-gov-global": {
        description: "AWS GovCloud (US) global region"
      },
      "us-gov-east-1": {
        description: "AWS GovCloud (US-East)"
      },
      "us-gov-west-1": {
        description: "AWS GovCloud (US-West)"
      }
    }
  },
  {
    id: "aws-iso",
    outputs: {
      dnsSuffix: "c2s.ic.gov",
      dualStackDnsSuffix: "c2s.ic.gov",
      implicitGlobalRegion: "us-iso-east-1",
      name: "aws-iso",
      supportsDualStack: !1,
      supportsFIPS: !0
    },
    regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-global": {
        description: "AWS ISO (US) global region"
      },
      "us-iso-east-1": {
        description: "US ISO East"
      },
      "us-iso-west-1": {
        description: "US ISO WEST"
      }
    }
  },
  {
    id: "aws-iso-b",
    outputs: {
      dnsSuffix: "sc2s.sgov.gov",
      dualStackDnsSuffix: "sc2s.sgov.gov",
      implicitGlobalRegion: "us-isob-east-1",
      name: "aws-iso-b",
      supportsDualStack: !1,
      supportsFIPS: !0
    },
    regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-b-global": {
        description: "AWS ISOB (US) global region"
      },
      "us-isob-east-1": {
        description: "US ISOB East (Ohio)"
      }
    }
  },
  {
    id: "aws-iso-e",
    outputs: {
      dnsSuffix: "cloud.adc-e.uk",
      dualStackDnsSuffix: "cloud.adc-e.uk",
      implicitGlobalRegion: "eu-isoe-west-1",
      name: "aws-iso-e",
      supportsDualStack: !1,
      supportsFIPS: !0
    },
    regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
    regions: {
      "eu-isoe-west-1": {
        description: "EU ISOE West"
      }
    }
  },
  {
    id: "aws-iso-f",
    outputs: {
      dnsSuffix: "csp.hci.ic.gov",
      dualStackDnsSuffix: "csp.hci.ic.gov",
      implicitGlobalRegion: "us-isof-south-1",
      name: "aws-iso-f",
      supportsDualStack: !1,
      supportsFIPS: !0
    },
    regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
    regions: {}
  }
], _l = "1.1", Tl = {
  partitions: Rl,
  version: _l
};
let Bl = Tl;
const kl = (e) => {
  const { partitions: t } = Bl;
  for (const n of t) {
    const { regions: s, outputs: i } = n;
    for (const [o, a] of Object.entries(s))
      if (o === e)
        return {
          ...i,
          ...a
        };
  }
  for (const n of t) {
    const { regionRegex: s, outputs: i } = n;
    if (new RegExp(s).test(e))
      return {
        ...i
      };
  }
  const r = t.find((n) => n.id === "aws");
  if (!r)
    throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
  return {
    ...r.outputs
  };
}, ya = {
  isVirtualHostableS3Bucket: ma,
  parseArn: vl,
  partition: kl
};
er.aws = ya;
const Is = "user-agent", br = "x-amz-user-agent", Fs = " ", wr = "/", Nl = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g, Pl = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g, Ds = "-", Ol = (e) => (t, r) => async (n) => {
  var h, p;
  const { request: s } = n;
  if (!ge.isInstance(s))
    return t(n);
  const { headers: i } = s, o = ((h = r == null ? void 0 : r.userAgent) == null ? void 0 : h.map(xr)) || [], a = (await e.defaultUserAgentProvider()).map(xr), c = ((p = e == null ? void 0 : e.customUserAgent) == null ? void 0 : p.map(xr)) || [], u = [].concat([...a, ...o, ...c]).join(Fs), l = [
    ...a.filter((g) => g.startsWith("aws-sdk-")),
    ...c
  ].join(Fs);
  return e.runtime !== "browser" ? (l && (i[br] = i[br] ? `${i[Is]} ${l}` : l), i[Is] = u) : i[br] = u, t({
    ...n,
    request: s
  });
}, xr = (e) => {
  var o;
  const t = e[0].split(wr).map((a) => a.replace(Nl, Ds)).join(wr), r = (o = e[1]) == null ? void 0 : o.replace(Pl, Ds), n = t.indexOf(wr), s = t.substring(0, n);
  let i = t.substring(n + 1);
  return s === "api" && (i = i.toLowerCase()), [s, i, r].filter((a) => a && a.length > 0).reduce((a, c, u) => {
    switch (u) {
      case 0:
        return c;
      case 1:
        return `${a}/${c}`;
      default:
        return `${a}#${c}`;
    }
  }, "");
}, Ml = {
  name: "getUserAgentMiddleware",
  step: "build",
  priority: "low",
  tags: ["SET_USER_AGENT", "USER_AGENT"],
  override: !0
}, Il = (e) => ({
  applyToStack: (t) => {
    t.add(Ol(e), Ml);
  }
}), Fl = !1, Dl = !1, ba = (e) => typeof e == "string" && (e.startsWith("fips-") || e.endsWith("-fips")), Us = (e) => ba(e) ? ["fips-aws-global", "aws-fips"].includes(e) ? "us-east-1" : e.replace(/fips-(dkr-|prod-)?|-fips/, "") : e, Ul = (e) => {
  const { region: t, useFipsEndpoint: r } = e;
  if (!t)
    throw new Error("Region is missing");
  return {
    ...e,
    region: async () => {
      if (typeof t == "string")
        return Us(t);
      const n = await t();
      return Us(n);
    },
    useFipsEndpoint: async () => {
      const n = typeof t == "string" ? t : await t();
      return ba(n) ? !0 : typeof r != "function" ? Promise.resolve(!!r) : r();
    }
  };
}, $l = (e) => ({
  ...e,
  eventStreamMarshaller: e.eventStreamSerdeProvider(e)
}), $s = "content-length";
function Ll(e) {
  return (t) => async (r) => {
    const n = r.request;
    if (ge.isInstance(n)) {
      const { body: s, headers: i } = n;
      if (s && Object.keys(i).map((o) => o.toLowerCase()).indexOf($s) === -1)
        try {
          const o = e(s);
          n.headers = {
            ...n.headers,
            [$s]: String(o)
          };
        } catch {
        }
    }
    return t({
      ...r,
      request: n
    });
  };
}
const Hl = {
  step: "build",
  tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
  name: "contentLengthMiddleware",
  override: !0
}, jl = (e) => ({
  applyToStack: (t) => {
    t.add(Ll(e.bodyLengthChecker), Hl);
  }
}), zl = async (e) => {
  const t = (e == null ? void 0 : e.Bucket) || "";
  if (typeof e.Bucket == "string" && (e.Bucket = t.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"))), Kl(t)) {
    if (e.ForcePathStyle === !0)
      throw new Error("Path-style addressing cannot be used with ARN buckets");
  } else
    (!Vl(t) || t.indexOf(".") !== -1 && !String(e.Endpoint).startsWith("http:") || t.toLowerCase() !== t || t.length < 3) && (e.ForcePathStyle = !0);
  return e.DisableMultiRegionAccessPoints && (e.disableMultiRegionAccessPoints = !0, e.DisableMRAP = !0), e;
}, ql = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/, Wl = /(\d+\.){3}\d+/, Gl = /\.\./, Vl = (e) => ql.test(e) && !Wl.test(e) && !Gl.test(e), Kl = (e) => {
  const [t, r, n, , , s] = e.split(":"), i = t === "arn" && e.split(":").length >= 6, o = !!(i && r && n && s);
  if (i && !o)
    throw new Error(`Invalid ARN: ${e} was an invalid ARN.`);
  return o;
}, Xl = (e, t, r) => {
  const n = async () => {
    const s = r[e] ?? r[t];
    return typeof s == "function" ? s() : s;
  };
  return e === "credentialScope" || t === "CredentialScope" ? async () => {
    const s = typeof r.credentials == "function" ? await r.credentials() : r.credentials;
    return (s == null ? void 0 : s.credentialScope) ?? (s == null ? void 0 : s.CredentialScope);
  } : e === "endpoint" || t === "endpoint" ? async () => {
    const s = await n();
    if (s && typeof s == "object") {
      if ("url" in s)
        return s.url.href;
      if ("hostname" in s) {
        const { protocol: i, hostname: o, port: a, path: c } = s;
        return `${i}//${o}${a ? ":" + a : ""}${c}`;
      }
    }
    return s;
  } : n;
}, Zl = async (e) => {
};
function Yl(e) {
  const t = {};
  if (e = e.replace(/^\?/, ""), e)
    for (const r of e.split("&")) {
      let [n, s = null] = r.split("=");
      n = decodeURIComponent(n), s && (s = decodeURIComponent(s)), n in t ? Array.isArray(t[n]) ? t[n].push(s) : t[n] = [t[n], s] : t[n] = s;
    }
  return t;
}
const tr = (e) => {
  if (typeof e == "string")
    return tr(new URL(e));
  const { hostname: t, pathname: r, port: n, protocol: s, search: i } = e;
  let o;
  return i && (o = Yl(i)), {
    hostname: t,
    port: n ? parseInt(n) : void 0,
    protocol: s,
    path: r,
    query: o
  };
}, wa = (e) => typeof e == "object" ? "url" in e ? tr(e.url) : e : tr(e), Ql = async (e, t, r, n) => {
  if (!r.endpoint) {
    const o = await Zl(r.serviceId || "");
    o && (r.endpoint = () => Promise.resolve(wa(o)));
  }
  const s = await Jl(e, t, r);
  if (typeof r.endpointProvider != "function")
    throw new Error("config.endpointProvider is not set.");
  return r.endpointProvider(s, n);
}, Jl = async (e, t, r) => {
  var i;
  const n = {}, s = ((i = t == null ? void 0 : t.getEndpointParameterInstructions) == null ? void 0 : i.call(t)) || {};
  for (const [o, a] of Object.entries(s))
    switch (a.type) {
      case "staticContextParams":
        n[o] = a.value;
        break;
      case "contextParams":
        n[o] = e[a.name];
        break;
      case "clientContextParams":
      case "builtInParams":
        n[o] = await Xl(a.name, o, r)();
        break;
      default:
        throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(a));
    }
  return Object.keys(s).length === 0 && Object.assign(n, r), String(r.serviceId).toLowerCase() === "s3" && await zl(n), n;
}, ef = ({ config: e, instructions: t }) => (r, n) => async (s) => {
  var a, c, u;
  const i = await Ql(s.input, {
    getEndpointParameterInstructions() {
      return t;
    }
  }, { ...e }, n);
  n.endpointV2 = i, n.authSchemes = (a = i.properties) == null ? void 0 : a.authSchemes;
  const o = (c = n.authSchemes) == null ? void 0 : c[0];
  if (o) {
    n.signing_region = o.signingRegion, n.signing_service = o.signingName;
    const l = fd(n), h = (u = l == null ? void 0 : l.selectedHttpAuthScheme) == null ? void 0 : u.httpAuthOption;
    h && (h.signingProperties = Object.assign(h.signingProperties || {}, {
      signing_region: o.signingRegion,
      signingRegion: o.signingRegion,
      signing_service: o.signingName,
      signingName: o.signingName,
      signingRegionSet: o.signingRegionSet
    }, o.properties));
  }
  return r({
    ...s
  });
}, tf = (e, t) => (r) => async (n) => {
  const { response: s } = await r(n);
  try {
    const i = await t(s, e);
    return {
      response: s,
      output: i
    };
  } catch (i) {
    if (Object.defineProperty(i, "$response", {
      value: s
    }), !("$metadata" in i)) {
      const o = "Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.";
      i.message += `
  ` + o, typeof i.$responseBodyText < "u" && i.$response && (i.$response.body = i.$responseBodyText);
    }
    throw i;
  }
}, rf = (e, t) => (r, n) => async (s) => {
  var a;
  const i = (a = n.endpointV2) != null && a.url && e.urlParser ? async () => e.urlParser(n.endpointV2.url) : e.endpoint;
  if (!i)
    throw new Error("No valid endpoint provider available.");
  const o = await t(s.input, { ...e, endpoint: i });
  return r({
    ...s,
    request: o
  });
}, nf = {
  name: "deserializerMiddleware",
  step: "deserialize",
  tags: ["DESERIALIZER"],
  override: !0
}, Un = {
  name: "serializerMiddleware",
  step: "serialize",
  tags: ["SERIALIZER"],
  override: !0
};
function xa(e, t, r) {
  return {
    applyToStack: (n) => {
      n.add(tf(e, r), nf), n.add(rf(e, t), Un);
    }
  };
}
const Ea = {
  step: "serialize",
  tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
  name: "endpointV2Middleware",
  override: !0,
  relation: "before",
  toMiddleware: Un.name
}, Aa = (e, t) => ({
  applyToStack: (r) => {
    r.addRelativeTo(ef({
      config: e,
      instructions: t
    }), Ea);
  }
}), sf = (e) => {
  const t = e.tls ?? !0, { endpoint: r } = e, n = r != null ? async () => wa(await ve(r)()) : void 0;
  return {
    ...e,
    endpoint: n,
    tls: t,
    isCustomEndpoint: !!r,
    useDualstackEndpoint: ve(e.useDualstackEndpoint ?? !1),
    useFipsEndpoint: ve(e.useFipsEndpoint ?? !1)
  };
};
var at;
(function(e) {
  e.STANDARD = "standard", e.ADAPTIVE = "adaptive";
})(at || (at = {}));
const $n = 3, of = at.STANDARD, af = [
  "BandwidthLimitExceeded",
  "EC2ThrottledException",
  "LimitExceededException",
  "PriorRequestNotComplete",
  "ProvisionedThroughputExceededException",
  "RequestLimitExceeded",
  "RequestThrottled",
  "RequestThrottledException",
  "SlowDown",
  "ThrottledException",
  "Throttling",
  "ThrottlingException",
  "TooManyRequestsException",
  "TransactionInProgressException"
], cf = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"], uf = [500, 502, 503, 504], df = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"], lf = (e) => {
  var t;
  return (t = e.$metadata) == null ? void 0 : t.clockSkewCorrected;
}, Sa = (e) => {
  var t, r;
  return ((t = e.$metadata) == null ? void 0 : t.httpStatusCode) === 429 || af.includes(e.name) || ((r = e.$retryable) == null ? void 0 : r.throttling) == !0;
}, Ca = (e) => {
  var t;
  return lf(e) || cf.includes(e.name) || df.includes((e == null ? void 0 : e.code) || "") || uf.includes(((t = e.$metadata) == null ? void 0 : t.httpStatusCode) || 0);
}, ff = (e) => {
  var t;
  if (((t = e.$metadata) == null ? void 0 : t.httpStatusCode) !== void 0) {
    const r = e.$metadata.httpStatusCode;
    return 500 <= r && r <= 599 && !Ca(e);
  }
  return !1;
};
class hf {
  constructor(t) {
    this.currentCapacity = 0, this.enabled = !1, this.lastMaxRate = 0, this.measuredTxRate = 0, this.requestCount = 0, this.lastTimestamp = 0, this.timeWindow = 0, this.beta = (t == null ? void 0 : t.beta) ?? 0.7, this.minCapacity = (t == null ? void 0 : t.minCapacity) ?? 1, this.minFillRate = (t == null ? void 0 : t.minFillRate) ?? 0.5, this.scaleConstant = (t == null ? void 0 : t.scaleConstant) ?? 0.4, this.smooth = (t == null ? void 0 : t.smooth) ?? 0.8;
    const r = this.getCurrentTimeInSeconds();
    this.lastThrottleTime = r, this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds()), this.fillRate = this.minFillRate, this.maxCapacity = this.minCapacity;
  }
  getCurrentTimeInSeconds() {
    return Date.now() / 1e3;
  }
  async getSendToken() {
    return this.acquireTokenBucket(1);
  }
  async acquireTokenBucket(t) {
    if (this.enabled) {
      if (this.refillTokenBucket(), t > this.currentCapacity) {
        const r = (t - this.currentCapacity) / this.fillRate * 1e3;
        await new Promise((n) => setTimeout(n, r));
      }
      this.currentCapacity = this.currentCapacity - t;
    }
  }
  refillTokenBucket() {
    const t = this.getCurrentTimeInSeconds();
    if (!this.lastTimestamp) {
      this.lastTimestamp = t;
      return;
    }
    const r = (t - this.lastTimestamp) * this.fillRate;
    this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + r), this.lastTimestamp = t;
  }
  updateClientSendingRate(t) {
    let r;
    if (this.updateMeasuredRate(), Sa(t)) {
      const s = this.enabled ? Math.min(this.measuredTxRate, this.fillRate) : this.measuredTxRate;
      this.lastMaxRate = s, this.calculateTimeWindow(), this.lastThrottleTime = this.getCurrentTimeInSeconds(), r = this.cubicThrottle(s), this.enableTokenBucket();
    } else
      this.calculateTimeWindow(), r = this.cubicSuccess(this.getCurrentTimeInSeconds());
    const n = Math.min(r, 2 * this.measuredTxRate);
    this.updateTokenBucketRate(n);
  }
  calculateTimeWindow() {
    this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
  }
  cubicThrottle(t) {
    return this.getPrecise(t * this.beta);
  }
  cubicSuccess(t) {
    return this.getPrecise(this.scaleConstant * Math.pow(t - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
  }
  enableTokenBucket() {
    this.enabled = !0;
  }
  updateTokenBucketRate(t) {
    this.refillTokenBucket(), this.fillRate = Math.max(t, this.minFillRate), this.maxCapacity = Math.max(t, this.minCapacity), this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
  }
  updateMeasuredRate() {
    const t = this.getCurrentTimeInSeconds(), r = Math.floor(t * 2) / 2;
    if (this.requestCount++, r > this.lastTxRateBucket) {
      const n = this.requestCount / (r - this.lastTxRateBucket);
      this.measuredTxRate = this.getPrecise(n * this.smooth + this.measuredTxRate * (1 - this.smooth)), this.requestCount = 0, this.lastTxRateBucket = r;
    }
  }
  getPrecise(t) {
    return parseFloat(t.toFixed(8));
  }
}
const mn = 100, va = 20 * 1e3, pf = 500, Ls = 500, gf = 5, mf = 10, yf = 1, bf = "amz-sdk-invocation-id", wf = "amz-sdk-request", xf = () => {
  let e = mn;
  return {
    computeNextBackoffDelay: (n) => Math.floor(Math.min(va, Math.random() * 2 ** n * e)),
    setDelayBase: (n) => {
      e = n;
    }
  };
}, Hs = ({ retryDelay: e, retryCount: t, retryCost: r }) => ({
  getRetryCount: () => t,
  getRetryDelay: () => Math.min(va, e),
  getRetryCost: () => r
});
class Ra {
  constructor(t) {
    this.maxAttempts = t, this.mode = at.STANDARD, this.capacity = Ls, this.retryBackoffStrategy = xf(), this.maxAttemptsProvider = typeof t == "function" ? t : async () => t;
  }
  async acquireInitialRetryToken(t) {
    return Hs({
      retryDelay: mn,
      retryCount: 0
    });
  }
  async refreshRetryTokenForRetry(t, r) {
    const n = await this.getMaxAttempts();
    if (this.shouldRetry(t, r, n)) {
      const s = r.errorType;
      this.retryBackoffStrategy.setDelayBase(s === "THROTTLING" ? pf : mn);
      const i = this.retryBackoffStrategy.computeNextBackoffDelay(t.getRetryCount()), o = r.retryAfterHint ? Math.max(r.retryAfterHint.getTime() - Date.now() || 0, i) : i, a = this.getCapacityCost(s);
      return this.capacity -= a, Hs({
        retryDelay: o,
        retryCount: t.getRetryCount() + 1,
        retryCost: a
      });
    }
    throw new Error("No retry token available");
  }
  recordSuccess(t) {
    this.capacity = Math.max(Ls, this.capacity + (t.getRetryCost() ?? yf));
  }
  getCapacity() {
    return this.capacity;
  }
  async getMaxAttempts() {
    try {
      return await this.maxAttemptsProvider();
    } catch {
      return $n;
    }
  }
  shouldRetry(t, r, n) {
    return t.getRetryCount() + 1 < n && this.capacity >= this.getCapacityCost(r.errorType) && this.isRetryableError(r.errorType);
  }
  getCapacityCost(t) {
    return t === "TRANSIENT" ? mf : gf;
  }
  isRetryableError(t) {
    return t === "THROTTLING" || t === "TRANSIENT";
  }
}
class Ef {
  constructor(t, r) {
    this.maxAttemptsProvider = t, this.mode = at.ADAPTIVE;
    const { rateLimiter: n } = r ?? {};
    this.rateLimiter = n ?? new hf(), this.standardRetryStrategy = new Ra(t);
  }
  async acquireInitialRetryToken(t) {
    return await this.rateLimiter.getSendToken(), this.standardRetryStrategy.acquireInitialRetryToken(t);
  }
  async refreshRetryTokenForRetry(t, r) {
    return this.rateLimiter.updateClientSendingRate(r), this.standardRetryStrategy.refreshRetryTokenForRetry(t, r);
  }
  recordSuccess(t) {
    this.rateLimiter.updateClientSendingRate({}), this.standardRetryStrategy.recordSuccess(t);
  }
}
let jt;
const Af = new Uint8Array(16);
function Sf() {
  if (!jt && (jt = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !jt))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return jt(Af);
}
const re = [];
for (let e = 0; e < 256; ++e)
  re.push((e + 256).toString(16).slice(1));
function Cf(e, t = 0) {
  return re[e[t + 0]] + re[e[t + 1]] + re[e[t + 2]] + re[e[t + 3]] + "-" + re[e[t + 4]] + re[e[t + 5]] + "-" + re[e[t + 6]] + re[e[t + 7]] + "-" + re[e[t + 8]] + re[e[t + 9]] + "-" + re[e[t + 10]] + re[e[t + 11]] + re[e[t + 12]] + re[e[t + 13]] + re[e[t + 14]] + re[e[t + 15]];
}
const vf = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), js = {
  randomUUID: vf
};
function Rf(e, t, r) {
  if (js.randomUUID && !t && !e)
    return js.randomUUID();
  e = e || {};
  const n = e.random || (e.rng || Sf)();
  if (n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, t) {
    r = r || 0;
    for (let s = 0; s < 16; ++s)
      t[r + s] = n[s];
    return t;
  }
  return Cf(n);
}
const _f = (e) => e instanceof Error ? e : e instanceof Object ? Object.assign(new Error(), e) : typeof e == "string" ? new Error(e) : new Error(`AWS SDK error wrapper for ${e}`), Tf = (e) => {
  const { retryStrategy: t } = e, r = ve(e.maxAttempts ?? $n);
  return {
    ...e,
    maxAttempts: r,
    retryStrategy: async () => t || (await ve(e.retryMode)() === at.ADAPTIVE ? new Ef(r) : new Ra(r))
  };
}, Bf = (e) => (e == null ? void 0 : e.body) instanceof ReadableStream, kf = (e) => (t, r) => async (n) => {
  var o;
  let s = await e.retryStrategy();
  const i = await e.maxAttempts();
  if (Nf(s)) {
    s = s;
    let a = await s.acquireInitialRetryToken(r.partition_id), c = new Error(), u = 0, l = 0;
    const { request: h } = n, p = ge.isInstance(h);
    for (p && (h.headers[bf] = Rf()); ; )
      try {
        p && (h.headers[wf] = `attempt=${u + 1}; max=${i}`);
        const { response: g, output: b } = await t(n);
        return s.recordSuccess(a), b.$metadata.attempts = u + 1, b.$metadata.totalRetryDelay = l, { response: g, output: b };
      } catch (g) {
        const b = Pf(g);
        if (c = _f(g), p && Bf(h))
          throw (o = r.logger instanceof Tn ? console : r.logger) == null || o.warn("An error was encountered in a non-retryable streaming request."), c;
        try {
          a = await s.refreshRetryTokenForRetry(a, b);
        } catch {
          throw c.$metadata || (c.$metadata = {}), c.$metadata.attempts = u + 1, c.$metadata.totalRetryDelay = l, c;
        }
        u = a.getRetryCount();
        const A = a.getRetryDelay();
        l += A, await new Promise((R) => setTimeout(R, A));
      }
  } else
    return s = s, s != null && s.mode && (r.userAgent = [...r.userAgent || [], ["cfg/retry-mode", s.mode]]), s.retry(t, n);
}, Nf = (e) => typeof e.acquireInitialRetryToken < "u" && typeof e.refreshRetryTokenForRetry < "u" && typeof e.recordSuccess < "u", Pf = (e) => {
  const t = {
    error: e,
    errorType: Of(e)
  }, r = If(e.$response);
  return r && (t.retryAfterHint = r), t;
}, Of = (e) => Sa(e) ? "THROTTLING" : Ca(e) ? "TRANSIENT" : ff(e) ? "SERVER_ERROR" : "CLIENT_ERROR", _a = {
  name: "retryMiddleware",
  tags: ["RETRY"],
  step: "finalizeRequest",
  priority: "high",
  override: !0
}, Mf = (e) => ({
  applyToStack: (t) => {
    t.add(kf(e), _a);
  }
}), If = (e) => {
  if (!Qt.isInstance(e))
    return;
  const t = Object.keys(e.headers).find((i) => i.toLowerCase() === "retry-after");
  if (!t)
    return;
  const r = e.headers[t], n = Number(r);
  return Number.isNaN(n) ? new Date(r) : new Date(n * 1e3);
}, Ff = (e) => ({
  ...e,
  useFipsEndpoint: e.useFipsEndpoint ?? !1,
  useDualstackEndpoint: e.useDualstackEndpoint ?? !1,
  forcePathStyle: e.forcePathStyle ?? !1,
  useAccelerateEndpoint: e.useAccelerateEndpoint ?? !1,
  useGlobalEndpoint: e.useGlobalEndpoint ?? !1,
  disableMultiregionAccessPoints: e.disableMultiregionAccessPoints ?? !1,
  defaultSigningName: "s3"
}), Ta = {
  ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
  UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
  DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
  Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
  DisableS3ExpressSessionAuth: { type: "clientContextParams", name: "disableS3ExpressSessionAuth" },
  UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
  UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
  Endpoint: { type: "builtInParams", name: "endpoint" },
  Region: { type: "builtInParams", name: "region" },
  UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
};
class Ee extends In {
  constructor(t) {
    super(t), Object.setPrototypeOf(this, Ee.prototype);
  }
}
class Ln extends Ee {
  constructor(t) {
    super({
      name: "NoSuchUpload",
      $fault: "client",
      ...t
    }), this.name = "NoSuchUpload", this.$fault = "client", Object.setPrototypeOf(this, Ln.prototype);
  }
}
class Hn extends Ee {
  constructor(t) {
    super({
      name: "ObjectNotInActiveTierError",
      $fault: "client",
      ...t
    }), this.name = "ObjectNotInActiveTierError", this.$fault = "client", Object.setPrototypeOf(this, Hn.prototype);
  }
}
class jn extends Ee {
  constructor(t) {
    super({
      name: "BucketAlreadyExists",
      $fault: "client",
      ...t
    }), this.name = "BucketAlreadyExists", this.$fault = "client", Object.setPrototypeOf(this, jn.prototype);
  }
}
class zn extends Ee {
  constructor(t) {
    super({
      name: "BucketAlreadyOwnedByYou",
      $fault: "client",
      ...t
    }), this.name = "BucketAlreadyOwnedByYou", this.$fault = "client", Object.setPrototypeOf(this, zn.prototype);
  }
}
class qn extends Ee {
  constructor(t) {
    super({
      name: "NoSuchBucket",
      $fault: "client",
      ...t
    }), this.name = "NoSuchBucket", this.$fault = "client", Object.setPrototypeOf(this, qn.prototype);
  }
}
var zs;
(function(e) {
  e.visit = (t, r) => t.Prefix !== void 0 ? r.Prefix(t.Prefix) : t.Tag !== void 0 ? r.Tag(t.Tag) : t.And !== void 0 ? r.And(t.And) : r._(t.$unknown[0], t.$unknown[1]);
})(zs || (zs = {}));
var qs;
(function(e) {
  e.visit = (t, r) => t.Prefix !== void 0 ? r.Prefix(t.Prefix) : t.Tag !== void 0 ? r.Tag(t.Tag) : t.ObjectSizeGreaterThan !== void 0 ? r.ObjectSizeGreaterThan(t.ObjectSizeGreaterThan) : t.ObjectSizeLessThan !== void 0 ? r.ObjectSizeLessThan(t.ObjectSizeLessThan) : t.And !== void 0 ? r.And(t.And) : r._(t.$unknown[0], t.$unknown[1]);
})(qs || (qs = {}));
var Ws;
(function(e) {
  e.visit = (t, r) => t.Prefix !== void 0 ? r.Prefix(t.Prefix) : t.Tag !== void 0 ? r.Tag(t.Tag) : t.AccessPointArn !== void 0 ? r.AccessPointArn(t.AccessPointArn) : t.And !== void 0 ? r.And(t.And) : r._(t.$unknown[0], t.$unknown[1]);
})(Ws || (Ws = {}));
var Gs;
(function(e) {
  e.visit = (t, r) => t.Prefix !== void 0 ? r.Prefix(t.Prefix) : t.Tag !== void 0 ? r.Tag(t.Tag) : t.And !== void 0 ? r.And(t.And) : r._(t.$unknown[0], t.$unknown[1]);
})(Gs || (Gs = {}));
class Wn extends Ee {
  constructor(t) {
    super({
      name: "InvalidObjectState",
      $fault: "client",
      ...t
    }), this.name = "InvalidObjectState", this.$fault = "client", Object.setPrototypeOf(this, Wn.prototype), this.StorageClass = t.StorageClass, this.AccessTier = t.AccessTier;
  }
}
class Gn extends Ee {
  constructor(t) {
    super({
      name: "NoSuchKey",
      $fault: "client",
      ...t
    }), this.name = "NoSuchKey", this.$fault = "client", Object.setPrototypeOf(this, Gn.prototype);
  }
}
class Vn extends Ee {
  constructor(t) {
    super({
      name: "NotFound",
      $fault: "client",
      ...t
    }), this.name = "NotFound", this.$fault = "client", Object.setPrototypeOf(this, Vn.prototype);
  }
}
const Df = (e) => ({
  ...e,
  ...e.SecretAccessKey && { SecretAccessKey: Ye },
  ...e.SessionToken && { SessionToken: Ye }
}), Uf = (e) => ({
  ...e,
  ...e.Credentials && { Credentials: Df(e.Credentials) }
});
Ea.name;
Un.name;
_a.name;
function Ba(e, t) {
  return new $f(e, t);
}
class $f {
  constructor(t, r) {
    this.input = t, this.context = r, this.query = {}, this.method = "", this.headers = {}, this.path = "", this.body = null, this.hostname = "", this.resolvePathStack = [];
  }
  async build() {
    const { hostname: t, protocol: r = "https", port: n, path: s } = await this.context.endpoint();
    this.path = s;
    for (const i of this.resolvePathStack)
      i(this.path);
    return new ge({
      protocol: r,
      hostname: this.hostname || t,
      port: n,
      method: this.method,
      path: this.path,
      query: this.query,
      body: this.body,
      headers: this.headers
    });
  }
  hn(t) {
    return this.hostname = t, this;
  }
  bp(t) {
    return this.resolvePathStack.push((r) => {
      this.path = `${r != null && r.endsWith("/") ? r.slice(0, -1) : r || ""}` + t;
    }), this;
  }
  p(t, r, n, s) {
    return this.resolvePathStack.push((i) => {
      this.path = td(i, this.input, t, r, n, s);
    }), this;
  }
  h(t) {
    return this.headers = t, this;
  }
  q(t) {
    return this.query = t, this;
  }
  b(t) {
    return this.body = t, this;
  }
  m(t) {
    return this.method = t, this;
  }
}
const Lf = (e, t) => qo(e, t).then((r) => t.utf8Encoder(r));
var Kn = {}, ur = {};
(function(e) {
  const t = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", r = t + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040", n = "[" + t + "][" + r + "]*", s = new RegExp("^" + n + "$"), i = function(a, c) {
    const u = [];
    let l = c.exec(a);
    for (; l; ) {
      const h = [];
      h.startIndex = c.lastIndex - l[0].length;
      const p = l.length;
      for (let g = 0; g < p; g++)
        h.push(l[g]);
      u.push(h), l = c.exec(a);
    }
    return u;
  }, o = function(a) {
    const c = s.exec(a);
    return !(c === null || typeof c > "u");
  };
  e.isExist = function(a) {
    return typeof a < "u";
  }, e.isEmptyObject = function(a) {
    return Object.keys(a).length === 0;
  }, e.merge = function(a, c, u) {
    if (c) {
      const l = Object.keys(c), h = l.length;
      for (let p = 0; p < h; p++)
        u === "strict" ? a[l[p]] = [c[l[p]]] : a[l[p]] = c[l[p]];
    }
  }, e.getValue = function(a) {
    return e.isExist(a) ? a : "";
  }, e.isName = o, e.getAllMatches = i, e.nameRegexp = n;
})(ur);
const Xn = ur, Hf = {
  allowBooleanAttributes: !1,
  //A tag can have attributes without any value
  unpairedTags: []
};
Kn.validate = function(e, t) {
  t = Object.assign({}, Hf, t);
  const r = [];
  let n = !1, s = !1;
  e[0] === "\uFEFF" && (e = e.substr(1));
  for (let i = 0; i < e.length; i++)
    if (e[i] === "<" && e[i + 1] === "?") {
      if (i += 2, i = Ks(e, i), i.err)
        return i;
    } else if (e[i] === "<") {
      let o = i;
      if (i++, e[i] === "!") {
        i = Xs(e, i);
        continue;
      } else {
        let a = !1;
        e[i] === "/" && (a = !0, i++);
        let c = "";
        for (; i < e.length && e[i] !== ">" && e[i] !== " " && e[i] !== "	" && e[i] !== `
` && e[i] !== "\r"; i++)
          c += e[i];
        if (c = c.trim(), c[c.length - 1] === "/" && (c = c.substring(0, c.length - 1), i--), !Xf(c)) {
          let h;
          return c.trim().length === 0 ? h = "Invalid space after '<'." : h = "Tag '" + c + "' is an invalid name.", G("InvalidTag", h, fe(e, i));
        }
        const u = qf(e, i);
        if (u === !1)
          return G("InvalidAttr", "Attributes for '" + c + "' have open quote.", fe(e, i));
        let l = u.value;
        if (i = u.index, l[l.length - 1] === "/") {
          const h = i - l.length;
          l = l.substring(0, l.length - 1);
          const p = Zs(l, t);
          if (p === !0)
            n = !0;
          else
            return G(p.err.code, p.err.msg, fe(e, h + p.err.line));
        } else if (a)
          if (u.tagClosed) {
            if (l.trim().length > 0)
              return G("InvalidTag", "Closing tag '" + c + "' can't have attributes or invalid starting.", fe(e, o));
            {
              const h = r.pop();
              if (c !== h.tagName) {
                let p = fe(e, h.tagStartPos);
                return G(
                  "InvalidTag",
                  "Expected closing tag '" + h.tagName + "' (opened in line " + p.line + ", col " + p.col + ") instead of closing tag '" + c + "'.",
                  fe(e, o)
                );
              }
              r.length == 0 && (s = !0);
            }
          } else
            return G("InvalidTag", "Closing tag '" + c + "' doesn't have proper closing.", fe(e, i));
        else {
          const h = Zs(l, t);
          if (h !== !0)
            return G(h.err.code, h.err.msg, fe(e, i - l.length + h.err.line));
          if (s === !0)
            return G("InvalidXml", "Multiple possible root nodes found.", fe(e, i));
          t.unpairedTags.indexOf(c) !== -1 || r.push({ tagName: c, tagStartPos: o }), n = !0;
        }
        for (i++; i < e.length; i++)
          if (e[i] === "<")
            if (e[i + 1] === "!") {
              i++, i = Xs(e, i);
              continue;
            } else if (e[i + 1] === "?") {
              if (i = Ks(e, ++i), i.err)
                return i;
            } else
              break;
          else if (e[i] === "&") {
            const h = Vf(e, i);
            if (h == -1)
              return G("InvalidChar", "char '&' is not expected.", fe(e, i));
            i = h;
          } else if (s === !0 && !Vs(e[i]))
            return G("InvalidXml", "Extra text at the end", fe(e, i));
        e[i] === "<" && i--;
      }
    } else {
      if (Vs(e[i]))
        continue;
      return G("InvalidChar", "char '" + e[i] + "' is not expected.", fe(e, i));
    }
  if (n) {
    if (r.length == 1)
      return G("InvalidTag", "Unclosed tag '" + r[0].tagName + "'.", fe(e, r[0].tagStartPos));
    if (r.length > 0)
      return G("InvalidXml", "Invalid '" + JSON.stringify(r.map((i) => i.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
  } else
    return G("InvalidXml", "Start tag expected.", 1);
  return !0;
};
function Vs(e) {
  return e === " " || e === "	" || e === `
` || e === "\r";
}
function Ks(e, t) {
  const r = t;
  for (; t < e.length; t++)
    if (e[t] == "?" || e[t] == " ") {
      const n = e.substr(r, t - r);
      if (t > 5 && n === "xml")
        return G("InvalidXml", "XML declaration allowed only at the start of the document.", fe(e, t));
      if (e[t] == "?" && e[t + 1] == ">") {
        t++;
        break;
      } else
        continue;
    }
  return t;
}
function Xs(e, t) {
  if (e.length > t + 5 && e[t + 1] === "-" && e[t + 2] === "-") {
    for (t += 3; t < e.length; t++)
      if (e[t] === "-" && e[t + 1] === "-" && e[t + 2] === ">") {
        t += 2;
        break;
      }
  } else if (e.length > t + 8 && e[t + 1] === "D" && e[t + 2] === "O" && e[t + 3] === "C" && e[t + 4] === "T" && e[t + 5] === "Y" && e[t + 6] === "P" && e[t + 7] === "E") {
    let r = 1;
    for (t += 8; t < e.length; t++)
      if (e[t] === "<")
        r++;
      else if (e[t] === ">" && (r--, r === 0))
        break;
  } else if (e.length > t + 9 && e[t + 1] === "[" && e[t + 2] === "C" && e[t + 3] === "D" && e[t + 4] === "A" && e[t + 5] === "T" && e[t + 6] === "A" && e[t + 7] === "[") {
    for (t += 8; t < e.length; t++)
      if (e[t] === "]" && e[t + 1] === "]" && e[t + 2] === ">") {
        t += 2;
        break;
      }
  }
  return t;
}
const jf = '"', zf = "'";
function qf(e, t) {
  let r = "", n = "", s = !1;
  for (; t < e.length; t++) {
    if (e[t] === jf || e[t] === zf)
      n === "" ? n = e[t] : n !== e[t] || (n = "");
    else if (e[t] === ">" && n === "") {
      s = !0;
      break;
    }
    r += e[t];
  }
  return n !== "" ? !1 : {
    value: r,
    index: t,
    tagClosed: s
  };
}
const Wf = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
function Zs(e, t) {
  const r = Xn.getAllMatches(e, Wf), n = {};
  for (let s = 0; s < r.length; s++) {
    if (r[s][1].length === 0)
      return G("InvalidAttr", "Attribute '" + r[s][2] + "' has no space in starting.", lt(r[s]));
    if (r[s][3] !== void 0 && r[s][4] === void 0)
      return G("InvalidAttr", "Attribute '" + r[s][2] + "' is without value.", lt(r[s]));
    if (r[s][3] === void 0 && !t.allowBooleanAttributes)
      return G("InvalidAttr", "boolean attribute '" + r[s][2] + "' is not allowed.", lt(r[s]));
    const i = r[s][2];
    if (!Kf(i))
      return G("InvalidAttr", "Attribute '" + i + "' is an invalid name.", lt(r[s]));
    if (!n.hasOwnProperty(i))
      n[i] = 1;
    else
      return G("InvalidAttr", "Attribute '" + i + "' is repeated.", lt(r[s]));
  }
  return !0;
}
function Gf(e, t) {
  let r = /\d/;
  for (e[t] === "x" && (t++, r = /[\da-fA-F]/); t < e.length; t++) {
    if (e[t] === ";")
      return t;
    if (!e[t].match(r))
      break;
  }
  return -1;
}
function Vf(e, t) {
  if (t++, e[t] === ";")
    return -1;
  if (e[t] === "#")
    return t++, Gf(e, t);
  let r = 0;
  for (; t < e.length; t++, r++)
    if (!(e[t].match(/\w/) && r < 20)) {
      if (e[t] === ";")
        break;
      return -1;
    }
  return t;
}
function G(e, t, r) {
  return {
    err: {
      code: e,
      msg: t,
      line: r.line || r,
      col: r.col
    }
  };
}
function Kf(e) {
  return Xn.isName(e);
}
function Xf(e) {
  return Xn.isName(e);
}
function fe(e, t) {
  const r = e.substring(0, t).split(/\r?\n/);
  return {
    line: r.length,
    // column number is last line's length + 1, because column numbering starts at 1:
    col: r[r.length - 1].length + 1
  };
}
function lt(e) {
  return e.startIndex + e[1].length;
}
var Zn = {};
const ka = {
  preserveOrder: !1,
  attributeNamePrefix: "@_",
  attributesGroupName: !1,
  textNodeName: "#text",
  ignoreAttributes: !0,
  removeNSPrefix: !1,
  // remove NS from tag name or attribute name if true
  allowBooleanAttributes: !1,
  //a tag can have attributes without any value
  //ignoreRootElement : false,
  parseTagValue: !0,
  parseAttributeValue: !1,
  trimValues: !0,
  //Trim string values of tag and attributes
  cdataPropName: !1,
  numberParseOptions: {
    hex: !0,
    leadingZeros: !0,
    eNotation: !0
  },
  tagValueProcessor: function(e, t) {
    return t;
  },
  attributeValueProcessor: function(e, t) {
    return t;
  },
  stopNodes: [],
  //nested tags will not be parsed even for errors
  alwaysCreateTextNode: !1,
  isArray: () => !1,
  commentPropName: !1,
  unpairedTags: [],
  processEntities: !0,
  htmlEntities: !1,
  ignoreDeclaration: !1,
  ignorePiTags: !1,
  transformTagName: !1,
  transformAttributeName: !1,
  updateTag: function(e, t, r) {
    return e;
  }
  // skipEmptyListItem: false
}, Zf = function(e) {
  return Object.assign({}, ka, e);
};
Zn.buildOptions = Zf;
Zn.defaultOptions = ka;
class Yf {
  constructor(t) {
    this.tagname = t, this.child = [], this[":@"] = {};
  }
  add(t, r) {
    t === "__proto__" && (t = "#__proto__"), this.child.push({ [t]: r });
  }
  addChild(t) {
    t.tagname === "__proto__" && (t.tagname = "#__proto__"), t[":@"] && Object.keys(t[":@"]).length > 0 ? this.child.push({ [t.tagname]: t.child, ":@": t[":@"] }) : this.child.push({ [t.tagname]: t.child });
  }
}
var Qf = Yf;
const Jf = ur;
function eh(e, t) {
  const r = {};
  if (e[t + 3] === "O" && e[t + 4] === "C" && e[t + 5] === "T" && e[t + 6] === "Y" && e[t + 7] === "P" && e[t + 8] === "E") {
    t = t + 9;
    let n = 1, s = !1, i = !1, o = "";
    for (; t < e.length; t++)
      if (e[t] === "<" && !i) {
        if (s && nh(e, t))
          t += 7, [entityName, val, t] = th(e, t + 1), val.indexOf("&") === -1 && (r[ah(entityName)] = {
            regx: RegExp(`&${entityName};`, "g"),
            val
          });
        else if (s && sh(e, t))
          t += 8;
        else if (s && ih(e, t))
          t += 8;
        else if (s && oh(e, t))
          t += 9;
        else if (rh)
          i = !0;
        else
          throw new Error("Invalid DOCTYPE");
        n++, o = "";
      } else if (e[t] === ">") {
        if (i ? e[t - 1] === "-" && e[t - 2] === "-" && (i = !1, n--) : n--, n === 0)
          break;
      } else
        e[t] === "[" ? s = !0 : o += e[t];
    if (n !== 0)
      throw new Error("Unclosed DOCTYPE");
  } else
    throw new Error("Invalid Tag instead of DOCTYPE");
  return { entities: r, i: t };
}
function th(e, t) {
  let r = "";
  for (; t < e.length && e[t] !== "'" && e[t] !== '"'; t++)
    r += e[t];
  if (r = r.trim(), r.indexOf(" ") !== -1)
    throw new Error("External entites are not supported");
  const n = e[t++];
  let s = "";
  for (; t < e.length && e[t] !== n; t++)
    s += e[t];
  return [r, s, t];
}
function rh(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "-" && e[t + 3] === "-";
}
function nh(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "E" && e[t + 3] === "N" && e[t + 4] === "T" && e[t + 5] === "I" && e[t + 6] === "T" && e[t + 7] === "Y";
}
function sh(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "E" && e[t + 3] === "L" && e[t + 4] === "E" && e[t + 5] === "M" && e[t + 6] === "E" && e[t + 7] === "N" && e[t + 8] === "T";
}
function ih(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "A" && e[t + 3] === "T" && e[t + 4] === "T" && e[t + 5] === "L" && e[t + 6] === "I" && e[t + 7] === "S" && e[t + 8] === "T";
}
function oh(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "N" && e[t + 3] === "O" && e[t + 4] === "T" && e[t + 5] === "A" && e[t + 6] === "T" && e[t + 7] === "I" && e[t + 8] === "O" && e[t + 9] === "N";
}
function ah(e) {
  if (Jf.isName(e))
    return e;
  throw new Error(`Invalid entity name ${e}`);
}
var ch = eh;
const uh = /^[-+]?0x[a-fA-F0-9]+$/, dh = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
!Number.parseInt && window.parseInt && (Number.parseInt = window.parseInt);
!Number.parseFloat && window.parseFloat && (Number.parseFloat = window.parseFloat);
const lh = {
  hex: !0,
  leadingZeros: !0,
  decimalPoint: ".",
  eNotation: !0
  //skipLike: /regex/
};
function fh(e, t = {}) {
  if (t = Object.assign({}, lh, t), !e || typeof e != "string")
    return e;
  let r = e.trim();
  if (t.skipLike !== void 0 && t.skipLike.test(r))
    return e;
  if (t.hex && uh.test(r))
    return Number.parseInt(r, 16);
  {
    const n = dh.exec(r);
    if (n) {
      const s = n[1], i = n[2];
      let o = hh(n[3]);
      const a = n[4] || n[6];
      if (!t.leadingZeros && i.length > 0 && s && r[2] !== ".")
        return e;
      if (!t.leadingZeros && i.length > 0 && !s && r[1] !== ".")
        return e;
      {
        const c = Number(r), u = "" + c;
        return u.search(/[eE]/) !== -1 || a ? t.eNotation ? c : e : r.indexOf(".") !== -1 ? u === "0" && o === "" || u === o || s && u === "-" + o ? c : e : i ? o === u || s + o === u ? c : e : r === u || r === s + u ? c : e;
      }
    } else
      return e;
  }
}
function hh(e) {
  return e && e.indexOf(".") !== -1 && (e = e.replace(/0+$/, ""), e === "." ? e = "0" : e[0] === "." ? e = "0" + e : e[e.length - 1] === "." && (e = e.substr(0, e.length - 1))), e;
}
var ph = fh;
const Yn = ur, ft = Qf, gh = ch, mh = ph;
"<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, Yn.nameRegexp);
let yh = class {
  constructor(t) {
    this.options = t, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = {
      apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
      gt: { regex: /&(gt|#62|#x3E);/g, val: ">" },
      lt: { regex: /&(lt|#60|#x3C);/g, val: "<" },
      quot: { regex: /&(quot|#34|#x22);/g, val: '"' }
    }, this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }, this.htmlEntities = {
      space: { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      cent: { regex: /&(cent|#162);/g, val: "" },
      pound: { regex: /&(pound|#163);/g, val: "" },
      yen: { regex: /&(yen|#165);/g, val: "" },
      euro: { regex: /&(euro|#8364);/g, val: "" },
      copyright: { regex: /&(copy|#169);/g, val: "" },
      reg: { regex: /&(reg|#174);/g, val: "" },
      inr: { regex: /&(inr|#8377);/g, val: "" }
    }, this.addExternalEntities = bh, this.parseXml = Sh, this.parseTextData = wh, this.resolveNameSpace = xh, this.buildAttributesMap = Ah, this.isItStopNode = _h, this.replaceEntitiesValue = vh, this.readStopNodeData = Bh, this.saveTextToParentTag = Rh, this.addChild = Ch;
  }
};
function bh(e) {
  const t = Object.keys(e);
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    this.lastEntities[n] = {
      regex: new RegExp("&" + n + ";", "g"),
      val: e[n]
    };
  }
}
function wh(e, t, r, n, s, i, o) {
  if (e !== void 0 && (this.options.trimValues && !n && (e = e.trim()), e.length > 0)) {
    o || (e = this.replaceEntitiesValue(e));
    const a = this.options.tagValueProcessor(t, e, r, s, i);
    return a == null ? e : typeof a != typeof e || a !== e ? a : this.options.trimValues ? bn(e, this.options.parseTagValue, this.options.numberParseOptions) : e.trim() === e ? bn(e, this.options.parseTagValue, this.options.numberParseOptions) : e;
  }
}
function xh(e) {
  if (this.options.removeNSPrefix) {
    const t = e.split(":"), r = e.charAt(0) === "/" ? "/" : "";
    if (t[0] === "xmlns")
      return "";
    t.length === 2 && (e = r + t[1]);
  }
  return e;
}
const Eh = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
function Ah(e, t, r) {
  if (!this.options.ignoreAttributes && typeof e == "string") {
    const n = Yn.getAllMatches(e, Eh), s = n.length, i = {};
    for (let o = 0; o < s; o++) {
      const a = this.resolveNameSpace(n[o][1]);
      let c = n[o][4], u = this.options.attributeNamePrefix + a;
      if (a.length)
        if (this.options.transformAttributeName && (u = this.options.transformAttributeName(u)), u === "__proto__" && (u = "#__proto__"), c !== void 0) {
          this.options.trimValues && (c = c.trim()), c = this.replaceEntitiesValue(c);
          const l = this.options.attributeValueProcessor(a, c, t);
          l == null ? i[u] = c : typeof l != typeof c || l !== c ? i[u] = l : i[u] = bn(
            c,
            this.options.parseAttributeValue,
            this.options.numberParseOptions
          );
        } else
          this.options.allowBooleanAttributes && (i[u] = !0);
    }
    if (!Object.keys(i).length)
      return;
    if (this.options.attributesGroupName) {
      const o = {};
      return o[this.options.attributesGroupName] = i, o;
    }
    return i;
  }
}
const Sh = function(e) {
  e = e.replace(/\r\n?/g, `
`);
  const t = new ft("!xml");
  let r = t, n = "", s = "";
  for (let i = 0; i < e.length; i++)
    if (e[i] === "<")
      if (e[i + 1] === "/") {
        const a = Xe(e, ">", i, "Closing Tag is not closed.");
        let c = e.substring(i + 2, a).trim();
        if (this.options.removeNSPrefix) {
          const h = c.indexOf(":");
          h !== -1 && (c = c.substr(h + 1));
        }
        this.options.transformTagName && (c = this.options.transformTagName(c)), r && (n = this.saveTextToParentTag(n, r, s));
        const u = s.substring(s.lastIndexOf(".") + 1);
        if (c && this.options.unpairedTags.indexOf(c) !== -1)
          throw new Error(`Unpaired tag can not be used as closing tag: </${c}>`);
        let l = 0;
        u && this.options.unpairedTags.indexOf(u) !== -1 ? (l = s.lastIndexOf(".", s.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : l = s.lastIndexOf("."), s = s.substring(0, l), r = this.tagsNodeStack.pop(), n = "", i = a;
      } else if (e[i + 1] === "?") {
        let a = yn(e, i, !1, "?>");
        if (!a)
          throw new Error("Pi Tag is not closed.");
        if (n = this.saveTextToParentTag(n, r, s), !(this.options.ignoreDeclaration && a.tagName === "?xml" || this.options.ignorePiTags)) {
          const c = new ft(a.tagName);
          c.add(this.options.textNodeName, ""), a.tagName !== a.tagExp && a.attrExpPresent && (c[":@"] = this.buildAttributesMap(a.tagExp, s, a.tagName)), this.addChild(r, c, s);
        }
        i = a.closeIndex + 1;
      } else if (e.substr(i + 1, 3) === "!--") {
        const a = Xe(e, "-->", i + 4, "Comment is not closed.");
        if (this.options.commentPropName) {
          const c = e.substring(i + 4, a - 2);
          n = this.saveTextToParentTag(n, r, s), r.add(this.options.commentPropName, [{ [this.options.textNodeName]: c }]);
        }
        i = a;
      } else if (e.substr(i + 1, 2) === "!D") {
        const a = gh(e, i);
        this.docTypeEntities = a.entities, i = a.i;
      } else if (e.substr(i + 1, 2) === "![") {
        const a = Xe(e, "]]>", i, "CDATA is not closed.") - 2, c = e.substring(i + 9, a);
        if (n = this.saveTextToParentTag(n, r, s), this.options.cdataPropName)
          r.add(this.options.cdataPropName, [{ [this.options.textNodeName]: c }]);
        else {
          let u = this.parseTextData(c, r.tagname, s, !0, !1, !0);
          u == null && (u = ""), r.add(this.options.textNodeName, u);
        }
        i = a + 2;
      } else {
        let a = yn(e, i, this.options.removeNSPrefix), c = a.tagName, u = a.tagExp, l = a.attrExpPresent, h = a.closeIndex;
        this.options.transformTagName && (c = this.options.transformTagName(c)), r && n && r.tagname !== "!xml" && (n = this.saveTextToParentTag(n, r, s, !1));
        const p = r;
        if (p && this.options.unpairedTags.indexOf(p.tagname) !== -1 && (r = this.tagsNodeStack.pop(), s = s.substring(0, s.lastIndexOf("."))), c !== t.tagname && (s += s ? "." + c : c), this.isItStopNode(this.options.stopNodes, s, c)) {
          let g = "";
          if (u.length > 0 && u.lastIndexOf("/") === u.length - 1)
            i = a.closeIndex;
          else if (this.options.unpairedTags.indexOf(c) !== -1)
            i = a.closeIndex;
          else {
            const A = this.readStopNodeData(e, c, h + 1);
            if (!A)
              throw new Error(`Unexpected end of ${c}`);
            i = A.i, g = A.tagContent;
          }
          const b = new ft(c);
          c !== u && l && (b[":@"] = this.buildAttributesMap(u, s, c)), g && (g = this.parseTextData(g, c, s, !0, l, !0, !0)), s = s.substr(0, s.lastIndexOf(".")), b.add(this.options.textNodeName, g), this.addChild(r, b, s);
        } else {
          if (u.length > 0 && u.lastIndexOf("/") === u.length - 1) {
            c[c.length - 1] === "/" ? (c = c.substr(0, c.length - 1), u = c) : u = u.substr(0, u.length - 1), this.options.transformTagName && (c = this.options.transformTagName(c));
            const g = new ft(c);
            c !== u && l && (g[":@"] = this.buildAttributesMap(u, s, c)), this.addChild(r, g, s), s = s.substr(0, s.lastIndexOf("."));
          } else {
            const g = new ft(c);
            this.tagsNodeStack.push(r), c !== u && l && (g[":@"] = this.buildAttributesMap(u, s, c)), this.addChild(r, g, s), r = g;
          }
          n = "", i = h;
        }
      }
    else
      n += e[i];
  return t.child;
};
function Ch(e, t, r) {
  const n = this.options.updateTag(t.tagname, r, t[":@"]);
  n === !1 || (typeof n == "string" && (t.tagname = n), e.addChild(t));
}
const vh = function(e) {
  if (this.options.processEntities) {
    for (let t in this.docTypeEntities) {
      const r = this.docTypeEntities[t];
      e = e.replace(r.regx, r.val);
    }
    for (let t in this.lastEntities) {
      const r = this.lastEntities[t];
      e = e.replace(r.regex, r.val);
    }
    if (this.options.htmlEntities)
      for (let t in this.htmlEntities) {
        const r = this.htmlEntities[t];
        e = e.replace(r.regex, r.val);
      }
    e = e.replace(this.ampEntity.regex, this.ampEntity.val);
  }
  return e;
};
function Rh(e, t, r, n) {
  return e && (n === void 0 && (n = Object.keys(t.child).length === 0), e = this.parseTextData(
    e,
    t.tagname,
    r,
    !1,
    t[":@"] ? Object.keys(t[":@"]).length !== 0 : !1,
    n
  ), e !== void 0 && e !== "" && t.add(this.options.textNodeName, e), e = ""), e;
}
function _h(e, t, r) {
  const n = "*." + r;
  for (const s in e) {
    const i = e[s];
    if (n === i || t === i)
      return !0;
  }
  return !1;
}
function Th(e, t, r = ">") {
  let n, s = "";
  for (let i = t; i < e.length; i++) {
    let o = e[i];
    if (n)
      o === n && (n = "");
    else if (o === '"' || o === "'")
      n = o;
    else if (o === r[0])
      if (r[1]) {
        if (e[i + 1] === r[1])
          return {
            data: s,
            index: i
          };
      } else
        return {
          data: s,
          index: i
        };
    else
      o === "	" && (o = " ");
    s += o;
  }
}
function Xe(e, t, r, n) {
  const s = e.indexOf(t, r);
  if (s === -1)
    throw new Error(n);
  return s + t.length - 1;
}
function yn(e, t, r, n = ">") {
  const s = Th(e, t + 1, n);
  if (!s)
    return;
  let i = s.data;
  const o = s.index, a = i.search(/\s/);
  let c = i, u = !0;
  if (a !== -1 && (c = i.substr(0, a).replace(/\s\s*$/, ""), i = i.substr(a + 1)), r) {
    const l = c.indexOf(":");
    l !== -1 && (c = c.substr(l + 1), u = c !== s.data.substr(l + 1));
  }
  return {
    tagName: c,
    tagExp: i,
    closeIndex: o,
    attrExpPresent: u
  };
}
function Bh(e, t, r) {
  const n = r;
  let s = 1;
  for (; r < e.length; r++)
    if (e[r] === "<")
      if (e[r + 1] === "/") {
        const i = Xe(e, ">", r, `${t} is not closed`);
        if (e.substring(r + 2, i).trim() === t && (s--, s === 0))
          return {
            tagContent: e.substring(n, r),
            i
          };
        r = i;
      } else if (e[r + 1] === "?")
        r = Xe(e, "?>", r + 1, "StopNode is not closed.");
      else if (e.substr(r + 1, 3) === "!--")
        r = Xe(e, "-->", r + 3, "StopNode is not closed.");
      else if (e.substr(r + 1, 2) === "![")
        r = Xe(e, "]]>", r, "StopNode is not closed.") - 2;
      else {
        const i = yn(e, r, ">");
        i && ((i && i.tagName) === t && i.tagExp[i.tagExp.length - 1] !== "/" && s++, r = i.closeIndex);
      }
}
function bn(e, t, r) {
  if (t && typeof e == "string") {
    const n = e.trim();
    return n === "true" ? !0 : n === "false" ? !1 : mh(e, r);
  } else
    return Yn.isExist(e) ? e : "";
}
var kh = yh, Na = {};
function Nh(e, t) {
  return Pa(e, t);
}
function Pa(e, t, r) {
  let n;
  const s = {};
  for (let i = 0; i < e.length; i++) {
    const o = e[i], a = Ph(o);
    let c = "";
    if (r === void 0 ? c = a : c = r + "." + a, a === t.textNodeName)
      n === void 0 ? n = o[a] : n += "" + o[a];
    else {
      if (a === void 0)
        continue;
      if (o[a]) {
        let u = Pa(o[a], t, c);
        const l = Mh(u, t);
        o[":@"] ? Oh(u, o[":@"], c, t) : Object.keys(u).length === 1 && u[t.textNodeName] !== void 0 && !t.alwaysCreateTextNode ? u = u[t.textNodeName] : Object.keys(u).length === 0 && (t.alwaysCreateTextNode ? u[t.textNodeName] = "" : u = ""), s[a] !== void 0 && s.hasOwnProperty(a) ? (Array.isArray(s[a]) || (s[a] = [s[a]]), s[a].push(u)) : t.isArray(a, c, l) ? s[a] = [u] : s[a] = u;
      }
    }
  }
  return typeof n == "string" ? n.length > 0 && (s[t.textNodeName] = n) : n !== void 0 && (s[t.textNodeName] = n), s;
}
function Ph(e) {
  const t = Object.keys(e);
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    if (n !== ":@")
      return n;
  }
}
function Oh(e, t, r, n) {
  if (t) {
    const s = Object.keys(t), i = s.length;
    for (let o = 0; o < i; o++) {
      const a = s[o];
      n.isArray(a, r + "." + a, !0, !0) ? e[a] = [t[a]] : e[a] = t[a];
    }
  }
}
function Mh(e, t) {
  const { textNodeName: r } = t, n = Object.keys(e).length;
  return !!(n === 0 || n === 1 && (e[r] || typeof e[r] == "boolean" || e[r] === 0));
}
Na.prettify = Nh;
const { buildOptions: Ih } = Zn, Fh = kh, { prettify: Dh } = Na, Uh = Kn;
let $h = class {
  constructor(t) {
    this.externalEntities = {}, this.options = Ih(t);
  }
  /**
   * Parse XML dats to JS object 
   * @param {string|Buffer} xmlData 
   * @param {boolean|Object} validationOption 
   */
  parse(t, r) {
    if (typeof t != "string")
      if (t.toString)
        t = t.toString();
      else
        throw new Error("XML data is accepted in String or Bytes[] form.");
    if (r) {
      r === !0 && (r = {});
      const i = Uh.validate(t, r);
      if (i !== !0)
        throw Error(`${i.err.msg}:${i.err.line}:${i.err.col}`);
    }
    const n = new Fh(this.options);
    n.addExternalEntities(this.externalEntities);
    const s = n.parseXml(t);
    return this.options.preserveOrder || s === void 0 ? s : Dh(s, this.options);
  }
  /**
   * Add Entity which is not by default supported by this library
   * @param {string} key 
   * @param {string} value 
   */
  addEntity(t, r) {
    if (r.indexOf("&") !== -1)
      throw new Error("Entity value can't have '&'");
    if (t.indexOf("&") !== -1 || t.indexOf(";") !== -1)
      throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
    if (r === "&")
      throw new Error("An entity with value '&' is not permitted");
    this.externalEntities[t] = r;
  }
};
var Lh = $h;
const Hh = `
`;
function jh(e, t) {
  let r = "";
  return t.format && t.indentBy.length > 0 && (r = Hh), Oa(e, t, "", r);
}
function Oa(e, t, r, n) {
  let s = "", i = !1;
  for (let o = 0; o < e.length; o++) {
    const a = e[o], c = zh(a);
    let u = "";
    if (r.length === 0 ? u = c : u = `${r}.${c}`, c === t.textNodeName) {
      let b = a[c];
      qh(u, t) || (b = t.tagValueProcessor(c, b), b = Ma(b, t)), i && (s += n), s += b, i = !1;
      continue;
    } else if (c === t.cdataPropName) {
      i && (s += n), s += `<![CDATA[${a[c][0][t.textNodeName]}]]>`, i = !1;
      continue;
    } else if (c === t.commentPropName) {
      s += n + `<!--${a[c][0][t.textNodeName]}-->`, i = !0;
      continue;
    } else if (c[0] === "?") {
      const b = Ys(a[":@"], t), A = c === "?xml" ? "" : n;
      let R = a[c][0][t.textNodeName];
      R = R.length !== 0 ? " " + R : "", s += A + `<${c}${R}${b}?>`, i = !0;
      continue;
    }
    let l = n;
    l !== "" && (l += t.indentBy);
    const h = Ys(a[":@"], t), p = n + `<${c}${h}`, g = Oa(a[c], t, u, l);
    t.unpairedTags.indexOf(c) !== -1 ? t.suppressUnpairedNode ? s += p + ">" : s += p + "/>" : (!g || g.length === 0) && t.suppressEmptyNode ? s += p + "/>" : g && g.endsWith(">") ? s += p + `>${g}${n}</${c}>` : (s += p + ">", g && n !== "" && (g.includes("/>") || g.includes("</")) ? s += n + t.indentBy + g + n : s += g, s += `</${c}>`), i = !0;
  }
  return s;
}
function zh(e) {
  const t = Object.keys(e);
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    if (n !== ":@")
      return n;
  }
}
function Ys(e, t) {
  let r = "";
  if (e && !t.ignoreAttributes)
    for (let n in e) {
      let s = t.attributeValueProcessor(n, e[n]);
      s = Ma(s, t), s === !0 && t.suppressBooleanAttributes ? r += ` ${n.substr(t.attributeNamePrefix.length)}` : r += ` ${n.substr(t.attributeNamePrefix.length)}="${s}"`;
    }
  return r;
}
function qh(e, t) {
  e = e.substr(0, e.length - t.textNodeName.length - 1);
  let r = e.substr(e.lastIndexOf(".") + 1);
  for (let n in t.stopNodes)
    if (t.stopNodes[n] === e || t.stopNodes[n] === "*." + r)
      return !0;
  return !1;
}
function Ma(e, t) {
  if (e && e.length > 0 && t.processEntities)
    for (let r = 0; r < t.entities.length; r++) {
      const n = t.entities[r];
      e = e.replace(n.regex, n.val);
    }
  return e;
}
var Wh = jh;
const Gh = Wh, Vh = {
  attributeNamePrefix: "@_",
  attributesGroupName: !1,
  textNodeName: "#text",
  ignoreAttributes: !0,
  cdataPropName: !1,
  format: !1,
  indentBy: "  ",
  suppressEmptyNode: !1,
  suppressUnpairedNode: !0,
  suppressBooleanAttributes: !0,
  tagValueProcessor: function(e, t) {
    return t;
  },
  attributeValueProcessor: function(e, t) {
    return t;
  },
  preserveOrder: !1,
  commentPropName: !1,
  unpairedTags: [],
  entities: [
    { regex: new RegExp("&", "g"), val: "&amp;" },
    //it must be on top
    { regex: new RegExp(">", "g"), val: "&gt;" },
    { regex: new RegExp("<", "g"), val: "&lt;" },
    { regex: new RegExp("'", "g"), val: "&apos;" },
    { regex: new RegExp('"', "g"), val: "&quot;" }
  ],
  processEntities: !0,
  stopNodes: [],
  // transformTagName: false,
  // transformAttributeName: false,
  oneListGroup: !1
};
function qe(e) {
  this.options = Object.assign({}, Vh, e), this.options.ignoreAttributes || this.options.attributesGroupName ? this.isAttribute = function() {
    return !1;
  } : (this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = Zh), this.processTextOrObjNode = Kh, this.options.format ? (this.indentate = Xh, this.tagEndChar = `>
`, this.newLine = `
`) : (this.indentate = function() {
    return "";
  }, this.tagEndChar = ">", this.newLine = "");
}
qe.prototype.build = function(e) {
  return this.options.preserveOrder ? Gh(e, this.options) : (Array.isArray(e) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (e = {
    [this.options.arrayNodeName]: e
  }), this.j2x(e, 0).val);
};
qe.prototype.j2x = function(e, t) {
  let r = "", n = "";
  for (let s in e)
    if (!(typeof e[s] > "u"))
      if (e[s] === null)
        s[0] === "?" ? n += this.indentate(t) + "<" + s + "?" + this.tagEndChar : n += this.indentate(t) + "<" + s + "/" + this.tagEndChar;
      else if (e[s] instanceof Date)
        n += this.buildTextValNode(e[s], s, "", t);
      else if (typeof e[s] != "object") {
        const i = this.isAttribute(s);
        if (i)
          r += this.buildAttrPairStr(i, "" + e[s]);
        else if (s === this.options.textNodeName) {
          let o = this.options.tagValueProcessor(s, "" + e[s]);
          n += this.replaceEntitiesValue(o);
        } else
          n += this.buildTextValNode(e[s], s, "", t);
      } else if (Array.isArray(e[s])) {
        const i = e[s].length;
        let o = "";
        for (let a = 0; a < i; a++) {
          const c = e[s][a];
          typeof c > "u" || (c === null ? s[0] === "?" ? n += this.indentate(t) + "<" + s + "?" + this.tagEndChar : n += this.indentate(t) + "<" + s + "/" + this.tagEndChar : typeof c == "object" ? this.options.oneListGroup ? o += this.j2x(c, t + 1).val : o += this.processTextOrObjNode(c, s, t) : o += this.buildTextValNode(c, s, "", t));
        }
        this.options.oneListGroup && (o = this.buildObjectNode(o, s, "", t)), n += o;
      } else if (this.options.attributesGroupName && s === this.options.attributesGroupName) {
        const i = Object.keys(e[s]), o = i.length;
        for (let a = 0; a < o; a++)
          r += this.buildAttrPairStr(i[a], "" + e[s][i[a]]);
      } else
        n += this.processTextOrObjNode(e[s], s, t);
  return { attrStr: r, val: n };
};
qe.prototype.buildAttrPairStr = function(e, t) {
  return t = this.options.attributeValueProcessor(e, "" + t), t = this.replaceEntitiesValue(t), this.options.suppressBooleanAttributes && t === "true" ? " " + e : " " + e + '="' + t + '"';
};
function Kh(e, t, r) {
  const n = this.j2x(e, r + 1);
  return e[this.options.textNodeName] !== void 0 && Object.keys(e).length === 1 ? this.buildTextValNode(e[this.options.textNodeName], t, n.attrStr, r) : this.buildObjectNode(n.val, t, n.attrStr, r);
}
qe.prototype.buildObjectNode = function(e, t, r, n) {
  if (e === "")
    return t[0] === "?" ? this.indentate(n) + "<" + t + r + "?" + this.tagEndChar : this.indentate(n) + "<" + t + r + this.closeTag(t) + this.tagEndChar;
  {
    let s = "</" + t + this.tagEndChar, i = "";
    return t[0] === "?" && (i = "?", s = ""), r && e.indexOf("<") === -1 ? this.indentate(n) + "<" + t + r + i + ">" + e + s : this.options.commentPropName !== !1 && t === this.options.commentPropName && i.length === 0 ? this.indentate(n) + `<!--${e}-->` + this.newLine : this.indentate(n) + "<" + t + r + i + this.tagEndChar + e + this.indentate(n) + s;
  }
};
qe.prototype.closeTag = function(e) {
  let t = "";
  return this.options.unpairedTags.indexOf(e) !== -1 ? this.options.suppressUnpairedNode || (t = "/") : this.options.suppressEmptyNode ? t = "/" : t = `></${e}`, t;
};
qe.prototype.buildTextValNode = function(e, t, r, n) {
  if (this.options.cdataPropName !== !1 && t === this.options.cdataPropName)
    return this.indentate(n) + `<![CDATA[${e}]]>` + this.newLine;
  if (this.options.commentPropName !== !1 && t === this.options.commentPropName)
    return this.indentate(n) + `<!--${e}-->` + this.newLine;
  if (t[0] === "?")
    return this.indentate(n) + "<" + t + r + "?" + this.tagEndChar;
  {
    let s = this.options.tagValueProcessor(t, e);
    return s = this.replaceEntitiesValue(s), s === "" ? this.indentate(n) + "<" + t + r + this.closeTag(t) + this.tagEndChar : this.indentate(n) + "<" + t + r + ">" + s + "</" + t + this.tagEndChar;
  }
};
qe.prototype.replaceEntitiesValue = function(e) {
  if (e && e.length > 0 && this.options.processEntities)
    for (let t = 0; t < this.options.entities.length; t++) {
      const r = this.options.entities[t];
      e = e.replace(r.regex, r.val);
    }
  return e;
};
function Xh(e) {
  return this.options.indentBy.repeat(e);
}
function Zh(e) {
  return e.startsWith(this.options.attributeNamePrefix) ? e.substr(this.attrPrefixLen) : !1;
}
var Yh = qe;
const Qh = Kn, Jh = Lh, ep = Yh;
var tp = {
  XMLParser: Jh,
  XMLValidator: Qh,
  XMLBuilder: ep
};
const Ia = (e, t) => Lf(e, t).then((r) => {
  if (r.length) {
    const n = new tp.XMLParser({
      attributeNamePrefix: "",
      htmlEntities: !0,
      ignoreAttributes: !1,
      ignoreDeclaration: !0,
      parseTagValue: !1,
      trimValues: !1,
      tagValueProcessor: (c, u) => u.trim() === "" && u.includes(`
`) ? "" : void 0
    });
    n.addEntity("#xD", "\r"), n.addEntity("#10", `
`);
    let s;
    try {
      s = n.parse(r, !0);
    } catch (c) {
      throw c && typeof c == "object" && Object.defineProperty(c, "$responseBodyText", {
        value: r
      }), c;
    }
    const i = "#text", o = Object.keys(s)[0], a = s[o];
    return a[i] && (a[o] = a[i], delete a[i]), Yo(a);
  }
  return {};
}), rp = async (e, t) => {
  const r = await Ia(e, t);
  return r.Error && (r.Error.message = r.Error.message ?? r.Error.Message), r;
}, np = (e, t) => {
  var r;
  if (((r = t == null ? void 0 : t.Error) == null ? void 0 : r.Code) !== void 0)
    return t.Error.Code;
  if ((t == null ? void 0 : t.Code) !== void 0)
    return t.Code;
  if (e.statusCode == 404)
    return "NotFound";
};
class Qn extends Ee {
  constructor(t) {
    super({
      name: "ObjectAlreadyInActiveTierError",
      $fault: "client",
      ...t
    }), this.name = "ObjectAlreadyInActiveTierError", this.$fault = "client", Object.setPrototypeOf(this, Qn.prototype);
  }
}
var Qs;
(function(e) {
  e.visit = (t, r) => t.Records !== void 0 ? r.Records(t.Records) : t.Stats !== void 0 ? r.Stats(t.Stats) : t.Progress !== void 0 ? r.Progress(t.Progress) : t.Cont !== void 0 ? r.Cont(t.Cont) : t.End !== void 0 ? r.End(t.End) : r._(t.$unknown[0], t.$unknown[1]);
})(Qs || (Qs = {}));
const sp = (e) => ({
  ...e,
  ...e.SSEKMSKeyId && { SSEKMSKeyId: Ye },
  ...e.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: Ye }
}), ip = (e) => ({
  ...e,
  ...e.SSECustomerKey && { SSECustomerKey: Ye },
  ...e.SSEKMSKeyId && { SSEKMSKeyId: Ye },
  ...e.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: Ye }
}), op = async (e, t) => {
  const r = Ba(e, t), n = ae({}, st, {
    [tg]: e[$p]
  });
  r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1);
  const s = ae({
    [Jp]: [, ""]
  });
  let i;
  return r.m("GET").h(n).q(s).b(i), r.build();
}, ap = async (e, t) => {
  const r = Ba(e, t), n = ae({}, st, {
    [Zp]: e[Tp] || "application/octet-stream",
    [eg]: e[Ep],
    [qp]: e[Sp],
    [Wp]: e[Cp],
    [Gp]: e[vp],
    [Vp]: e[Rp],
    [Kp]: [() => st(e[Js]), () => e[Js].toString()],
    [Xp]: e[_p],
    [pg]: e[Ap],
    [Ga]: e[Da],
    [Va]: e[Ua],
    [Ka]: e[$a],
    [Xa]: e[La],
    [Yp]: [() => st(e[ei]), () => Pu(e[ei]).toString()],
    [sg]: e[Np],
    [ig]: e[Pp],
    [og]: e[Op],
    [ag]: e[Mp],
    [Za]: e[Ha],
    [hg]: e[Vt],
    [bg]: e[zp],
    [Ja]: e[ja],
    [gg]: e[Lp],
    [ec]: e[za],
    [Ya]: e[Wa],
    [Qa]: e[qa],
    [xn]: [() => st(e[wn]), () => e[wn].toString()],
    [fg]: e[Up],
    [mg]: e[Hp],
    [ug]: e[Fp],
    [dg]: [() => st(e[ti]), () => rd(e[ti]).toString()],
    [cg]: e[Ip],
    [ng]: e[Bp],
    ...e.Metadata !== void 0 && Object.keys(e.Metadata).reduce((a, c) => (a[`x-amz-meta-${c.toLowerCase()}`] = e.Metadata[c], a), {})
  });
  r.bp("/{Key+}"), r.p("Bucket", () => e.Bucket, "{Bucket}", !1), r.p("Key", () => e.Key, "{Key+}", !0);
  const s = ae({
    [wg]: [, "PutObject"]
  });
  let i, o;
  return e.Body !== void 0 && (o = e.Body, i = o), r.m("PUT").h(n).q(s).b(i), r.build();
}, cp = async (e, t) => {
  if (e.statusCode !== 200 && e.statusCode >= 300)
    return Fa(e, t);
  const r = ae({
    $metadata: Re(e)
  }), n = Go(Ru(await Ia(e.body, t)), "body");
  return n[Sr] != null && (r[Sr] = xp(n[Sr])), r;
}, up = async (e, t) => {
  if (e.statusCode !== 200 && e.statusCode >= 300)
    return Fa(e, t);
  const r = ae({
    $metadata: Re(e),
    [Gt]: [, e.headers[rg]],
    [kp]: [, e.headers[Qp]],
    [Da]: [, e.headers[Ga]],
    [Ua]: [, e.headers[Va]],
    [$a]: [, e.headers[Ka]],
    [La]: [, e.headers[Xa]],
    [Ha]: [, e.headers[Za]],
    [jp]: [, e.headers[yg]],
    [ja]: [, e.headers[Ja]],
    [za]: [, e.headers[ec]],
    [Wa]: [, e.headers[Ya]],
    [qa]: [, e.headers[Qa]],
    [wn]: [() => e.headers[xn] !== void 0, () => Eu(e.headers[xn])],
    [Dp]: [, e.headers[lg]]
  });
  return await qo(e.body, t), r;
}, Fa = async (e, t) => {
  const r = {
    ...e,
    body: await rp(e.body, t)
  }, n = np(e, r.body);
  switch (n) {
    case "NoSuchUpload":
    case "com.amazonaws.s3#NoSuchUpload":
      throw await mp(r);
    case "ObjectNotInActiveTierError":
    case "com.amazonaws.s3#ObjectNotInActiveTierError":
      throw await wp(r);
    case "BucketAlreadyExists":
    case "com.amazonaws.s3#BucketAlreadyExists":
      throw await lp(r);
    case "BucketAlreadyOwnedByYou":
    case "com.amazonaws.s3#BucketAlreadyOwnedByYou":
      throw await fp(r);
    case "NoSuchBucket":
    case "com.amazonaws.s3#NoSuchBucket":
      throw await pp(r);
    case "InvalidObjectState":
    case "com.amazonaws.s3#InvalidObjectState":
      throw await hp(r);
    case "NoSuchKey":
    case "com.amazonaws.s3#NoSuchKey":
      throw await gp(r);
    case "NotFound":
    case "com.amazonaws.s3#NotFound":
      throw await yp(r);
    case "ObjectAlreadyInActiveTierError":
    case "com.amazonaws.s3#ObjectAlreadyInActiveTierError":
      throw await bp(r);
    default:
      const s = r.body;
      return dp({
        output: e,
        parsedBody: s,
        errorCode: n
      });
  }
}, dp = ju(Ee), lp = async (e, t) => {
  const r = ae({});
  e.body;
  const n = new jn({
    $metadata: Re(e),
    ...r
  });
  return Ne(n, e.body);
}, fp = async (e, t) => {
  const r = ae({});
  e.body;
  const n = new zn({
    $metadata: Re(e),
    ...r
  });
  return Ne(n, e.body);
}, hp = async (e, t) => {
  const r = ae({}), n = e.body;
  n[Ar] != null && (r[Ar] = Ot(n[Ar])), n[Vt] != null && (r[Vt] = Ot(n[Vt]));
  const s = new Wn({
    $metadata: Re(e),
    ...r
  });
  return Ne(s, e.body);
}, pp = async (e, t) => {
  const r = ae({});
  e.body;
  const n = new qn({
    $metadata: Re(e),
    ...r
  });
  return Ne(n, e.body);
}, gp = async (e, t) => {
  const r = ae({});
  e.body;
  const n = new Gn({
    $metadata: Re(e),
    ...r
  });
  return Ne(n, e.body);
}, mp = async (e, t) => {
  const r = ae({});
  e.body;
  const n = new Ln({
    $metadata: Re(e),
    ...r
  });
  return Ne(n, e.body);
}, yp = async (e, t) => {
  const r = ae({});
  e.body;
  const n = new Vn({
    $metadata: Re(e),
    ...r
  });
  return Ne(n, e.body);
}, bp = async (e, t) => {
  const r = ae({});
  e.body;
  const n = new Qn({
    $metadata: Re(e),
    ...r
  });
  return Ne(n, e.body);
}, wp = async (e, t) => {
  const r = ae({});
  e.body;
  const n = new Hn({
    $metadata: Re(e),
    ...r
  });
  return Ne(n, e.body);
}, xp = (e, t) => {
  const r = {};
  return e[Er] != null && (r[Er] = Ot(e[Er])), e[Cr] != null && (r[Cr] = Ot(e[Cr])), e[vr] != null && (r[vr] = Ot(e[vr])), e[Gt] != null && (r[Gt] = Go(Mu(e[Gt]))), r;
}, Re = (e) => ({
  httpStatusCode: e.statusCode,
  requestId: e.headers["x-amzn-requestid"] ?? e.headers["x-amzn-request-id"] ?? e.headers["x-amz-request-id"],
  extendedRequestId: e.headers["x-amz-id-2"],
  cfId: e.headers["x-amz-cf-id"]
}), st = (e) => e != null && e !== "" && (!Object.getOwnPropertyNames(e).includes("length") || e.length != 0) && (!Object.getOwnPropertyNames(e).includes("size") || e.size != 0), Ep = "ACL", Er = "AccessKeyId", Ar = "AccessTier", wn = "BucketKeyEnabled", Sr = "Credentials", Ap = "ChecksumAlgorithm", Sp = "CacheControl", Da = "ChecksumCRC32", Ua = "ChecksumCRC32C", Cp = "ContentDisposition", vp = "ContentEncoding", Rp = "ContentLanguage", Js = "ContentLength", _p = "ContentMD5", $a = "ChecksumSHA1", La = "ChecksumSHA256", Tp = "ContentType", ei = "Expires", Bp = "ExpectedBucketOwner", kp = "ETag", Gt = "Expiration", Np = "GrantFullControl", Pp = "GrantRead", Op = "GrantReadACP", Mp = "GrantWriteACP", Ip = "ObjectLockLegalHoldStatus", Fp = "ObjectLockMode", ti = "ObjectLockRetainUntilDate", Dp = "RequestCharged", Up = "RequestPayer", Cr = "SecretAccessKey", Vt = "StorageClass", $p = "SessionMode", Ha = "ServerSideEncryption", ja = "SSECustomerAlgorithm", Lp = "SSECustomerKey", za = "SSECustomerKeyMD5", qa = "SSEKMSEncryptionContext", Wa = "SSEKMSKeyId", vr = "SessionToken", Hp = "Tagging", jp = "VersionId", zp = "WebsiteRedirectLocation", qp = "cache-control", Wp = "content-disposition", Gp = "content-encoding", Vp = "content-language", Kp = "content-length", Xp = "content-md5", Zp = "content-type", Yp = "expires", Qp = "etag", Jp = "session", eg = "x-amz-acl", Ga = "x-amz-checksum-crc32", Va = "x-amz-checksum-crc32c", Ka = "x-amz-checksum-sha1", Xa = "x-amz-checksum-sha256", tg = "x-amz-create-session-mode", rg = "x-amz-expiration", ng = "x-amz-expected-bucket-owner", sg = "x-amz-grant-full-control", ig = "x-amz-grant-read", og = "x-amz-grant-read-acp", ag = "x-amz-grant-write-acp", cg = "x-amz-object-lock-legal-hold", ug = "x-amz-object-lock-mode", dg = "x-amz-object-lock-retain-until-date", lg = "x-amz-request-charged", fg = "x-amz-request-payer", hg = "x-amz-storage-class", pg = "x-amz-sdk-checksum-algorithm", Za = "x-amz-server-side-encryption", Ya = "x-amz-server-side-encryption-aws-kms-key-id", xn = "x-amz-server-side-encryption-bucket-key-enabled", Qa = "x-amz-server-side-encryption-context", Ja = "x-amz-server-side-encryption-customer-algorithm", gg = "x-amz-server-side-encryption-customer-key", ec = "x-amz-server-side-encryption-customer-key-md5", mg = "x-amz-tagging", yg = "x-amz-version-id", bg = "x-amz-website-redirect-location", wg = "x-id";
class xg extends On.classBuilder().ep({
  ...Ta,
  DisableS3ExpressSessionAuth: { type: "staticContextParams", value: !0 },
  Bucket: { type: "contextParams", name: "Bucket" }
}).m(function(t, r, n, s) {
  return [
    xa(n, this.serialize, this.deserialize),
    Aa(n, t.getEndpointParameterInstructions())
  ];
}).s("AmazonS3", "CreateSession", {}).n("S3Client", "CreateSessionCommand").f(void 0, Uf).ser(op).de(cp).build() {
}
const Eg = "@aws-sdk/client-s3", Ag = "AWS SDK for JavaScript S3 Client for Node.js, Browser and React Native", Sg = "3.596.0", Cg = {
  build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
  "build:cjs": "node ../../scripts/compilation/inline client-s3",
  "build:es": "tsc -p tsconfig.es.json",
  "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
  "build:types": "tsc -p tsconfig.types.json",
  "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
  clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
  "extract:docs": "api-extractor run --local",
  "generate:client": "node ../../scripts/generate-clients/single-service --solo s3",
  test: "yarn test:unit",
  "test:e2e": "yarn test:e2e:node && yarn test:e2e:browser",
  "test:e2e:browser": "ts-mocha test/**/*.browser.ispec.ts && karma start karma.conf.js",
  "test:e2e:node": "jest --c jest.config.e2e.js",
  "test:unit": "ts-mocha test/unit/**/*.spec.ts"
}, vg = "./dist-cjs/index.js", Rg = "./dist-types/index.d.ts", _g = "./dist-es/index.js", Tg = !1, Bg = {
  "@aws-crypto/sha1-browser": "3.0.0",
  "@aws-crypto/sha256-browser": "3.0.0",
  "@aws-crypto/sha256-js": "3.0.0",
  "@aws-sdk/client-sso-oidc": "3.596.0",
  "@aws-sdk/client-sts": "3.596.0",
  "@aws-sdk/core": "3.592.0",
  "@aws-sdk/credential-provider-node": "3.596.0",
  "@aws-sdk/middleware-bucket-endpoint": "3.587.0",
  "@aws-sdk/middleware-expect-continue": "3.577.0",
  "@aws-sdk/middleware-flexible-checksums": "3.587.0",
  "@aws-sdk/middleware-host-header": "3.577.0",
  "@aws-sdk/middleware-location-constraint": "3.577.0",
  "@aws-sdk/middleware-logger": "3.577.0",
  "@aws-sdk/middleware-recursion-detection": "3.577.0",
  "@aws-sdk/middleware-sdk-s3": "3.587.0",
  "@aws-sdk/middleware-signing": "3.587.0",
  "@aws-sdk/middleware-ssec": "3.577.0",
  "@aws-sdk/middleware-user-agent": "3.587.0",
  "@aws-sdk/region-config-resolver": "3.587.0",
  "@aws-sdk/signature-v4-multi-region": "3.587.0",
  "@aws-sdk/types": "3.577.0",
  "@aws-sdk/util-endpoints": "3.587.0",
  "@aws-sdk/util-user-agent-browser": "3.577.0",
  "@aws-sdk/util-user-agent-node": "3.587.0",
  "@aws-sdk/xml-builder": "3.575.0",
  "@smithy/config-resolver": "^3.0.1",
  "@smithy/core": "^2.2.0",
  "@smithy/eventstream-serde-browser": "^3.0.0",
  "@smithy/eventstream-serde-config-resolver": "^3.0.0",
  "@smithy/eventstream-serde-node": "^3.0.0",
  "@smithy/fetch-http-handler": "^3.0.1",
  "@smithy/hash-blob-browser": "^3.0.0",
  "@smithy/hash-node": "^3.0.0",
  "@smithy/hash-stream-node": "^3.0.0",
  "@smithy/invalid-dependency": "^3.0.0",
  "@smithy/md5-js": "^3.0.0",
  "@smithy/middleware-content-length": "^3.0.0",
  "@smithy/middleware-endpoint": "^3.0.1",
  "@smithy/middleware-retry": "^3.0.3",
  "@smithy/middleware-serde": "^3.0.0",
  "@smithy/middleware-stack": "^3.0.0",
  "@smithy/node-config-provider": "^3.1.0",
  "@smithy/node-http-handler": "^3.0.0",
  "@smithy/protocol-http": "^4.0.0",
  "@smithy/smithy-client": "^3.1.1",
  "@smithy/types": "^3.0.0",
  "@smithy/url-parser": "^3.0.0",
  "@smithy/util-base64": "^3.0.0",
  "@smithy/util-body-length-browser": "^3.0.0",
  "@smithy/util-body-length-node": "^3.0.0",
  "@smithy/util-defaults-mode-browser": "^3.0.3",
  "@smithy/util-defaults-mode-node": "^3.0.3",
  "@smithy/util-endpoints": "^2.0.1",
  "@smithy/util-retry": "^3.0.0",
  "@smithy/util-stream": "^3.0.1",
  "@smithy/util-utf8": "^3.0.0",
  "@smithy/util-waiter": "^3.0.0",
  tslib: "^2.6.2"
}, kg = {
  "@aws-sdk/signature-v4-crt": "3.587.0",
  "@tsconfig/node16": "16.1.3",
  "@types/chai": "^4.2.11",
  "@types/mocha": "^8.0.4",
  "@types/node": "^16.18.96",
  concurrently: "7.0.0",
  "downlevel-dts": "0.10.1",
  rimraf: "3.0.2",
  typescript: "~4.9.5"
}, Ng = {
  node: ">=16.0.0"
}, Pg = {
  "<4.0": {
    "dist-types/*": [
      "dist-types/ts3.4/*"
    ]
  }
}, Og = [
  "dist-*/**"
], Mg = {
  name: "AWS SDK for JavaScript Team",
  url: "https://aws.amazon.com/javascript/"
}, Ig = "Apache-2.0", Fg = {
  "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
}, Dg = "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-s3", Ug = {
  type: "git",
  url: "https://github.com/aws/aws-sdk-js-v3.git",
  directory: "clients/client-s3"
}, $g = {
  name: Eg,
  description: Ag,
  version: Sg,
  scripts: Cg,
  main: vg,
  types: Rg,
  module: _g,
  sideEffects: Tg,
  dependencies: Bg,
  devDependencies: kg,
  engines: Ng,
  typesVersions: Pg,
  files: Og,
  author: Mg,
  license: Ig,
  browser: Fg,
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: Dg,
  repository: Ug
};
var tc = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var En = function(e, t) {
  return En = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, n) {
    r.__proto__ = n;
  } || function(r, n) {
    for (var s in n)
      n.hasOwnProperty(s) && (r[s] = n[s]);
  }, En(e, t);
};
function Lg(e, t) {
  En(e, t);
  function r() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (r.prototype = t.prototype, new r());
}
var An = function() {
  return An = Object.assign || function(t) {
    for (var r, n = 1, s = arguments.length; n < s; n++) {
      r = arguments[n];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]);
    }
    return t;
  }, An.apply(this, arguments);
};
function Hg(e, t) {
  var r = {};
  for (var n in e)
    Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var s = 0, n = Object.getOwnPropertySymbols(e); s < n.length; s++)
      t.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[s]) && (r[n[s]] = e[n[s]]);
  return r;
}
function jg(e, t, r, n) {
  var s = arguments.length, i = s < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    i = Reflect.decorate(e, t, r, n);
  else
    for (var a = e.length - 1; a >= 0; a--)
      (o = e[a]) && (i = (s < 3 ? o(i) : s > 3 ? o(t, r, i) : o(t, r)) || i);
  return s > 3 && i && Object.defineProperty(t, r, i), i;
}
function zg(e, t) {
  return function(r, n) {
    t(r, n, e);
  };
}
function qg(e, t) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(e, t);
}
function Wg(e, t, r, n) {
  function s(i) {
    return i instanceof r ? i : new r(function(o) {
      o(i);
    });
  }
  return new (r || (r = Promise))(function(i, o) {
    function a(l) {
      try {
        u(n.next(l));
      } catch (h) {
        o(h);
      }
    }
    function c(l) {
      try {
        u(n.throw(l));
      } catch (h) {
        o(h);
      }
    }
    function u(l) {
      l.done ? i(l.value) : s(l.value).then(a, c);
    }
    u((n = n.apply(e, t || [])).next());
  });
}
function Gg(e, t) {
  var r = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(u) {
    return function(l) {
      return c([u, l]);
    };
  }
  function c(u) {
    if (n)
      throw new TypeError("Generator is already executing.");
    for (; r; )
      try {
        if (n = 1, s && (i = u[0] & 2 ? s.return : u[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, u[1])).done)
          return i;
        switch (s = 0, i && (u = [u[0] & 2, i.value]), u[0]) {
          case 0:
          case 1:
            i = u;
            break;
          case 4:
            return r.label++, { value: u[1], done: !1 };
          case 5:
            r.label++, s = u[1], u = [0];
            continue;
          case 7:
            u = r.ops.pop(), r.trys.pop();
            continue;
          default:
            if (i = r.trys, !(i = i.length > 0 && i[i.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              r = 0;
              continue;
            }
            if (u[0] === 3 && (!i || u[1] > i[0] && u[1] < i[3])) {
              r.label = u[1];
              break;
            }
            if (u[0] === 6 && r.label < i[1]) {
              r.label = i[1], i = u;
              break;
            }
            if (i && r.label < i[2]) {
              r.label = i[2], r.ops.push(u);
              break;
            }
            i[2] && r.ops.pop(), r.trys.pop();
            continue;
        }
        u = t.call(e, r);
      } catch (l) {
        u = [6, l], s = 0;
      } finally {
        n = i = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function Vg(e, t, r, n) {
  n === void 0 && (n = r), e[n] = t[r];
}
function Kg(e, t) {
  for (var r in e)
    r !== "default" && !t.hasOwnProperty(r) && (t[r] = e[r]);
}
function Sn(e) {
  var t = typeof Symbol == "function" && Symbol.iterator, r = t && e[t], n = 0;
  if (r)
    return r.call(e);
  if (e && typeof e.length == "number")
    return {
      next: function() {
        return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e };
      }
    };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function rc(e, t) {
  var r = typeof Symbol == "function" && e[Symbol.iterator];
  if (!r)
    return e;
  var n = r.call(e), s, i = [], o;
  try {
    for (; (t === void 0 || t-- > 0) && !(s = n.next()).done; )
      i.push(s.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      s && !s.done && (r = n.return) && r.call(n);
    } finally {
      if (o)
        throw o.error;
    }
  }
  return i;
}
function Xg() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e = e.concat(rc(arguments[t]));
  return e;
}
function Zg() {
  for (var e = 0, t = 0, r = arguments.length; t < r; t++)
    e += arguments[t].length;
  for (var n = Array(e), s = 0, t = 0; t < r; t++)
    for (var i = arguments[t], o = 0, a = i.length; o < a; o++, s++)
      n[s] = i[o];
  return n;
}
function Ut(e) {
  return this instanceof Ut ? (this.v = e, this) : new Ut(e);
}
function Yg(e, t, r) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = r.apply(e, t || []), s, i = [];
  return s = {}, o("next"), o("throw"), o("return"), s[Symbol.asyncIterator] = function() {
    return this;
  }, s;
  function o(p) {
    n[p] && (s[p] = function(g) {
      return new Promise(function(b, A) {
        i.push([p, g, b, A]) > 1 || a(p, g);
      });
    });
  }
  function a(p, g) {
    try {
      c(n[p](g));
    } catch (b) {
      h(i[0][3], b);
    }
  }
  function c(p) {
    p.value instanceof Ut ? Promise.resolve(p.value.v).then(u, l) : h(i[0][2], p);
  }
  function u(p) {
    a("next", p);
  }
  function l(p) {
    a("throw", p);
  }
  function h(p, g) {
    p(g), i.shift(), i.length && a(i[0][0], i[0][1]);
  }
}
function Qg(e) {
  var t, r;
  return t = {}, n("next"), n("throw", function(s) {
    throw s;
  }), n("return"), t[Symbol.iterator] = function() {
    return this;
  }, t;
  function n(s, i) {
    t[s] = e[s] ? function(o) {
      return (r = !r) ? { value: Ut(e[s](o)), done: s === "return" } : i ? i(o) : o;
    } : i;
  }
}
function Jg(e) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = e[Symbol.asyncIterator], r;
  return t ? t.call(e) : (e = typeof Sn == "function" ? Sn(e) : e[Symbol.iterator](), r = {}, n("next"), n("throw"), n("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r);
  function n(i) {
    r[i] = e[i] && function(o) {
      return new Promise(function(a, c) {
        o = e[i](o), s(a, c, o.done, o.value);
      });
    };
  }
  function s(i, o, a, c) {
    Promise.resolve(c).then(function(u) {
      i({ value: u, done: a });
    }, o);
  }
}
function e0(e, t) {
  return Object.defineProperty ? Object.defineProperty(e, "raw", { value: t }) : e.raw = t, e;
}
function t0(e) {
  if (e && e.__esModule)
    return e;
  var t = {};
  if (e != null)
    for (var r in e)
      Object.hasOwnProperty.call(e, r) && (t[r] = e[r]);
  return t.default = e, t;
}
function r0(e) {
  return e && e.__esModule ? e : { default: e };
}
function n0(e, t) {
  if (!t.has(e))
    throw new TypeError("attempted to get private field on non-instance");
  return t.get(e);
}
function s0(e, t, r) {
  if (!t.has(e))
    throw new TypeError("attempted to set private field on non-instance");
  return t.set(e, r), r;
}
const i0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return An;
  },
  __asyncDelegator: Qg,
  __asyncGenerator: Yg,
  __asyncValues: Jg,
  __await: Ut,
  __awaiter: Wg,
  __classPrivateFieldGet: n0,
  __classPrivateFieldSet: s0,
  __createBinding: Vg,
  __decorate: jg,
  __exportStar: Kg,
  __extends: Lg,
  __generator: Gg,
  __importDefault: r0,
  __importStar: t0,
  __makeTemplateObject: e0,
  __metadata: qg,
  __param: zg,
  __read: rc,
  __rest: Hg,
  __spread: Xg,
  __spreadArrays: Zg,
  __values: Sn
}, Symbol.toStringTag, { value: "Module" })), _e = /* @__PURE__ */ _n(i0);
var ht = {}, pt = {}, gt = {}, ri;
function nc() {
  if (ri)
    return gt;
  ri = 1, Object.defineProperty(gt, "__esModule", { value: !0 }), gt.isEmptyData = void 0;
  function e(t) {
    return typeof t == "string" ? t.length === 0 : t.byteLength === 0;
  }
  return gt.isEmptyData = e, gt;
}
var Rr = {}, ni;
function sc() {
  return ni || (ni = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.EMPTY_DATA_SHA_1 = e.SHA_1_HMAC_ALGO = e.SHA_1_HASH = void 0, e.SHA_1_HASH = { name: "SHA-1" }, e.SHA_1_HMAC_ALGO = {
      name: "HMAC",
      hash: e.SHA_1_HASH
    }, e.EMPTY_DATA_SHA_1 = new Uint8Array([
      218,
      57,
      163,
      238,
      94,
      107,
      75,
      13,
      50,
      85,
      191,
      239,
      149,
      96,
      24,
      144,
      175,
      216,
      7,
      9
    ]);
  }(Rr)), Rr;
}
const o0 = (e) => {
  const t = [];
  for (let r = 0, n = e.length; r < n; r++) {
    const s = e.charCodeAt(r);
    if (s < 128)
      t.push(s);
    else if (s < 2048)
      t.push(s >> 6 | 192, s & 63 | 128);
    else if (r + 1 < e.length && (s & 64512) === 55296 && (e.charCodeAt(r + 1) & 64512) === 56320) {
      const i = 65536 + ((s & 1023) << 10) + (e.charCodeAt(++r) & 1023);
      t.push(i >> 18 | 240, i >> 12 & 63 | 128, i >> 6 & 63 | 128, i & 63 | 128);
    } else
      t.push(s >> 12 | 224, s >> 6 & 63 | 128, s & 63 | 128);
  }
  return Uint8Array.from(t);
}, a0 = (e) => {
  let t = "";
  for (let r = 0, n = e.length; r < n; r++) {
    const s = e[r];
    if (s < 128)
      t += String.fromCharCode(s);
    else if (192 <= s && s < 224) {
      const i = e[++r];
      t += String.fromCharCode((s & 31) << 6 | i & 63);
    } else if (240 <= s && s < 365) {
      const o = "%" + [s, e[++r], e[++r], e[++r]].map((a) => a.toString(16)).join("%");
      t += decodeURIComponent(o);
    } else
      t += String.fromCharCode((s & 15) << 12 | (e[++r] & 63) << 6 | e[++r] & 63);
  }
  return t;
};
function c0(e) {
  return new TextEncoder().encode(e);
}
function u0(e) {
  return new TextDecoder("utf-8").decode(e);
}
const d0 = (e) => typeof TextEncoder == "function" ? c0(e) : o0(e), l0 = (e) => typeof TextDecoder == "function" ? u0(e) : a0(e), f0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  fromUtf8: d0,
  toUtf8: l0
}, Symbol.toStringTag, { value: "Module" })), dr = /* @__PURE__ */ _n(f0), h0 = {};
function p0() {
  return typeof window < "u" ? window : typeof self < "u" ? self : h0;
}
const g0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  locateWindow: p0
}, Symbol.toStringTag, { value: "Module" })), dt = /* @__PURE__ */ _n(g0);
var si;
function ic() {
  if (si)
    return pt;
  si = 1, Object.defineProperty(pt, "__esModule", { value: !0 }), pt.Sha1 = void 0;
  var e = nc(), t = sc(), r = dr, n = dt, s = (
    /** @class */
    function() {
      function a(c) {
        this.secret = c, this.reset();
      }
      return a.prototype.update = function(c) {
        var u = this;
        (0, e.isEmptyData)(c) || (this.operation = this.operation.then(function(l) {
          return l.onerror = function() {
            u.operation = Promise.reject(new Error("Error encountered updating hash"));
          }, l.process(o(c)), l;
        }), this.operation.catch(function() {
        }));
      }, a.prototype.digest = function() {
        return this.operation.then(function(c) {
          return new Promise(function(u, l) {
            c.onerror = function() {
              l(new Error("Error encountered finalizing hash"));
            }, c.oncomplete = function() {
              c.result && u(new Uint8Array(c.result)), l(new Error("Error encountered finalizing hash"));
            }, c.finish();
          });
        });
      }, a.prototype.reset = function() {
        this.secret ? (this.operation = i(this.secret).then(function(c) {
          return (0, n.locateWindow)().msCrypto.subtle.sign(t.SHA_1_HMAC_ALGO, c);
        }), this.operation.catch(function() {
        })) : this.operation = Promise.resolve((0, n.locateWindow)().msCrypto.subtle.digest("SHA-1"));
      }, a;
    }()
  );
  pt.Sha1 = s;
  function i(a) {
    return new Promise(function(c, u) {
      var l = (0, n.locateWindow)().msCrypto.subtle.importKey("raw", o(a), t.SHA_1_HMAC_ALGO, !1, ["sign"]);
      l.oncomplete = function() {
        l.result && c(l.result), u(new Error("ImportKey completed without importing key."));
      }, l.onerror = function() {
        u(new Error("ImportKey failed to import key."));
      };
    });
  }
  function o(a) {
    return typeof a == "string" ? (0, r.fromUtf8)(a) : ArrayBuffer.isView(a) ? new Uint8Array(a.buffer, a.byteOffset, a.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(a);
  }
  return pt;
}
var mt = {}, ii;
function oc() {
  if (ii)
    return mt;
  ii = 1, Object.defineProperty(mt, "__esModule", { value: !0 }), mt.Sha1 = void 0;
  var e = dr, t = nc(), r = sc(), n = dt, s = (
    /** @class */
    function() {
      function o(a) {
        this.toHash = new Uint8Array(0), a !== void 0 && (this.key = new Promise(function(c, u) {
          (0, n.locateWindow)().crypto.subtle.importKey("raw", i(a), r.SHA_1_HMAC_ALGO, !1, ["sign"]).then(c, u);
        }), this.key.catch(function() {
        }));
      }
      return o.prototype.update = function(a) {
        if (!(0, t.isEmptyData)(a)) {
          var c = i(a), u = new Uint8Array(this.toHash.byteLength + c.byteLength);
          u.set(this.toHash, 0), u.set(c, this.toHash.byteLength), this.toHash = u;
        }
      }, o.prototype.digest = function() {
        var a = this;
        return this.key ? this.key.then(function(c) {
          return (0, n.locateWindow)().crypto.subtle.sign(r.SHA_1_HMAC_ALGO, c, a.toHash).then(function(u) {
            return new Uint8Array(u);
          });
        }) : (0, t.isEmptyData)(this.toHash) ? Promise.resolve(r.EMPTY_DATA_SHA_1) : Promise.resolve().then(function() {
          return (0, n.locateWindow)().crypto.subtle.digest(r.SHA_1_HASH, a.toHash);
        }).then(function(c) {
          return Promise.resolve(new Uint8Array(c));
        });
      }, o.prototype.reset = function() {
        this.toHash = new Uint8Array(0);
      }, o;
    }()
  );
  mt.Sha1 = s;
  function i(o) {
    return typeof o == "string" ? (0, e.fromUtf8)(o) : ArrayBuffer.isView(o) ? new Uint8Array(o.buffer, o.byteOffset, o.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(o);
  }
  return mt;
}
var _r = {}, Ae = {}, oi;
function m0() {
  if (oi)
    return Ae;
  oi = 1, Object.defineProperty(Ae, "__esModule", { value: !0 }), Ae.supportsZeroByteGCM = Ae.supportsSubtleCrypto = Ae.supportsSecureRandom = Ae.supportsWebCrypto = void 0;
  var e = _e, t = [
    "decrypt",
    "digest",
    "encrypt",
    "exportKey",
    "generateKey",
    "importKey",
    "sign",
    "verify"
  ];
  function r(o) {
    if (n(o) && typeof o.crypto.subtle == "object") {
      var a = o.crypto.subtle;
      return s(a);
    }
    return !1;
  }
  Ae.supportsWebCrypto = r;
  function n(o) {
    if (typeof o == "object" && typeof o.crypto == "object") {
      var a = o.crypto.getRandomValues;
      return typeof a == "function";
    }
    return !1;
  }
  Ae.supportsSecureRandom = n;
  function s(o) {
    return o && t.every(function(a) {
      return typeof o[a] == "function";
    });
  }
  Ae.supportsSubtleCrypto = s;
  function i(o) {
    return e.__awaiter(this, void 0, void 0, function() {
      var a, c;
      return e.__generator(this, function(u) {
        switch (u.label) {
          case 0:
            if (!s(o))
              return [2, !1];
            u.label = 1;
          case 1:
            return u.trys.push([1, 4, , 5]), [4, o.generateKey({ name: "AES-GCM", length: 128 }, !1, ["encrypt"])];
          case 2:
            return a = u.sent(), [4, o.encrypt({
              name: "AES-GCM",
              iv: new Uint8Array(Array(12)),
              additionalData: new Uint8Array(Array(16)),
              tagLength: 128
            }, a, new Uint8Array(0))];
          case 3:
            return c = u.sent(), [2, c.byteLength === 16];
          case 4:
            return u.sent(), [2, !1];
          case 5:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }
  return Ae.supportsZeroByteGCM = i, Ae;
}
var ai;
function ac() {
  return ai || (ai = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 });
    var t = _e;
    t.__exportStar(m0(), e);
  }(_r)), _r;
}
var Tr = {}, Br = {}, ci;
function y0() {
  return ci || (ci = 1, Object.defineProperty(Br, "__esModule", { value: !0 })), Br;
}
var kr = {}, ui;
function b0() {
  return ui || (ui = 1, Object.defineProperty(kr, "__esModule", { value: !0 })), kr;
}
var Nr = {}, di;
function w0() {
  return di || (di = 1, Object.defineProperty(Nr, "__esModule", { value: !0 })), Nr;
}
var Pr = {}, li;
function x0() {
  return li || (li = 1, Object.defineProperty(Pr, "__esModule", { value: !0 })), Pr;
}
var yt = {}, fi;
function E0() {
  if (fi)
    return yt;
  fi = 1, Object.defineProperty(yt, "__esModule", { value: !0 }), yt.isMsWindow = void 0;
  var e = [
    "decrypt",
    "digest",
    "encrypt",
    "exportKey",
    "generateKey",
    "importKey",
    "sign",
    "verify"
  ];
  function t(n) {
    return "MSInputMethodContext" in n && "msCrypto" in n;
  }
  function r(n) {
    if (t(n) && n.msCrypto.subtle !== void 0) {
      var s = n.msCrypto, i = s.getRandomValues, o = s.subtle;
      return e.map(function(a) {
        return o[a];
      }).concat(i).every(function(a) {
        return typeof a == "function";
      });
    }
    return !1;
  }
  return yt.isMsWindow = r, yt;
}
var hi;
function cc() {
  return hi || (hi = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 });
    var t = _e;
    t.__exportStar(y0(), e), t.__exportStar(b0(), e), t.__exportStar(w0(), e), t.__exportStar(x0(), e), t.__exportStar(E0(), e);
  }(Tr)), Tr;
}
var Or = {}, bt = {}, pi;
function A0() {
  if (pi)
    return bt;
  pi = 1, Object.defineProperty(bt, "__esModule", { value: !0 }), bt.convertToBuffer = void 0;
  var e = dr, t = typeof Buffer < "u" && Buffer.from ? function(n) {
    return Buffer.from(n, "utf8");
  } : e.fromUtf8;
  function r(n) {
    return n instanceof Uint8Array ? n : typeof n == "string" ? t(n) : ArrayBuffer.isView(n) ? new Uint8Array(n.buffer, n.byteOffset, n.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(n);
  }
  return bt.convertToBuffer = r, bt;
}
var wt = {}, gi;
function S0() {
  if (gi)
    return wt;
  gi = 1, Object.defineProperty(wt, "__esModule", { value: !0 }), wt.isEmptyData = void 0;
  function e(t) {
    return typeof t == "string" ? t.length === 0 : t.byteLength === 0;
  }
  return wt.isEmptyData = e, wt;
}
var xt = {}, mi;
function C0() {
  if (mi)
    return xt;
  mi = 1, Object.defineProperty(xt, "__esModule", { value: !0 }), xt.numToUint8 = void 0;
  function e(t) {
    return new Uint8Array([
      (t & 4278190080) >> 24,
      (t & 16711680) >> 16,
      (t & 65280) >> 8,
      t & 255
    ]);
  }
  return xt.numToUint8 = e, xt;
}
var Et = {}, yi;
function v0() {
  if (yi)
    return Et;
  yi = 1, Object.defineProperty(Et, "__esModule", { value: !0 }), Et.uint32ArrayFrom = void 0;
  function e(t) {
    if (!Uint32Array.from) {
      for (var r = new Uint32Array(t.length), n = 0; n < t.length; )
        r[n] = t[n], n += 1;
      return r;
    }
    return Uint32Array.from(t);
  }
  return Et.uint32ArrayFrom = e, Et;
}
var bi;
function We() {
  return bi || (bi = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.uint32ArrayFrom = e.numToUint8 = e.isEmptyData = e.convertToBuffer = void 0;
    var t = A0();
    Object.defineProperty(e, "convertToBuffer", { enumerable: !0, get: function() {
      return t.convertToBuffer;
    } });
    var r = S0();
    Object.defineProperty(e, "isEmptyData", { enumerable: !0, get: function() {
      return r.isEmptyData;
    } });
    var n = C0();
    Object.defineProperty(e, "numToUint8", { enumerable: !0, get: function() {
      return n.numToUint8;
    } });
    var s = v0();
    Object.defineProperty(e, "uint32ArrayFrom", { enumerable: !0, get: function() {
      return s.uint32ArrayFrom;
    } });
  }(Or)), Or;
}
var wi;
function R0() {
  if (wi)
    return ht;
  wi = 1, Object.defineProperty(ht, "__esModule", { value: !0 }), ht.Sha1 = void 0;
  var e = ic(), t = oc(), r = ac(), n = cc(), s = dt, i = We(), o = (
    /** @class */
    function() {
      function a(c) {
        if ((0, r.supportsWebCrypto)((0, s.locateWindow)()))
          this.hash = new t.Sha1(c);
        else if ((0, n.isMsWindow)((0, s.locateWindow)()))
          this.hash = new e.Sha1(c);
        else
          throw new Error("SHA1 not supported");
      }
      return a.prototype.update = function(c, u) {
        this.hash.update((0, i.convertToBuffer)(c));
      }, a.prototype.digest = function() {
        return this.hash.digest();
      }, a.prototype.reset = function() {
        this.hash.reset();
      }, a;
    }()
  );
  return ht.Sha1 = o, ht;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.WebCryptoSha1 = e.Ie11Sha1 = void 0;
  var t = _e;
  t.__exportStar(R0(), e);
  var r = ic();
  Object.defineProperty(e, "Ie11Sha1", { enumerable: !0, get: function() {
    return r.Sha1;
  } });
  var n = oc();
  Object.defineProperty(e, "WebCryptoSha1", { enumerable: !0, get: function() {
    return n.Sha1;
  } });
})(tc);
var uc = {}, At = {}, St = {}, Ct = {}, xi;
function _0() {
  if (xi)
    return Ct;
  xi = 1, Object.defineProperty(Ct, "__esModule", { value: !0 }), Ct.isEmptyData = void 0;
  function e(t) {
    return typeof t == "string" ? t.length === 0 : t.byteLength === 0;
  }
  return Ct.isEmptyData = e, Ct;
}
var Mr = {}, Ei;
function dc() {
  return Ei || (Ei = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.EMPTY_DATA_SHA_256 = e.SHA_256_HMAC_ALGO = e.SHA_256_HASH = void 0, e.SHA_256_HASH = { name: "SHA-256" }, e.SHA_256_HMAC_ALGO = {
      name: "HMAC",
      hash: e.SHA_256_HASH
    }, e.EMPTY_DATA_SHA_256 = new Uint8Array([
      227,
      176,
      196,
      66,
      152,
      252,
      28,
      20,
      154,
      251,
      244,
      200,
      153,
      111,
      185,
      36,
      39,
      174,
      65,
      228,
      100,
      155,
      147,
      76,
      164,
      149,
      153,
      27,
      120,
      82,
      184,
      85
    ]);
  }(Mr)), Mr;
}
var Ai;
function lc() {
  if (Ai)
    return St;
  Ai = 1, Object.defineProperty(St, "__esModule", { value: !0 }), St.Sha256 = void 0;
  var e = _0(), t = dc(), r = dr, n = dt, s = (
    /** @class */
    function() {
      function a(c) {
        this.secret = c, this.reset();
      }
      return a.prototype.update = function(c) {
        var u = this;
        (0, e.isEmptyData)(c) || (this.operation = this.operation.then(function(l) {
          return l.onerror = function() {
            u.operation = Promise.reject(new Error("Error encountered updating hash"));
          }, l.process(o(c)), l;
        }), this.operation.catch(function() {
        }));
      }, a.prototype.digest = function() {
        return this.operation.then(function(c) {
          return new Promise(function(u, l) {
            c.onerror = function() {
              l(new Error("Error encountered finalizing hash"));
            }, c.oncomplete = function() {
              c.result && u(new Uint8Array(c.result)), l(new Error("Error encountered finalizing hash"));
            }, c.finish();
          });
        });
      }, a.prototype.reset = function() {
        this.secret ? (this.operation = i(this.secret).then(function(c) {
          return (0, n.locateWindow)().msCrypto.subtle.sign(t.SHA_256_HMAC_ALGO, c);
        }), this.operation.catch(function() {
        })) : this.operation = Promise.resolve((0, n.locateWindow)().msCrypto.subtle.digest("SHA-256"));
      }, a;
    }()
  );
  St.Sha256 = s;
  function i(a) {
    return new Promise(function(c, u) {
      var l = (0, n.locateWindow)().msCrypto.subtle.importKey("raw", o(a), t.SHA_256_HMAC_ALGO, !1, ["sign"]);
      l.oncomplete = function() {
        l.result && c(l.result), u(new Error("ImportKey completed without importing key."));
      }, l.onerror = function() {
        u(new Error("ImportKey failed to import key."));
      };
    });
  }
  function o(a) {
    return typeof a == "string" ? (0, r.fromUtf8)(a) : ArrayBuffer.isView(a) ? new Uint8Array(a.buffer, a.byteOffset, a.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(a);
  }
  return St;
}
var vt = {}, Si;
function fc() {
  if (Si)
    return vt;
  Si = 1, Object.defineProperty(vt, "__esModule", { value: !0 }), vt.Sha256 = void 0;
  var e = We(), t = dc(), r = dt, n = (
    /** @class */
    function() {
      function s(i) {
        this.toHash = new Uint8Array(0), this.secret = i, this.reset();
      }
      return s.prototype.update = function(i) {
        if (!(0, e.isEmptyData)(i)) {
          var o = (0, e.convertToBuffer)(i), a = new Uint8Array(this.toHash.byteLength + o.byteLength);
          a.set(this.toHash, 0), a.set(o, this.toHash.byteLength), this.toHash = a;
        }
      }, s.prototype.digest = function() {
        var i = this;
        return this.key ? this.key.then(function(o) {
          return (0, r.locateWindow)().crypto.subtle.sign(t.SHA_256_HMAC_ALGO, o, i.toHash).then(function(a) {
            return new Uint8Array(a);
          });
        }) : (0, e.isEmptyData)(this.toHash) ? Promise.resolve(t.EMPTY_DATA_SHA_256) : Promise.resolve().then(function() {
          return (0, r.locateWindow)().crypto.subtle.digest(t.SHA_256_HASH, i.toHash);
        }).then(function(o) {
          return Promise.resolve(new Uint8Array(o));
        });
      }, s.prototype.reset = function() {
        var i = this;
        this.toHash = new Uint8Array(0), this.secret && this.secret !== void 0 && (this.key = new Promise(function(o, a) {
          (0, r.locateWindow)().crypto.subtle.importKey("raw", (0, e.convertToBuffer)(i.secret), t.SHA_256_HMAC_ALGO, !1, ["sign"]).then(o, a);
        }), this.key.catch(function() {
        }));
      }, s;
    }()
  );
  return vt.Sha256 = n, vt;
}
var Ir = {}, Rt = {}, me = {}, Ci;
function hc() {
  return Ci || (Ci = 1, Object.defineProperty(me, "__esModule", { value: !0 }), me.MAX_HASHABLE_LENGTH = me.INIT = me.KEY = me.DIGEST_LENGTH = me.BLOCK_SIZE = void 0, me.BLOCK_SIZE = 64, me.DIGEST_LENGTH = 32, me.KEY = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]), me.INIT = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], me.MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1), me;
}
var _t = {}, vi;
function T0() {
  if (vi)
    return _t;
  vi = 1, Object.defineProperty(_t, "__esModule", { value: !0 }), _t.RawSha256 = void 0;
  var e = hc(), t = (
    /** @class */
    function() {
      function r() {
        this.state = Int32Array.from(e.INIT), this.temp = new Int32Array(64), this.buffer = new Uint8Array(64), this.bufferLength = 0, this.bytesHashed = 0, this.finished = !1;
      }
      return r.prototype.update = function(n) {
        if (this.finished)
          throw new Error("Attempted to update an already finished hash.");
        var s = 0, i = n.byteLength;
        if (this.bytesHashed += i, this.bytesHashed * 8 > e.MAX_HASHABLE_LENGTH)
          throw new Error("Cannot hash more than 2^53 - 1 bits");
        for (; i > 0; )
          this.buffer[this.bufferLength++] = n[s++], i--, this.bufferLength === e.BLOCK_SIZE && (this.hashBuffer(), this.bufferLength = 0);
      }, r.prototype.digest = function() {
        if (!this.finished) {
          var n = this.bytesHashed * 8, s = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength), i = this.bufferLength;
          if (s.setUint8(this.bufferLength++, 128), i % e.BLOCK_SIZE >= e.BLOCK_SIZE - 8) {
            for (var o = this.bufferLength; o < e.BLOCK_SIZE; o++)
              s.setUint8(o, 0);
            this.hashBuffer(), this.bufferLength = 0;
          }
          for (var o = this.bufferLength; o < e.BLOCK_SIZE - 8; o++)
            s.setUint8(o, 0);
          s.setUint32(e.BLOCK_SIZE - 8, Math.floor(n / 4294967296), !0), s.setUint32(e.BLOCK_SIZE - 4, n), this.hashBuffer(), this.finished = !0;
        }
        for (var a = new Uint8Array(e.DIGEST_LENGTH), o = 0; o < 8; o++)
          a[o * 4] = this.state[o] >>> 24 & 255, a[o * 4 + 1] = this.state[o] >>> 16 & 255, a[o * 4 + 2] = this.state[o] >>> 8 & 255, a[o * 4 + 3] = this.state[o] >>> 0 & 255;
        return a;
      }, r.prototype.hashBuffer = function() {
        for (var n = this, s = n.buffer, i = n.state, o = i[0], a = i[1], c = i[2], u = i[3], l = i[4], h = i[5], p = i[6], g = i[7], b = 0; b < e.BLOCK_SIZE; b++) {
          if (b < 16)
            this.temp[b] = (s[b * 4] & 255) << 24 | (s[b * 4 + 1] & 255) << 16 | (s[b * 4 + 2] & 255) << 8 | s[b * 4 + 3] & 255;
          else {
            var A = this.temp[b - 2], R = (A >>> 17 | A << 15) ^ (A >>> 19 | A << 13) ^ A >>> 10;
            A = this.temp[b - 15];
            var T = (A >>> 7 | A << 25) ^ (A >>> 18 | A << 14) ^ A >>> 3;
            this.temp[b] = (R + this.temp[b - 7] | 0) + (T + this.temp[b - 16] | 0);
          }
          var I = (((l >>> 6 | l << 26) ^ (l >>> 11 | l << 21) ^ (l >>> 25 | l << 7)) + (l & h ^ ~l & p) | 0) + (g + (e.KEY[b] + this.temp[b] | 0) | 0) | 0, $ = ((o >>> 2 | o << 30) ^ (o >>> 13 | o << 19) ^ (o >>> 22 | o << 10)) + (o & a ^ o & c ^ a & c) | 0;
          g = p, p = h, h = l, l = u + I | 0, u = c, c = a, a = o, o = I + $ | 0;
        }
        i[0] += o, i[1] += a, i[2] += c, i[3] += u, i[4] += l, i[5] += h, i[6] += p, i[7] += g;
      }, r;
    }()
  );
  return _t.RawSha256 = t, _t;
}
var Ri;
function B0() {
  if (Ri)
    return Rt;
  Ri = 1, Object.defineProperty(Rt, "__esModule", { value: !0 }), Rt.Sha256 = void 0;
  var e = _e, t = hc(), r = T0(), n = We(), s = (
    /** @class */
    function() {
      function o(a) {
        this.secret = a, this.hash = new r.RawSha256(), this.reset();
      }
      return o.prototype.update = function(a) {
        if (!((0, n.isEmptyData)(a) || this.error))
          try {
            this.hash.update((0, n.convertToBuffer)(a));
          } catch (c) {
            this.error = c;
          }
      }, o.prototype.digestSync = function() {
        if (this.error)
          throw this.error;
        return this.outer ? (this.outer.finished || this.outer.update(this.hash.digest()), this.outer.digest()) : this.hash.digest();
      }, o.prototype.digest = function() {
        return e.__awaiter(this, void 0, void 0, function() {
          return e.__generator(this, function(a) {
            return [2, this.digestSync()];
          });
        });
      }, o.prototype.reset = function() {
        if (this.hash = new r.RawSha256(), this.secret) {
          this.outer = new r.RawSha256();
          var a = i(this.secret), c = new Uint8Array(t.BLOCK_SIZE);
          c.set(a);
          for (var u = 0; u < t.BLOCK_SIZE; u++)
            a[u] ^= 54, c[u] ^= 92;
          this.hash.update(a), this.outer.update(c);
          for (var u = 0; u < a.byteLength; u++)
            a[u] = 0;
        }
      }, o;
    }()
  );
  Rt.Sha256 = s;
  function i(o) {
    var a = (0, n.convertToBuffer)(o);
    if (a.byteLength > t.BLOCK_SIZE) {
      var c = new r.RawSha256();
      c.update(a), a = c.digest();
    }
    var u = new Uint8Array(t.BLOCK_SIZE);
    return u.set(a), u;
  }
  return Rt;
}
var _i;
function k0() {
  return _i || (_i = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 });
    var t = _e;
    t.__exportStar(B0(), e);
  }(Ir)), Ir;
}
var Ti;
function N0() {
  if (Ti)
    return At;
  Ti = 1, Object.defineProperty(At, "__esModule", { value: !0 }), At.Sha256 = void 0;
  var e = lc(), t = fc(), r = k0(), n = ac(), s = cc(), i = dt, o = We(), a = (
    /** @class */
    function() {
      function c(u) {
        (0, n.supportsWebCrypto)((0, i.locateWindow)()) ? this.hash = new t.Sha256(u) : (0, s.isMsWindow)((0, i.locateWindow)()) ? this.hash = new e.Sha256(u) : this.hash = new r.Sha256(u);
      }
      return c.prototype.update = function(u, l) {
        this.hash.update((0, o.convertToBuffer)(u));
      }, c.prototype.digest = function() {
        return this.hash.digest();
      }, c.prototype.reset = function() {
        this.hash.reset();
      }, c;
    }()
  );
  return At.Sha256 = a, At;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.WebCryptoSha256 = e.Ie11Sha256 = void 0;
  var t = _e;
  t.__exportStar(N0(), e);
  var r = lc();
  Object.defineProperty(e, "Ie11Sha256", { enumerable: !0, get: function() {
    return r.Sha256;
  } });
  var n = fc();
  Object.defineProperty(e, "WebCryptoSha256", { enumerable: !0, get: function() {
    return n.Sha256;
  } });
})(uc);
const P0 = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
}, pc = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
}, j = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv"
}, ue = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
}, $e = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};
class w {
  /**
   * Get first matched item for a string
   * @param {RegExp} regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getFirstMatch(t, r) {
    const n = r.match(t);
    return n && n.length > 0 && n[1] || "";
  }
  /**
   * Get second matched item for a string
   * @param regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getSecondMatch(t, r) {
    const n = r.match(t);
    return n && n.length > 1 && n[2] || "";
  }
  /**
   * Match a regexp and return a constant or undefined
   * @param {RegExp} regexp
   * @param {String} ua
   * @param {*} _const Any const that will be returned if regexp matches the string
   * @return {*}
   */
  static matchAndReturnConst(t, r, n) {
    if (t.test(r))
      return n;
  }
  static getWindowsVersionName(t) {
    switch (t) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return;
    }
  }
  /**
   * Get macOS version name
   *    10.5 - Leopard
   *    10.6 - Snow Leopard
   *    10.7 - Lion
   *    10.8 - Mountain Lion
   *    10.9 - Mavericks
   *    10.10 - Yosemite
   *    10.11 - El Capitan
   *    10.12 - Sierra
   *    10.13 - High Sierra
   *    10.14 - Mojave
   *    10.15 - Catalina
   *
   * @example
   *   getMacOSVersionName("10.14") // 'Mojave'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getMacOSVersionName(t) {
    const r = t.split(".").splice(0, 2).map((n) => parseInt(n, 10) || 0);
    if (r.push(0), r[0] === 10)
      switch (r[1]) {
        case 5:
          return "Leopard";
        case 6:
          return "Snow Leopard";
        case 7:
          return "Lion";
        case 8:
          return "Mountain Lion";
        case 9:
          return "Mavericks";
        case 10:
          return "Yosemite";
        case 11:
          return "El Capitan";
        case 12:
          return "Sierra";
        case 13:
          return "High Sierra";
        case 14:
          return "Mojave";
        case 15:
          return "Catalina";
        default:
          return;
      }
  }
  /**
   * Get Android version name
   *    1.5 - Cupcake
   *    1.6 - Donut
   *    2.0 - Eclair
   *    2.1 - Eclair
   *    2.2 - Froyo
   *    2.x - Gingerbread
   *    3.x - Honeycomb
   *    4.0 - Ice Cream Sandwich
   *    4.1 - Jelly Bean
   *    4.4 - KitKat
   *    5.x - Lollipop
   *    6.x - Marshmallow
   *    7.x - Nougat
   *    8.x - Oreo
   *    9.x - Pie
   *
   * @example
   *   getAndroidVersionName("7.0") // 'Nougat'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getAndroidVersionName(t) {
    const r = t.split(".").splice(0, 2).map((n) => parseInt(n, 10) || 0);
    if (r.push(0), !(r[0] === 1 && r[1] < 5)) {
      if (r[0] === 1 && r[1] < 6)
        return "Cupcake";
      if (r[0] === 1 && r[1] >= 6)
        return "Donut";
      if (r[0] === 2 && r[1] < 2)
        return "Eclair";
      if (r[0] === 2 && r[1] === 2)
        return "Froyo";
      if (r[0] === 2 && r[1] > 2)
        return "Gingerbread";
      if (r[0] === 3)
        return "Honeycomb";
      if (r[0] === 4 && r[1] < 1)
        return "Ice Cream Sandwich";
      if (r[0] === 4 && r[1] < 4)
        return "Jelly Bean";
      if (r[0] === 4 && r[1] >= 4)
        return "KitKat";
      if (r[0] === 5)
        return "Lollipop";
      if (r[0] === 6)
        return "Marshmallow";
      if (r[0] === 7)
        return "Nougat";
      if (r[0] === 8)
        return "Oreo";
      if (r[0] === 9)
        return "Pie";
    }
  }
  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  static getVersionPrecision(t) {
    return t.split(".").length;
  }
  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1
   *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1
   *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0
   *   compareVersions('1.10.2.1',  '1.0800.2');     // -1
   *   compareVersions('1.10.2.1',  '1.10',  true);  // 0
   *
   * @param {String} versionA versions versions to compare
   * @param {String} versionB versions versions to compare
   * @param {boolean} [isLoose] enable loose comparison
   * @return {Number} comparison result: -1 when versionA is lower,
   * 1 when versionA is bigger, 0 when both equal
   */
  /* eslint consistent-return: 1 */
  static compareVersions(t, r, n = !1) {
    const s = w.getVersionPrecision(t), i = w.getVersionPrecision(r);
    let o = Math.max(s, i), a = 0;
    const c = w.map([t, r], (u) => {
      const l = o - w.getVersionPrecision(u), h = u + new Array(l + 1).join(".0");
      return w.map(h.split("."), (p) => new Array(20 - p.length).join("0") + p).reverse();
    });
    for (n && (a = o - Math.min(s, i)), o -= 1; o >= a; ) {
      if (c[0][o] > c[1][o])
        return 1;
      if (c[0][o] === c[1][o]) {
        if (o === a)
          return 0;
        o -= 1;
      } else if (c[0][o] < c[1][o])
        return -1;
    }
  }
  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  static map(t, r) {
    const n = [];
    let s;
    if (Array.prototype.map)
      return Array.prototype.map.call(t, r);
    for (s = 0; s < t.length; s += 1)
      n.push(r(t[s]));
    return n;
  }
  /**
   * Array::find polyfill
   *
   * @param  {Array} arr
   * @param  {Function} predicate
   * @return {Array}
   */
  static find(t, r) {
    let n, s;
    if (Array.prototype.find)
      return Array.prototype.find.call(t, r);
    for (n = 0, s = t.length; n < s; n += 1) {
      const i = t[n];
      if (r(i, n))
        return i;
    }
  }
  /**
   * Object::assign polyfill
   *
   * @param  {Object} obj
   * @param  {Object} ...objs
   * @return {Object}
   */
  static assign(t, ...r) {
    const n = t;
    let s, i;
    if (Object.assign)
      return Object.assign(t, ...r);
    for (s = 0, i = r.length; s < i; s += 1) {
      const o = r[s];
      typeof o == "object" && o !== null && Object.keys(o).forEach((c) => {
        n[c] = o[c];
      });
    }
    return t;
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('Microsoft Edge') // edge
   *
   * @param  {string} browserName
   * @return {string}
   */
  static getBrowserAlias(t) {
    return P0[t];
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('edge') // Microsoft Edge
   *
   * @param  {string} browserAlias
   * @return {string}
   */
  static getBrowserTypeByAlias(t) {
    return pc[t] || "";
  }
}
const F = /version\/(\d+(\.?_?\d+)+)/i, O0 = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe(e) {
      const t = {
        name: "Googlebot"
      }, r = w.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e) || w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  /* Opera < 13.0 */
  {
    test: [/opera/i],
    describe(e) {
      const t = {
        name: "Opera"
      }, r = w.getFirstMatch(F, e) || w.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  /* Opera > 13.0 */
  {
    test: [/opr\/|opios/i],
    describe(e) {
      const t = {
        name: "Opera"
      }, r = w.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e) || w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe(e) {
      const t = {
        name: "Samsung Internet for Android"
      }, r = w.getFirstMatch(F, e) || w.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/Whale/i],
    describe(e) {
      const t = {
        name: "NAVER Whale Browser"
      }, r = w.getFirstMatch(F, e) || w.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/MZBrowser/i],
    describe(e) {
      const t = {
        name: "MZ Browser"
      }, r = w.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e) || w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/focus/i],
    describe(e) {
      const t = {
        name: "Focus"
      }, r = w.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e) || w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/swing/i],
    describe(e) {
      const t = {
        name: "Swing"
      }, r = w.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e) || w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/coast/i],
    describe(e) {
      const t = {
        name: "Opera Coast"
      }, r = w.getFirstMatch(F, e) || w.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(e) {
      const t = {
        name: "Opera Touch"
      }, r = w.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e) || w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/yabrowser/i],
    describe(e) {
      const t = {
        name: "Yandex Browser"
      }, r = w.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e) || w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/ucbrowser/i],
    describe(e) {
      const t = {
        name: "UC Browser"
      }, r = w.getFirstMatch(F, e) || w.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe(e) {
      const t = {
        name: "Maxthon"
      }, r = w.getFirstMatch(F, e) || w.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/epiphany/i],
    describe(e) {
      const t = {
        name: "Epiphany"
      }, r = w.getFirstMatch(F, e) || w.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/puffin/i],
    describe(e) {
      const t = {
        name: "Puffin"
      }, r = w.getFirstMatch(F, e) || w.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/sleipnir/i],
    describe(e) {
      const t = {
        name: "Sleipnir"
      }, r = w.getFirstMatch(F, e) || w.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/k-meleon/i],
    describe(e) {
      const t = {
        name: "K-Meleon"
      }, r = w.getFirstMatch(F, e) || w.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/micromessenger/i],
    describe(e) {
      const t = {
        name: "WeChat"
      }, r = w.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e) || w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/qqbrowser/i],
    describe(e) {
      const t = {
        name: /qqbrowserlite/i.test(e) ? "QQ Browser Lite" : "QQ Browser"
      }, r = w.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e) || w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/msie|trident/i],
    describe(e) {
      const t = {
        name: "Internet Explorer"
      }, r = w.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/\sedg\//i],
    describe(e) {
      const t = {
        name: "Microsoft Edge"
      }, r = w.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe(e) {
      const t = {
        name: "Microsoft Edge"
      }, r = w.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/vivaldi/i],
    describe(e) {
      const t = {
        name: "Vivaldi"
      }, r = w.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/seamonkey/i],
    describe(e) {
      const t = {
        name: "SeaMonkey"
      }, r = w.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/sailfish/i],
    describe(e) {
      const t = {
        name: "Sailfish"
      }, r = w.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/silk/i],
    describe(e) {
      const t = {
        name: "Amazon Silk"
      }, r = w.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/phantom/i],
    describe(e) {
      const t = {
        name: "PhantomJS"
      }, r = w.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/slimerjs/i],
    describe(e) {
      const t = {
        name: "SlimerJS"
      }, r = w.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(e) {
      const t = {
        name: "BlackBerry"
      }, r = w.getFirstMatch(F, e) || w.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(e) {
      const t = {
        name: "WebOS Browser"
      }, r = w.getFirstMatch(F, e) || w.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/bada/i],
    describe(e) {
      const t = {
        name: "Bada"
      }, r = w.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/tizen/i],
    describe(e) {
      const t = {
        name: "Tizen"
      }, r = w.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e) || w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/qupzilla/i],
    describe(e) {
      const t = {
        name: "QupZilla"
      }, r = w.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e) || w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe(e) {
      const t = {
        name: "Firefox"
      }, r = w.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/electron/i],
    describe(e) {
      const t = {
        name: "Electron"
      }, r = w.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe(e) {
      const t = {
        name: "Miui"
      }, r = w.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/chromium/i],
    describe(e) {
      const t = {
        name: "Chromium"
      }, r = w.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e) || w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe(e) {
      const t = {
        name: "Chrome"
      }, r = w.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/GSA/i],
    describe(e) {
      const t = {
        name: "Google Search"
      }, r = w.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  /* Android Browser */
  {
    test(e) {
      const t = !e.test(/like android/i), r = e.test(/android/i);
      return t && r;
    },
    describe(e) {
      const t = {
        name: "Android Browser"
      }, r = w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  /* PlayStation 4 */
  {
    test: [/playstation 4/i],
    describe(e) {
      const t = {
        name: "PlayStation 4"
      }, r = w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  /* Safari */
  {
    test: [/safari|applewebkit/i],
    describe(e) {
      const t = {
        name: "Safari"
      }, r = w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  /* Something else */
  {
    test: [/.*/i],
    describe(e) {
      const t = /^(.*)\/(.*) /, r = /^(.*)\/(.*)[ \t]\((.*)/, s = e.search("\\(") !== -1 ? r : t;
      return {
        name: w.getFirstMatch(s, e),
        version: w.getSecondMatch(s, e)
      };
    }
  }
], M0 = [
  /* Roku */
  {
    test: [/Roku\/DVP/],
    describe(e) {
      const t = w.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e);
      return {
        name: ue.Roku,
        version: t
      };
    }
  },
  /* Windows Phone */
  {
    test: [/windows phone/i],
    describe(e) {
      const t = w.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e);
      return {
        name: ue.WindowsPhone,
        version: t
      };
    }
  },
  /* Windows */
  {
    test: [/windows /i],
    describe(e) {
      const t = w.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e), r = w.getWindowsVersionName(t);
      return {
        name: ue.Windows,
        version: t,
        versionName: r
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(e) {
      const t = {
        name: ue.iOS
      }, r = w.getSecondMatch(/(Version\/)(\d[\d.]+)/, e);
      return r && (t.version = r), t;
    }
  },
  /* macOS */
  {
    test: [/macintosh/i],
    describe(e) {
      const t = w.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e).replace(/[_\s]/g, "."), r = w.getMacOSVersionName(t), n = {
        name: ue.MacOS,
        version: t
      };
      return r && (n.versionName = r), n;
    }
  },
  /* iOS */
  {
    test: [/(ipod|iphone|ipad)/i],
    describe(e) {
      const t = w.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e).replace(/[_\s]/g, ".");
      return {
        name: ue.iOS,
        version: t
      };
    }
  },
  /* Android */
  {
    test(e) {
      const t = !e.test(/like android/i), r = e.test(/android/i);
      return t && r;
    },
    describe(e) {
      const t = w.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e), r = w.getAndroidVersionName(t), n = {
        name: ue.Android,
        version: t
      };
      return r && (n.versionName = r), n;
    }
  },
  /* WebOS */
  {
    test: [/(web|hpw)[o0]s/i],
    describe(e) {
      const t = w.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e), r = {
        name: ue.WebOS
      };
      return t && t.length && (r.version = t), r;
    }
  },
  /* BlackBerry */
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(e) {
      const t = w.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e) || w.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e) || w.getFirstMatch(/\bbb(\d+)/i, e);
      return {
        name: ue.BlackBerry,
        version: t
      };
    }
  },
  /* Bada */
  {
    test: [/bada/i],
    describe(e) {
      const t = w.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e);
      return {
        name: ue.Bada,
        version: t
      };
    }
  },
  /* Tizen */
  {
    test: [/tizen/i],
    describe(e) {
      const t = w.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e);
      return {
        name: ue.Tizen,
        version: t
      };
    }
  },
  /* Linux */
  {
    test: [/linux/i],
    describe() {
      return {
        name: ue.Linux
      };
    }
  },
  /* Chrome OS */
  {
    test: [/CrOS/],
    describe() {
      return {
        name: ue.ChromeOS
      };
    }
  },
  /* Playstation 4 */
  {
    test: [/PlayStation 4/],
    describe(e) {
      const t = w.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e);
      return {
        name: ue.PlayStation4,
        version: t
      };
    }
  }
], I0 = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: "bot",
        vendor: "Google"
      };
    }
  },
  /* Huawei */
  {
    test: [/huawei/i],
    describe(e) {
      const t = w.getFirstMatch(/(can-l01)/i, e) && "Nova", r = {
        type: j.mobile,
        vendor: "Huawei"
      };
      return t && (r.model = t), r;
    }
  },
  /* Nexus Tablet */
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: j.tablet,
        vendor: "Nexus"
      };
    }
  },
  /* iPad */
  {
    test: [/ipad/i],
    describe() {
      return {
        type: j.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: j.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Amazon Kindle Fire */
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: j.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  /* Another Amazon Tablet with Silk */
  {
    test: [/silk/i],
    describe() {
      return {
        type: j.tablet,
        vendor: "Amazon"
      };
    }
  },
  /* Tablet */
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: j.tablet
      };
    }
  },
  /* iPod/iPhone */
  {
    test(e) {
      const t = e.test(/ipod|iphone/i), r = e.test(/like (ipod|iphone)/i);
      return t && !r;
    },
    describe(e) {
      const t = w.getFirstMatch(/(ipod|iphone)/i, e);
      return {
        type: j.mobile,
        vendor: "Apple",
        model: t
      };
    }
  },
  /* Nexus Mobile */
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: j.mobile,
        vendor: "Nexus"
      };
    }
  },
  /* Mobile */
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: j.mobile
      };
    }
  },
  /* BlackBerry */
  {
    test(e) {
      return e.getBrowserName(!0) === "blackberry";
    },
    describe() {
      return {
        type: j.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  /* Bada */
  {
    test(e) {
      return e.getBrowserName(!0) === "bada";
    },
    describe() {
      return {
        type: j.mobile
      };
    }
  },
  /* Windows Phone */
  {
    test(e) {
      return e.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: j.mobile,
        vendor: "Microsoft"
      };
    }
  },
  /* Android Tablet */
  {
    test(e) {
      const t = Number(String(e.getOSVersion()).split(".")[0]);
      return e.getOSName(!0) === "android" && t >= 3;
    },
    describe() {
      return {
        type: j.tablet
      };
    }
  },
  /* Android Mobile */
  {
    test(e) {
      return e.getOSName(!0) === "android";
    },
    describe() {
      return {
        type: j.mobile
      };
    }
  },
  /* desktop */
  {
    test(e) {
      return e.getOSName(!0) === "macos";
    },
    describe() {
      return {
        type: j.desktop,
        vendor: "Apple"
      };
    }
  },
  /* Windows */
  {
    test(e) {
      return e.getOSName(!0) === "windows";
    },
    describe() {
      return {
        type: j.desktop
      };
    }
  },
  /* Linux */
  {
    test(e) {
      return e.getOSName(!0) === "linux";
    },
    describe() {
      return {
        type: j.desktop
      };
    }
  },
  /* PlayStation 4 */
  {
    test(e) {
      return e.getOSName(!0) === "playstation 4";
    },
    describe() {
      return {
        type: j.tv
      };
    }
  },
  /* Roku */
  {
    test(e) {
      return e.getOSName(!0) === "roku";
    },
    describe() {
      return {
        type: j.tv
      };
    }
  }
], F0 = [
  /* EdgeHTML */
  {
    test(e) {
      return e.getBrowserName(!0) === "microsoft edge";
    },
    describe(e) {
      if (/\sedg\//i.test(e))
        return {
          name: $e.Blink
        };
      const r = w.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e);
      return {
        name: $e.EdgeHTML,
        version: r
      };
    }
  },
  /* Trident */
  {
    test: [/trident/i],
    describe(e) {
      const t = {
        name: $e.Trident
      }, r = w.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  /* Presto */
  {
    test(e) {
      return e.test(/presto/i);
    },
    describe(e) {
      const t = {
        name: $e.Presto
      }, r = w.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  /* Gecko */
  {
    test(e) {
      const t = e.test(/gecko/i), r = e.test(/like gecko/i);
      return t && !r;
    },
    describe(e) {
      const t = {
        name: $e.Gecko
      }, r = w.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  /* Blink */
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: $e.Blink
      };
    }
  },
  /* WebKit */
  {
    test: [/(apple)?webkit/i],
    describe(e) {
      const t = {
        name: $e.WebKit
      }, r = w.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  }
];
class Bi {
  /**
   * Create instance of Parser
   *
   * @param {String} UA User-Agent string
   * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
   * improvements if you need to make a more particular parsing
   * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
   *
   * @throw {Error} in case of empty UA String
   *
   * @constructor
   */
  constructor(t, r = !1) {
    if (t == null || t === "")
      throw new Error("UserAgent parameter can't be empty");
    this._ua = t, this.parsedResult = {}, r !== !0 && this.parse();
  }
  /**
   * Get UserAgent string of current Parser instance
   * @return {String} User-Agent String of the current <Parser> object
   *
   * @public
   */
  getUA() {
    return this._ua;
  }
  /**
   * Test a UA string for a regexp
   * @param {RegExp} regex
   * @return {Boolean}
   */
  test(t) {
    return t.test(this._ua);
  }
  /**
   * Get parsed browser object
   * @return {Object}
   */
  parseBrowser() {
    this.parsedResult.browser = {};
    const t = w.find(O0, (r) => {
      if (typeof r.test == "function")
        return r.test(this);
      if (r.test instanceof Array)
        return r.test.some((n) => this.test(n));
      throw new Error("Browser's test function is not valid");
    });
    return t && (this.parsedResult.browser = t.describe(this.getUA())), this.parsedResult.browser;
  }
  /**
   * Get parsed browser object
   * @return {Object}
   *
   * @public
   */
  getBrowser() {
    return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
  }
  /**
   * Get browser's name
   * @return {String} Browser's name or an empty string
   *
   * @public
   */
  getBrowserName(t) {
    return t ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
  }
  /**
   * Get browser's version
   * @return {String} version of browser
   *
   * @public
   */
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  /**
   * Get OS
   * @return {Object}
   *
   * @example
   * this.getOS();
   * {
   *   name: 'macOS',
   *   version: '10.11.12'
   * }
   */
  getOS() {
    return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
  }
  /**
   * Parse OS and save it to this.parsedResult.os
   * @return {*|{}}
   */
  parseOS() {
    this.parsedResult.os = {};
    const t = w.find(M0, (r) => {
      if (typeof r.test == "function")
        return r.test(this);
      if (r.test instanceof Array)
        return r.test.some((n) => this.test(n));
      throw new Error("Browser's test function is not valid");
    });
    return t && (this.parsedResult.os = t.describe(this.getUA())), this.parsedResult.os;
  }
  /**
   * Get OS name
   * @param {Boolean} [toLowerCase] return lower-cased value
   * @return {String} name of the OS  macOS, Windows, Linux, etc.
   */
  getOSName(t) {
    const { name: r } = this.getOS();
    return t ? String(r).toLowerCase() || "" : r || "";
  }
  /**
   * Get OS version
   * @return {String} full version with dots ('10.11.12', '5.6', etc)
   */
  getOSVersion() {
    return this.getOS().version;
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  getPlatform() {
    return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
  }
  /**
   * Get platform name
   * @param {Boolean} [toLowerCase=false]
   * @return {*}
   */
  getPlatformType(t = !1) {
    const { type: r } = this.getPlatform();
    return t ? String(r).toLowerCase() || "" : r || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parsePlatform() {
    this.parsedResult.platform = {};
    const t = w.find(I0, (r) => {
      if (typeof r.test == "function")
        return r.test(this);
      if (r.test instanceof Array)
        return r.test.some((n) => this.test(n));
      throw new Error("Browser's test function is not valid");
    });
    return t && (this.parsedResult.platform = t.describe(this.getUA())), this.parsedResult.platform;
  }
  /**
   * Get parsed engine
   * @return {{}}
   */
  getEngine() {
    return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
  }
  /**
   * Get engines's name
   * @return {String} Engines's name or an empty string
   *
   * @public
   */
  getEngineName(t) {
    return t ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parseEngine() {
    this.parsedResult.engine = {};
    const t = w.find(F0, (r) => {
      if (typeof r.test == "function")
        return r.test(this);
      if (r.test instanceof Array)
        return r.test.some((n) => this.test(n));
      throw new Error("Browser's test function is not valid");
    });
    return t && (this.parsedResult.engine = t.describe(this.getUA())), this.parsedResult.engine;
  }
  /**
   * Parse full information about the browser
   * @returns {Parser}
   */
  parse() {
    return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
  }
  /**
   * Get parsed result
   * @return {ParsedResult}
   */
  getResult() {
    return w.assign({}, this.parsedResult);
  }
  /**
   * Check if parsed browser matches certain conditions
   *
   * @param {Object} checkTree It's one or two layered object,
   * which can include a platform or an OS on the first layer
   * and should have browsers specs on the bottom-laying layer
   *
   * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
   * Returns `undefined` when the browser is no described in the checkTree object.
   *
   * @example
   * const browser = Bowser.getParser(window.navigator.userAgent);
   * if (browser.satisfies({chrome: '>118.01.1322' }))
   * // or with os
   * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
   * // or with platforms
   * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
   */
  satisfies(t) {
    const r = {};
    let n = 0;
    const s = {};
    let i = 0;
    if (Object.keys(t).forEach((a) => {
      const c = t[a];
      typeof c == "string" ? (s[a] = c, i += 1) : typeof c == "object" && (r[a] = c, n += 1);
    }), n > 0) {
      const a = Object.keys(r), c = w.find(a, (l) => this.isOS(l));
      if (c) {
        const l = this.satisfies(r[c]);
        if (l !== void 0)
          return l;
      }
      const u = w.find(
        a,
        (l) => this.isPlatform(l)
      );
      if (u) {
        const l = this.satisfies(r[u]);
        if (l !== void 0)
          return l;
      }
    }
    if (i > 0) {
      const a = Object.keys(s), c = w.find(a, (u) => this.isBrowser(u, !0));
      if (c !== void 0)
        return this.compareVersion(s[c]);
    }
  }
  /**
   * Check if the browser name equals the passed string
   * @param browserName The string to compare with the browser name
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {boolean}
   */
  isBrowser(t, r = !1) {
    const n = this.getBrowserName().toLowerCase();
    let s = t.toLowerCase();
    const i = w.getBrowserTypeByAlias(s);
    return r && i && (s = i.toLowerCase()), s === n;
  }
  compareVersion(t) {
    let r = [0], n = t, s = !1;
    const i = this.getBrowserVersion();
    if (typeof i == "string")
      return t[0] === ">" || t[0] === "<" ? (n = t.substr(1), t[1] === "=" ? (s = !0, n = t.substr(2)) : r = [], t[0] === ">" ? r.push(1) : r.push(-1)) : t[0] === "=" ? n = t.substr(1) : t[0] === "~" && (s = !0, n = t.substr(1)), r.indexOf(
        w.compareVersions(i, n, s)
      ) > -1;
  }
  isOS(t) {
    return this.getOSName(!0) === String(t).toLowerCase();
  }
  isPlatform(t) {
    return this.getPlatformType(!0) === String(t).toLowerCase();
  }
  isEngine(t) {
    return this.getEngineName(!0) === String(t).toLowerCase();
  }
  /**
   * Is anything? Check if the browser is called "anything",
   * the OS called "anything" or the platform called "anything"
   * @param {String} anything
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {Boolean}
   */
  is(t, r = !1) {
    return this.isBrowser(t, r) || this.isOS(t) || this.isPlatform(t);
  }
  /**
   * Check if any of the given values satisfies this.is(anything)
   * @param {String[]} anythings
   * @returns {Boolean}
   */
  some(t = []) {
    return t.some((r) => this.is(r));
  }
}
/*!
 * Bowser - a browser detector
 * https://github.com/lancedikson/bowser
 * MIT License | (c) Dustin Diaz 2012-2015
 * MIT License | (c) Denis Demchenko 2015-2019
 */
class gc {
  /**
   * Creates a {@link Parser} instance
   *
   * @param {String} UA UserAgent string
   * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it
   * explicitly. Same as `skipParsing` for {@link Parser}.
   * @returns {Parser}
   * @throws {Error} when UA is not a String
   *
   * @example
   * const parser = Bowser.getParser(window.navigator.userAgent);
   * const result = parser.getResult();
   */
  static getParser(t, r = !1) {
    if (typeof t != "string")
      throw new Error("UserAgent should be a string");
    return new Bi(t, r);
  }
  /**
   * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately
   *
   * @param UA
   * @return {ParsedResult}
   *
   * @example
   * const result = Bowser.parse(window.navigator.userAgent);
   */
  static parse(t) {
    return new Bi(t).getResult();
  }
  static get BROWSER_MAP() {
    return pc;
  }
  static get ENGINE_MAP() {
    return $e;
  }
  static get OS_MAP() {
    return ue;
  }
  static get PLATFORMS_MAP() {
    return j;
  }
}
const D0 = ({ serviceId: e, clientVersion: t }) => async () => {
  var s, i, o, a, c;
  const r = typeof window < "u" && ((s = window == null ? void 0 : window.navigator) != null && s.userAgent) ? gc.parse(window.navigator.userAgent) : void 0, n = [
    ["aws-sdk-js", t],
    ["ua", "2.0"],
    [`os/${((i = r == null ? void 0 : r.os) == null ? void 0 : i.name) || "other"}`, (o = r == null ? void 0 : r.os) == null ? void 0 : o.version],
    ["lang/js"],
    ["md/browser", `${((a = r == null ? void 0 : r.browser) == null ? void 0 : a.name) ?? "unknown"}_${((c = r == null ? void 0 : r.browser) == null ? void 0 : c.version) ?? "unknown"}`]
  ];
  return e && n.push([`api/${e}`, t]), n;
};
var Fr = {}, Tt = {}, ki;
function U0() {
  if (ki)
    return Tt;
  ki = 1, Object.defineProperty(Tt, "__esModule", { value: !0 }), Tt.AwsCrc32 = void 0;
  var e = _e, t = We(), r = mc(), n = (
    /** @class */
    function() {
      function s() {
        this.crc32 = new r.Crc32();
      }
      return s.prototype.update = function(i) {
        (0, t.isEmptyData)(i) || this.crc32.update((0, t.convertToBuffer)(i));
      }, s.prototype.digest = function() {
        return e.__awaiter(this, void 0, void 0, function() {
          return e.__generator(this, function(i) {
            return [2, (0, t.numToUint8)(this.crc32.digest())];
          });
        });
      }, s.prototype.reset = function() {
        this.crc32 = new r.Crc32();
      }, s;
    }()
  );
  return Tt.AwsCrc32 = n, Tt;
}
var Ni;
function mc() {
  return Ni || (Ni = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.AwsCrc32 = e.Crc32 = e.crc32 = void 0;
    var t = _e, r = We();
    function n(c) {
      return new s().update(c).digest();
    }
    e.crc32 = n;
    var s = (
      /** @class */
      function() {
        function c() {
          this.checksum = 4294967295;
        }
        return c.prototype.update = function(u) {
          var l, h;
          try {
            for (var p = t.__values(u), g = p.next(); !g.done; g = p.next()) {
              var b = g.value;
              this.checksum = this.checksum >>> 8 ^ o[(this.checksum ^ b) & 255];
            }
          } catch (A) {
            l = { error: A };
          } finally {
            try {
              g && !g.done && (h = p.return) && h.call(p);
            } finally {
              if (l)
                throw l.error;
            }
          }
          return this;
        }, c.prototype.digest = function() {
          return (this.checksum ^ 4294967295) >>> 0;
        }, c;
      }()
    );
    e.Crc32 = s;
    var i = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ], o = (0, r.uint32ArrayFrom)(i), a = U0();
    Object.defineProperty(e, "AwsCrc32", { enumerable: !0, get: function() {
      return a.AwsCrc32;
    } });
  }(Fr)), Fr;
}
var Jn = mc();
class It {
  constructor(t) {
    if (this.bytes = t, t.byteLength !== 8)
      throw new Error("Int64 buffers must be exactly 8 bytes");
  }
  static fromNumber(t) {
    if (t > 9223372036854776e3 || t < -9223372036854776e3)
      throw new Error(`${t} is too large (or, if negative, too small) to represent as an Int64`);
    const r = new Uint8Array(8);
    for (let n = 7, s = Math.abs(Math.round(t)); n > -1 && s > 0; n--, s /= 256)
      r[n] = s;
    return t < 0 && Pi(r), new It(r);
  }
  valueOf() {
    const t = this.bytes.slice(0), r = t[0] & 128;
    return r && Pi(t), parseInt(he(t), 16) * (r ? -1 : 1);
  }
  toString() {
    return String(this.valueOf());
  }
}
function Pi(e) {
  for (let t = 0; t < 8; t++)
    e[t] ^= 255;
  for (let t = 7; t > -1 && (e[t]++, e[t] === 0); t--)
    ;
}
class $0 {
  constructor(t, r) {
    this.toUtf8 = t, this.fromUtf8 = r;
  }
  format(t) {
    const r = [];
    for (const i of Object.keys(t)) {
      const o = this.fromUtf8(i);
      r.push(Uint8Array.from([o.byteLength]), o, this.formatHeaderValue(t[i]));
    }
    const n = new Uint8Array(r.reduce((i, o) => i + o.byteLength, 0));
    let s = 0;
    for (const i of r)
      n.set(i, s), s += i.byteLength;
    return n;
  }
  formatHeaderValue(t) {
    switch (t.type) {
      case "boolean":
        return Uint8Array.from([t.value ? 0 : 1]);
      case "byte":
        return Uint8Array.from([2, t.value]);
      case "short":
        const r = new DataView(new ArrayBuffer(3));
        return r.setUint8(0, 3), r.setInt16(1, t.value, !1), new Uint8Array(r.buffer);
      case "integer":
        const n = new DataView(new ArrayBuffer(5));
        return n.setUint8(0, 4), n.setInt32(1, t.value, !1), new Uint8Array(n.buffer);
      case "long":
        const s = new Uint8Array(9);
        return s[0] = 5, s.set(t.value.bytes, 1), s;
      case "binary":
        const i = new DataView(new ArrayBuffer(3 + t.value.byteLength));
        i.setUint8(0, 6), i.setUint16(1, t.value.byteLength, !1);
        const o = new Uint8Array(i.buffer);
        return o.set(t.value, 3), o;
      case "string":
        const a = this.fromUtf8(t.value), c = new DataView(new ArrayBuffer(3 + a.byteLength));
        c.setUint8(0, 7), c.setUint16(1, a.byteLength, !1);
        const u = new Uint8Array(c.buffer);
        return u.set(a, 3), u;
      case "timestamp":
        const l = new Uint8Array(9);
        return l[0] = 8, l.set(It.fromNumber(t.value.valueOf()).bytes, 1), l;
      case "uuid":
        if (!K0.test(t.value))
          throw new Error(`Invalid UUID received: ${t.value}`);
        const h = new Uint8Array(17);
        return h[0] = 9, h.set(zo(t.value.replace(/\-/g, "")), 1), h;
    }
  }
  parse(t) {
    const r = {};
    let n = 0;
    for (; n < t.byteLength; ) {
      const s = t.getUint8(n++), i = this.toUtf8(new Uint8Array(t.buffer, t.byteOffset + n, s));
      switch (n += s, t.getUint8(n++)) {
        case 0:
          r[i] = {
            type: Mi,
            value: !0
          };
          break;
        case 1:
          r[i] = {
            type: Mi,
            value: !1
          };
          break;
        case 2:
          r[i] = {
            type: L0,
            value: t.getInt8(n++)
          };
          break;
        case 3:
          r[i] = {
            type: H0,
            value: t.getInt16(n, !1)
          }, n += 2;
          break;
        case 4:
          r[i] = {
            type: j0,
            value: t.getInt32(n, !1)
          }, n += 4;
          break;
        case 5:
          r[i] = {
            type: z0,
            value: new It(new Uint8Array(t.buffer, t.byteOffset + n, 8))
          }, n += 8;
          break;
        case 6:
          const o = t.getUint16(n, !1);
          n += 2, r[i] = {
            type: q0,
            value: new Uint8Array(t.buffer, t.byteOffset + n, o)
          }, n += o;
          break;
        case 7:
          const a = t.getUint16(n, !1);
          n += 2, r[i] = {
            type: W0,
            value: this.toUtf8(new Uint8Array(t.buffer, t.byteOffset + n, a))
          }, n += a;
          break;
        case 8:
          r[i] = {
            type: G0,
            value: new Date(new It(new Uint8Array(t.buffer, t.byteOffset + n, 8)).valueOf())
          }, n += 8;
          break;
        case 9:
          const c = new Uint8Array(t.buffer, t.byteOffset + n, 16);
          n += 16, r[i] = {
            type: V0,
            value: `${he(c.subarray(0, 4))}-${he(c.subarray(4, 6))}-${he(c.subarray(6, 8))}-${he(c.subarray(8, 10))}-${he(c.subarray(10))}`
          };
          break;
        default:
          throw new Error("Unrecognized header type tag");
      }
    }
    return r;
  }
}
var Oi;
(function(e) {
  e[e.boolTrue = 0] = "boolTrue", e[e.boolFalse = 1] = "boolFalse", e[e.byte = 2] = "byte", e[e.short = 3] = "short", e[e.integer = 4] = "integer", e[e.long = 5] = "long", e[e.byteArray = 6] = "byteArray", e[e.string = 7] = "string", e[e.timestamp = 8] = "timestamp", e[e.uuid = 9] = "uuid";
})(Oi || (Oi = {}));
const Mi = "boolean", L0 = "byte", H0 = "short", j0 = "integer", z0 = "long", q0 = "binary", W0 = "string", G0 = "timestamp", V0 = "uuid", K0 = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/, yc = 4, Le = yc * 2, Ke = 4, X0 = Le + Ke * 2;
function Z0({ byteLength: e, byteOffset: t, buffer: r }) {
  if (e < X0)
    throw new Error("Provided message too short to accommodate event stream message overhead");
  const n = new DataView(r, t, e), s = n.getUint32(0, !1);
  if (e !== s)
    throw new Error("Reported message length does not match received message length");
  const i = n.getUint32(yc, !1), o = n.getUint32(Le, !1), a = n.getUint32(e - Ke, !1), c = new Jn.Crc32().update(new Uint8Array(r, t, Le));
  if (o !== c.digest())
    throw new Error(`The prelude checksum specified in the message (${o}) does not match the calculated CRC32 checksum (${c.digest()})`);
  if (c.update(new Uint8Array(r, t + Le, e - (Le + Ke))), a !== c.digest())
    throw new Error(`The message checksum (${c.digest()}) did not match the expected value of ${a}`);
  return {
    headers: new DataView(r, t + Le + Ke, i),
    body: new Uint8Array(r, t + Le + Ke + i, s - i - (Le + Ke + Ke))
  };
}
class Y0 {
  constructor(t, r) {
    this.headerMarshaller = new $0(t, r), this.messageBuffer = [], this.isEndOfStream = !1;
  }
  feed(t) {
    this.messageBuffer.push(this.decode(t));
  }
  endOfStream() {
    this.isEndOfStream = !0;
  }
  getMessage() {
    const t = this.messageBuffer.pop(), r = this.isEndOfStream;
    return {
      getMessage() {
        return t;
      },
      isEndOfStream() {
        return r;
      }
    };
  }
  getAvailableMessages() {
    const t = this.messageBuffer;
    this.messageBuffer = [];
    const r = this.isEndOfStream;
    return {
      getMessages() {
        return t;
      },
      isEndOfStream() {
        return r;
      }
    };
  }
  encode({ headers: t, body: r }) {
    const n = this.headerMarshaller.format(t), s = n.byteLength + r.byteLength + 16, i = new Uint8Array(s), o = new DataView(i.buffer, i.byteOffset, i.byteLength), a = new Jn.Crc32();
    return o.setUint32(0, s, !1), o.setUint32(4, n.byteLength, !1), o.setUint32(8, a.update(i.subarray(0, 8)).digest(), !1), i.set(n, 12), i.set(r, n.byteLength + 12), o.setUint32(s - 4, a.update(i.subarray(8, s - 4)).digest(), !1), i;
  }
  decode(t) {
    const { headers: r, body: n } = Z0(t);
    return { headers: this.headerMarshaller.parse(r), body: n };
  }
  formatHeaders(t) {
    return this.headerMarshaller.format(t);
  }
}
class Q0 {
  constructor(t) {
    this.options = t;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const t of this.options.inputStream)
      yield this.options.decoder.decode(t);
  }
}
class J0 {
  constructor(t) {
    this.options = t;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const t of this.options.messageStream)
      yield this.options.encoder.encode(t);
    this.options.includeEndFrame && (yield new Uint8Array(0));
  }
}
class em {
  constructor(t) {
    this.options = t;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const t of this.options.messageStream) {
      const r = await this.options.deserializer(t);
      r !== void 0 && (yield r);
    }
  }
}
class tm {
  constructor(t) {
    this.options = t;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const t of this.options.inputStream)
      yield this.options.serializer(t);
  }
}
function rm(e) {
  let t = 0, r = 0, n = null, s = null;
  const i = (a) => {
    if (typeof a != "number")
      throw new Error("Attempted to allocate an event message where size was not a number: " + a);
    t = a, r = 4, n = new Uint8Array(a), new DataView(n.buffer).setUint32(0, a, !1);
  }, o = async function* () {
    const a = e[Symbol.asyncIterator]();
    for (; ; ) {
      const { value: c, done: u } = await a.next();
      if (u) {
        if (t)
          if (t === r)
            yield n;
          else
            throw new Error("Truncated event message received.");
        else
          return;
        return;
      }
      const l = c.length;
      let h = 0;
      for (; h < l; ) {
        if (!n) {
          const g = l - h;
          s || (s = new Uint8Array(4));
          const b = Math.min(4 - r, g);
          if (s.set(c.slice(h, h + b), r), r += b, h += b, r < 4)
            break;
          i(new DataView(s.buffer).getUint32(0, !1)), s = null;
        }
        const p = Math.min(t - r, l - h);
        n.set(c.slice(h, h + p), r), r += p, h += p, t && t === r && (yield n, n = null, t = 0, r = 0);
      }
    }
  };
  return {
    [Symbol.asyncIterator]: o
  };
}
function nm(e, t) {
  return async function(r) {
    const { value: n } = r.headers[":message-type"];
    if (n === "error") {
      const s = new Error(r.headers[":error-message"].value || "UnknownError");
      throw s.name = r.headers[":error-code"].value, s;
    } else if (n === "exception") {
      const s = r.headers[":exception-type"].value, i = { [s]: r }, o = await e(i);
      if (o.$unknown) {
        const a = new Error(t(r.body));
        throw a.name = s, a;
      }
      throw o[s];
    } else if (n === "event") {
      const s = {
        [r.headers[":event-type"].value]: r
      }, i = await e(s);
      return i.$unknown ? void 0 : i;
    } else
      throw Error(`Unrecognizable event type: ${r.headers[":event-type"].value}`);
  };
}
let sm = class {
  constructor({ utf8Encoder: t, utf8Decoder: r }) {
    this.eventStreamCodec = new Y0(t, r), this.utfEncoder = t;
  }
  deserialize(t, r) {
    const n = rm(t);
    return new em({
      messageStream: new Q0({ inputStream: n, decoder: this.eventStreamCodec }),
      deserializer: nm(r, this.utfEncoder)
    });
  }
  serialize(t, r) {
    return new J0({
      messageStream: new tm({ inputStream: t, serializer: r }),
      encoder: this.eventStreamCodec,
      includeEndFrame: !0
    });
  }
};
const im = (e) => ({
  [Symbol.asyncIterator]: async function* () {
    const t = e.getReader();
    try {
      for (; ; ) {
        const { done: r, value: n } = await t.read();
        if (r)
          return;
        yield n;
      }
    } finally {
      t.releaseLock();
    }
  }
}), om = (e) => {
  const t = e[Symbol.asyncIterator]();
  return new ReadableStream({
    async pull(r) {
      const { done: n, value: s } = await t.next();
      if (n)
        return r.close();
      r.enqueue(s);
    }
  });
};
class am {
  constructor({ utf8Encoder: t, utf8Decoder: r }) {
    this.universalMarshaller = new sm({
      utf8Decoder: r,
      utf8Encoder: t
    });
  }
  deserialize(t, r) {
    const n = cm(t) ? im(t) : t;
    return this.universalMarshaller.deserialize(n, r);
  }
  serialize(t, r) {
    const n = this.universalMarshaller.serialize(t, r);
    return typeof ReadableStream == "function" ? om(n) : n;
  }
}
const cm = (e) => typeof ReadableStream == "function" && e instanceof ReadableStream, um = (e) => new am(e);
function dm(e, t, r = 1024 * 1024) {
  return new Promise((n, s) => {
    const i = new FileReader();
    i.addEventListener("error", s), i.addEventListener("abort", s);
    const o = e.size;
    let a = 0;
    function c() {
      if (a >= o) {
        n();
        return;
      }
      i.readAsArrayBuffer(e.slice(a, Math.min(o, a + r)));
    }
    i.addEventListener("load", (u) => {
      const l = u.target.result;
      t(new Uint8Array(l)), a += l.byteLength, c();
    }), c();
  });
}
const lm = async function(t, r) {
  const n = new t();
  return await dm(r, (s) => {
    n.update(s);
  }), n.digest();
}, fm = (e) => () => Promise.reject(e), Fe = 64, hm = 16, pm = [1732584193, 4023233417, 2562383102, 271733878];
class gm {
  constructor() {
    this.reset();
  }
  update(t) {
    if (mm(t))
      return;
    if (this.finished)
      throw new Error("Attempted to update an already finished hash.");
    const r = ym(t);
    let n = 0, { byteLength: s } = r;
    for (this.bytesHashed += s; s > 0; )
      this.buffer.setUint8(this.bufferLength++, r[n++]), s--, this.bufferLength === Fe && (this.hashBuffer(), this.bufferLength = 0);
  }
  async digest() {
    if (!this.finished) {
      const { buffer: r, bufferLength: n, bytesHashed: s } = this, i = s * 8;
      if (r.setUint8(this.bufferLength++, 128), n % Fe >= Fe - 8) {
        for (let o = this.bufferLength; o < Fe; o++)
          r.setUint8(o, 0);
        this.hashBuffer(), this.bufferLength = 0;
      }
      for (let o = this.bufferLength; o < Fe - 8; o++)
        r.setUint8(o, 0);
      r.setUint32(Fe - 8, i >>> 0, !0), r.setUint32(Fe - 4, Math.floor(i / 4294967296), !0), this.hashBuffer(), this.finished = !0;
    }
    const t = new DataView(new ArrayBuffer(hm));
    for (let r = 0; r < 4; r++)
      t.setUint32(r * 4, this.state[r], !0);
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  }
  hashBuffer() {
    const { buffer: t, state: r } = this;
    let n = r[0], s = r[1], i = r[2], o = r[3];
    n = ne(n, s, i, o, t.getUint32(0, !0), 7, 3614090360), o = ne(o, n, s, i, t.getUint32(4, !0), 12, 3905402710), i = ne(i, o, n, s, t.getUint32(8, !0), 17, 606105819), s = ne(s, i, o, n, t.getUint32(12, !0), 22, 3250441966), n = ne(n, s, i, o, t.getUint32(16, !0), 7, 4118548399), o = ne(o, n, s, i, t.getUint32(20, !0), 12, 1200080426), i = ne(i, o, n, s, t.getUint32(24, !0), 17, 2821735955), s = ne(s, i, o, n, t.getUint32(28, !0), 22, 4249261313), n = ne(n, s, i, o, t.getUint32(32, !0), 7, 1770035416), o = ne(o, n, s, i, t.getUint32(36, !0), 12, 2336552879), i = ne(i, o, n, s, t.getUint32(40, !0), 17, 4294925233), s = ne(s, i, o, n, t.getUint32(44, !0), 22, 2304563134), n = ne(n, s, i, o, t.getUint32(48, !0), 7, 1804603682), o = ne(o, n, s, i, t.getUint32(52, !0), 12, 4254626195), i = ne(i, o, n, s, t.getUint32(56, !0), 17, 2792965006), s = ne(s, i, o, n, t.getUint32(60, !0), 22, 1236535329), n = se(n, s, i, o, t.getUint32(4, !0), 5, 4129170786), o = se(o, n, s, i, t.getUint32(24, !0), 9, 3225465664), i = se(i, o, n, s, t.getUint32(44, !0), 14, 643717713), s = se(s, i, o, n, t.getUint32(0, !0), 20, 3921069994), n = se(n, s, i, o, t.getUint32(20, !0), 5, 3593408605), o = se(o, n, s, i, t.getUint32(40, !0), 9, 38016083), i = se(i, o, n, s, t.getUint32(60, !0), 14, 3634488961), s = se(s, i, o, n, t.getUint32(16, !0), 20, 3889429448), n = se(n, s, i, o, t.getUint32(36, !0), 5, 568446438), o = se(o, n, s, i, t.getUint32(56, !0), 9, 3275163606), i = se(i, o, n, s, t.getUint32(12, !0), 14, 4107603335), s = se(s, i, o, n, t.getUint32(32, !0), 20, 1163531501), n = se(n, s, i, o, t.getUint32(52, !0), 5, 2850285829), o = se(o, n, s, i, t.getUint32(8, !0), 9, 4243563512), i = se(i, o, n, s, t.getUint32(28, !0), 14, 1735328473), s = se(s, i, o, n, t.getUint32(48, !0), 20, 2368359562), n = ie(n, s, i, o, t.getUint32(20, !0), 4, 4294588738), o = ie(o, n, s, i, t.getUint32(32, !0), 11, 2272392833), i = ie(i, o, n, s, t.getUint32(44, !0), 16, 1839030562), s = ie(s, i, o, n, t.getUint32(56, !0), 23, 4259657740), n = ie(n, s, i, o, t.getUint32(4, !0), 4, 2763975236), o = ie(o, n, s, i, t.getUint32(16, !0), 11, 1272893353), i = ie(i, o, n, s, t.getUint32(28, !0), 16, 4139469664), s = ie(s, i, o, n, t.getUint32(40, !0), 23, 3200236656), n = ie(n, s, i, o, t.getUint32(52, !0), 4, 681279174), o = ie(o, n, s, i, t.getUint32(0, !0), 11, 3936430074), i = ie(i, o, n, s, t.getUint32(12, !0), 16, 3572445317), s = ie(s, i, o, n, t.getUint32(24, !0), 23, 76029189), n = ie(n, s, i, o, t.getUint32(36, !0), 4, 3654602809), o = ie(o, n, s, i, t.getUint32(48, !0), 11, 3873151461), i = ie(i, o, n, s, t.getUint32(60, !0), 16, 530742520), s = ie(s, i, o, n, t.getUint32(8, !0), 23, 3299628645), n = oe(n, s, i, o, t.getUint32(0, !0), 6, 4096336452), o = oe(o, n, s, i, t.getUint32(28, !0), 10, 1126891415), i = oe(i, o, n, s, t.getUint32(56, !0), 15, 2878612391), s = oe(s, i, o, n, t.getUint32(20, !0), 21, 4237533241), n = oe(n, s, i, o, t.getUint32(48, !0), 6, 1700485571), o = oe(o, n, s, i, t.getUint32(12, !0), 10, 2399980690), i = oe(i, o, n, s, t.getUint32(40, !0), 15, 4293915773), s = oe(s, i, o, n, t.getUint32(4, !0), 21, 2240044497), n = oe(n, s, i, o, t.getUint32(32, !0), 6, 1873313359), o = oe(o, n, s, i, t.getUint32(60, !0), 10, 4264355552), i = oe(i, o, n, s, t.getUint32(24, !0), 15, 2734768916), s = oe(s, i, o, n, t.getUint32(52, !0), 21, 1309151649), n = oe(n, s, i, o, t.getUint32(16, !0), 6, 4149444226), o = oe(o, n, s, i, t.getUint32(44, !0), 10, 3174756917), i = oe(i, o, n, s, t.getUint32(8, !0), 15, 718787259), s = oe(s, i, o, n, t.getUint32(36, !0), 21, 3951481745), r[0] = n + r[0] & 4294967295, r[1] = s + r[1] & 4294967295, r[2] = i + r[2] & 4294967295, r[3] = o + r[3] & 4294967295;
  }
  reset() {
    this.state = Uint32Array.from(pm), this.buffer = new DataView(new ArrayBuffer(Fe)), this.bufferLength = 0, this.bytesHashed = 0, this.finished = !1;
  }
}
function lr(e, t, r, n, s, i) {
  return t = (t + e & 4294967295) + (n + i & 4294967295) & 4294967295, (t << s | t >>> 32 - s) + r & 4294967295;
}
function ne(e, t, r, n, s, i, o) {
  return lr(t & r | ~t & n, e, t, s, i, o);
}
function se(e, t, r, n, s, i, o) {
  return lr(t & n | r & ~n, e, t, s, i, o);
}
function ie(e, t, r, n, s, i, o) {
  return lr(t ^ r ^ n, e, t, s, i, o);
}
function oe(e, t, r, n, s, i, o) {
  return lr(r ^ (t | ~n), e, t, s, i, o);
}
function mm(e) {
  return typeof e == "string" ? e.length === 0 : e.byteLength === 0;
}
function ym(e) {
  return typeof e == "string" ? Qe(e) : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(e);
}
const Ii = typeof TextEncoder == "function" ? new TextEncoder() : null, bm = (e) => {
  if (typeof e == "string") {
    if (Ii)
      return Ii.encode(e).byteLength;
    let t = e.length;
    for (let r = t - 1; r >= 0; r--) {
      const n = e.charCodeAt(r);
      n > 127 && n <= 2047 ? t++ : n > 2047 && n <= 65535 && (t += 2), n >= 56320 && n <= 57343 && r--;
    }
    return t;
  } else {
    if (typeof e.byteLength == "number")
      return e.byteLength;
    if (typeof e.size == "number")
      return e.size;
  }
  throw new Error(`Body Length computation failed for ${e}`);
}, wm = {
  CrtSignerV4: null
};
class xm {
  constructor(t) {
    this.sigv4Signer = new Hd(t), this.signerOptions = t;
  }
  async sign(t, r = {}) {
    if (r.signingRegion === "*") {
      if (this.signerOptions.runtime !== "node")
        throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
      return this.getSigv4aSigner().sign(t, r);
    }
    return this.sigv4Signer.sign(t, r);
  }
  async signWithCredentials(t, r, n = {}) {
    if (n.signingRegion === "*") {
      if (this.signerOptions.runtime !== "node")
        throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
      return this.getSigv4aSigner().signWithCredentials(t, r, n);
    }
    return this.sigv4Signer.signWithCredentials(t, r, n);
  }
  async presign(t, r = {}) {
    if (r.signingRegion === "*") {
      if (this.signerOptions.runtime !== "node")
        throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
      return this.getSigv4aSigner().presign(t, r);
    }
    return this.sigv4Signer.presign(t, r);
  }
  async presignWithCredentials(t, r, n = {}) {
    if (n.signingRegion === "*")
      throw new Error("Method presignWithCredentials is not supported for [signingRegion=*].");
    return this.sigv4Signer.presignWithCredentials(t, r, n);
  }
  getSigv4aSigner() {
    if (!this.sigv4aSigner) {
      let t = null;
      try {
        if (t = wm.CrtSignerV4, typeof t != "function")
          throw new Error();
      } catch (r) {
        throw r.message = `${r.message}
Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. 
You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. 
For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`, r;
      }
      this.sigv4aSigner = new t({
        ...this.signerOptions,
        signingAlgorithm: 1
      });
    }
    return this.sigv4aSigner;
  }
}
const es = "required", d = "type", f = "conditions", m = "fn", y = "argv", B = "ref", H = "assign", S = "url", C = "properties", bc = "backend", Te = "authSchemes", be = "disableDoubleEncoding", we = "signingName", Pe = "signingRegion", v = "headers", ts = "signingRegionSet", Em = !1, Se = !0, xe = "isSet", te = "booleanEquals", _ = "error", rr = "aws.partition", L = "stringEquals", z = "getAttr", ce = "name", Be = "substring", Fi = "bucketSuffix", wc = "parseURL", Di = "{url#scheme}://{url#authority}/{uri_encoded_bucket}{url#path}", E = "endpoint", x = "tree", xc = "aws.isVirtualHostableS3Bucket", Kt = "{url#scheme}://{Bucket}.{url#authority}{url#path}", ke = "not", Xt = "{url#scheme}://{url#authority}{url#path}", Ec = "hardwareType", Ac = "regionPrefix", Ui = "bucketAliasSuffix", Cn = "outpostId", Je = "isValidHostLabel", rs = "sigv4a", $t = "s3-outposts", ct = "s3", Sc = "{url#scheme}://{url#authority}{url#normalizedPath}{Bucket}", Cc = "https://{Bucket}.s3-accelerate.{partitionResult#dnsSuffix}", $i = "https://{Bucket}.s3.{partitionResult#dnsSuffix}", vc = "aws.parseArn", Rc = "bucketArn", _c = "arnType", nr = "", ns = "s3-object-lambda", Tc = "accesspoint", ss = "accessPointName", Li = "{url#scheme}://{accessPointName}-{bucketArn#accountId}.{url#authority}{url#path}", Hi = "mrapPartition", ji = "outpostType", zi = "arnPrefix", Bc = "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}", qi = "https://s3.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", Wi = "https://s3.{partitionResult#dnsSuffix}", tt = { [es]: !1, [d]: "String" }, rt = { [es]: !0, default: !1, [d]: "Boolean" }, Bt = { [es]: !1, [d]: "Boolean" }, Ce = { [m]: te, [y]: [{ [B]: "Accelerate" }, !0] }, U = { [m]: te, [y]: [{ [B]: "UseFIPS" }, !0] }, D = { [m]: te, [y]: [{ [B]: "UseDualStack" }, !0] }, W = { [m]: xe, [y]: [{ [B]: "Endpoint" }] }, kc = { [m]: rr, [y]: [{ [B]: "Region" }], [H]: "partitionResult" }, Gi = { [m]: L, [y]: [{ [m]: z, [y]: [{ [B]: "partitionResult" }, ce] }, "aws-cn"] }, sr = { [m]: xe, [y]: [{ [B]: "Bucket" }] }, le = { [B]: "Bucket" }, de = { [m]: wc, [y]: [{ [B]: "Endpoint" }], [H]: "url" }, Zt = { [m]: te, [y]: [{ [m]: z, [y]: [{ [B]: "url" }, "isIp"] }, !0] }, Nc = { [B]: "url" }, Pc = { [m]: "uriEncode", [y]: [le], [H]: "uri_encoded_bucket" }, Me = { [bc]: "S3Express", [Te]: [{ [be]: !0, [ce]: "sigv4", [we]: "s3express", [Pe]: "{Region}" }] }, k = {}, Oc = { [m]: xc, [y]: [le, !1] }, Dr = { [_]: "S3Express bucket name is not a valid virtual hostable name.", [d]: _ }, ir = { [bc]: "S3Express", [Te]: [{ [be]: !0, [ce]: "sigv4-s3express", [we]: "s3express", [Pe]: "{Region}" }] }, Vi = { [m]: xe, [y]: [{ [B]: "UseS3ExpressControlEndpoint" }] }, Ki = { [m]: te, [y]: [{ [B]: "UseS3ExpressControlEndpoint" }, !0] }, N = { [m]: ke, [y]: [W] }, Xi = { [_]: "Unrecognized S3Express bucket name format.", [d]: _ }, Zi = { [m]: ke, [y]: [sr] }, Yi = { [B]: Ec }, Qi = { [f]: [N], [_]: "Expected a endpoint to be specified but no endpoint was found", [d]: _ }, zt = { [Te]: [{ [be]: !0, [ce]: rs, [we]: $t, [ts]: ["*"] }, { [be]: !0, [ce]: "sigv4", [we]: $t, [Pe]: "{Region}" }] }, Ur = { [m]: te, [y]: [{ [B]: "ForcePathStyle" }, !1] }, Am = { [B]: "ForcePathStyle" }, q = { [m]: te, [y]: [{ [B]: "Accelerate" }, !1] }, K = { [m]: L, [y]: [{ [B]: "Region" }, "aws-global"] }, Y = { [Te]: [{ [be]: !0, [ce]: "sigv4", [we]: ct, [Pe]: "us-east-1" }] }, M = { [m]: ke, [y]: [K] }, Q = { [m]: te, [y]: [{ [B]: "UseGlobalEndpoint" }, !0] }, Ji = { [S]: "https://{Bucket}.s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [C]: { [Te]: [{ [be]: !0, [ce]: "sigv4", [we]: ct, [Pe]: "{Region}" }] }, [v]: {} }, V = { [Te]: [{ [be]: !0, [ce]: "sigv4", [we]: ct, [Pe]: "{Region}" }] }, J = { [m]: te, [y]: [{ [B]: "UseGlobalEndpoint" }, !1] }, O = { [m]: te, [y]: [{ [B]: "UseDualStack" }, !1] }, eo = { [S]: "https://{Bucket}.s3-fips.{Region}.{partitionResult#dnsSuffix}", [C]: V, [v]: {} }, P = { [m]: te, [y]: [{ [B]: "UseFIPS" }, !1] }, to = { [S]: "https://{Bucket}.s3-accelerate.dualstack.{partitionResult#dnsSuffix}", [C]: V, [v]: {} }, ro = { [S]: "https://{Bucket}.s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [C]: V, [v]: {} }, $r = { [m]: te, [y]: [{ [m]: z, [y]: [Nc, "isIp"] }, !1] }, Lr = { [S]: Sc, [C]: V, [v]: {} }, vn = { [S]: Kt, [C]: V, [v]: {} }, no = { [E]: vn, [d]: E }, Hr = { [S]: Cc, [C]: V, [v]: {} }, so = { [S]: "https://{Bucket}.s3.{Region}.{partitionResult#dnsSuffix}", [C]: V, [v]: {} }, qt = { [_]: "Invalid region: region was not a valid DNS name.", [d]: _ }, pe = { [B]: Rc }, Mc = { [B]: _c }, jr = { [m]: z, [y]: [pe, "service"] }, is = { [B]: ss }, io = { [f]: [D], [_]: "S3 Object Lambda does not support Dual-stack", [d]: _ }, oo = { [f]: [Ce], [_]: "S3 Object Lambda does not support S3 Accelerate", [d]: _ }, ao = { [f]: [{ [m]: xe, [y]: [{ [B]: "DisableAccessPoints" }] }, { [m]: te, [y]: [{ [B]: "DisableAccessPoints" }, !0] }], [_]: "Access points are not supported for this operation", [d]: _ }, zr = { [f]: [{ [m]: xe, [y]: [{ [B]: "UseArnRegion" }] }, { [m]: te, [y]: [{ [B]: "UseArnRegion" }, !1] }, { [m]: ke, [y]: [{ [m]: L, [y]: [{ [m]: z, [y]: [pe, "region"] }, "{Region}"] }] }], [_]: "Invalid configuration: region from ARN `{bucketArn#region}` does not match client region `{Region}` and UseArnRegion is `false`", [d]: _ }, Ic = { [m]: z, [y]: [{ [B]: "bucketPartition" }, ce] }, Fc = { [m]: z, [y]: [pe, "accountId"] }, qr = { [Te]: [{ [be]: !0, [ce]: "sigv4", [we]: ns, [Pe]: "{bucketArn#region}" }] }, co = { [_]: "Invalid ARN: The access point name may only contain a-z, A-Z, 0-9 and `-`. Found: `{accessPointName}`", [d]: _ }, Wr = { [_]: "Invalid ARN: The account id may only contain a-z, A-Z, 0-9 and `-`. Found: `{bucketArn#accountId}`", [d]: _ }, Gr = { [_]: "Invalid region in ARN: `{bucketArn#region}` (invalid DNS name)", [d]: _ }, Vr = { [_]: "Client was configured for partition `{partitionResult#name}` but ARN (`{Bucket}`) has `{bucketPartition#name}`", [d]: _ }, uo = { [_]: "Invalid ARN: The ARN may only contain a single resource component after `accesspoint`.", [d]: _ }, lo = { [_]: "Invalid ARN: Expected a resource of the format `accesspoint:<accesspoint name>` but no name was provided", [d]: _ }, kt = { [Te]: [{ [be]: !0, [ce]: "sigv4", [we]: ct, [Pe]: "{bucketArn#region}" }] }, fo = { [Te]: [{ [be]: !0, [ce]: rs, [we]: $t, [ts]: ["*"] }, { [be]: !0, [ce]: "sigv4", [we]: $t, [Pe]: "{bucketArn#region}" }] }, ho = { [m]: vc, [y]: [le] }, po = { [S]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [C]: V, [v]: {} }, go = { [S]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [C]: V, [v]: {} }, mo = { [S]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [C]: V, [v]: {} }, Kr = { [S]: Bc, [C]: V, [v]: {} }, yo = { [S]: "https://s3.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [C]: V, [v]: {} }, bo = { [B]: "UseObjectLambdaEndpoint" }, Xr = { [Te]: [{ [be]: !0, [ce]: "sigv4", [we]: ns, [Pe]: "{Region}" }] }, wo = { [S]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [C]: V, [v]: {} }, xo = { [S]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}", [C]: V, [v]: {} }, Eo = { [S]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [C]: V, [v]: {} }, Zr = { [S]: Xt, [C]: V, [v]: {} }, Ao = { [S]: "https://s3.{Region}.{partitionResult#dnsSuffix}", [C]: V, [v]: {} }, Yr = [{ [B]: "Region" }], Sm = [{ [B]: "Endpoint" }], Cm = [le], Qr = [D], Wt = [Ce], Ve = [W, de], So = [{ [m]: xe, [y]: [{ [B]: "DisableS3ExpressSessionAuth" }] }, { [m]: te, [y]: [{ [B]: "DisableS3ExpressSessionAuth" }, !0] }], Co = [Zt], Jr = [Pc], en = [Oc], nt = [U], vo = [{ [m]: Be, [y]: [le, 6, 14, !0], [H]: "s3expressAvailabilityZoneId" }, { [m]: Be, [y]: [le, 14, 16, !0], [H]: "s3expressAvailabilityZoneDelim" }, { [m]: L, [y]: [{ [B]: "s3expressAvailabilityZoneDelim" }, "--"] }], Ro = [{ [f]: [U], [E]: { [S]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [C]: Me, [v]: {} }, [d]: E }, { [E]: { [S]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [C]: Me, [v]: {} }, [d]: E }], _o = [{ [m]: Be, [y]: [le, 6, 15, !0], [H]: "s3expressAvailabilityZoneId" }, { [m]: Be, [y]: [le, 15, 17, !0], [H]: "s3expressAvailabilityZoneDelim" }, { [m]: L, [y]: [{ [B]: "s3expressAvailabilityZoneDelim" }, "--"] }], To = [{ [f]: [U], [E]: { [S]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [C]: ir, [v]: {} }, [d]: E }, { [E]: { [S]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [C]: ir, [v]: {} }, [d]: E }], vm = [sr], Bo = [{ [m]: Je, [y]: [{ [B]: Cn }, !1] }], ko = [{ [m]: L, [y]: [{ [B]: Ac }, "beta"] }], Rm = ["*"], De = [kc], No = [{ [m]: Je, [y]: [{ [B]: "Region" }, !1] }], Ue = [{ [m]: L, [y]: [{ [B]: "Region" }, "us-east-1"] }], tn = [{ [m]: L, [y]: [Mc, Tc] }], Po = [{ [m]: z, [y]: [pe, "resourceId[1]"], [H]: ss }, { [m]: ke, [y]: [{ [m]: L, [y]: [is, nr] }] }], _m = [pe, "resourceId[1]"], rn = [{ [m]: ke, [y]: [{ [m]: L, [y]: [{ [m]: z, [y]: [pe, "region"] }, nr] }] }], Oo = [{ [m]: ke, [y]: [{ [m]: xe, [y]: [{ [m]: z, [y]: [pe, "resourceId[2]"] }] }] }], Tm = [pe, "resourceId[2]"], nn = [{ [m]: rr, [y]: [{ [m]: z, [y]: [pe, "region"] }], [H]: "bucketPartition" }], Mo = [{ [m]: L, [y]: [Ic, { [m]: z, [y]: [{ [B]: "partitionResult" }, ce] }] }], sn = [{ [m]: Je, [y]: [{ [m]: z, [y]: [pe, "region"] }, !0] }], on = [{ [m]: Je, [y]: [Fc, !1] }], Io = [{ [m]: Je, [y]: [is, !1] }], Fo = [{ [m]: Je, [y]: [{ [B]: "Region" }, !0] }], Bm = { version: "1.0", parameters: { Bucket: tt, Region: tt, UseFIPS: rt, UseDualStack: rt, Endpoint: tt, ForcePathStyle: rt, Accelerate: rt, UseGlobalEndpoint: rt, UseObjectLambdaEndpoint: Bt, Key: tt, Prefix: tt, CopySource: tt, DisableAccessPoints: Bt, DisableMultiRegionAccessPoints: rt, UseArnRegion: Bt, UseS3ExpressControlEndpoint: Bt, DisableS3ExpressSessionAuth: Bt }, rules: [{ [f]: [{ [m]: xe, [y]: Yr }], rules: [{ [f]: [Ce, U], error: "Accelerate cannot be used with FIPS", [d]: _ }, { [f]: [D, W], error: "Cannot set dual-stack in combination with a custom endpoint.", [d]: _ }, { [f]: [W, U], error: "A custom endpoint cannot be combined with FIPS", [d]: _ }, { [f]: [W, Ce], error: "A custom endpoint cannot be combined with S3 Accelerate", [d]: _ }, { [f]: [U, kc, Gi], error: "Partition does not support FIPS", [d]: _ }, { [f]: [sr, { [m]: Be, [y]: [le, 0, 6, Se], [H]: Fi }, { [m]: L, [y]: [{ [B]: Fi }, "--x-s3"] }], rules: [{ [f]: Qr, error: "S3Express does not support Dual-stack.", [d]: _ }, { [f]: Wt, error: "S3Express does not support S3 Accelerate.", [d]: _ }, { [f]: Ve, rules: [{ [f]: So, rules: [{ [f]: Co, rules: [{ [f]: Jr, rules: [{ endpoint: { [S]: Di, [C]: Me, [v]: k }, [d]: E }], [d]: x }], [d]: x }, { [f]: en, rules: [{ endpoint: { [S]: Kt, [C]: Me, [v]: k }, [d]: E }], [d]: x }, Dr], [d]: x }, { [f]: Co, rules: [{ [f]: Jr, rules: [{ endpoint: { [S]: Di, [C]: ir, [v]: k }, [d]: E }], [d]: x }], [d]: x }, { [f]: en, rules: [{ endpoint: { [S]: Kt, [C]: ir, [v]: k }, [d]: E }], [d]: x }, Dr], [d]: x }, { [f]: [Vi, Ki], rules: [{ [f]: [Pc, N], rules: [{ [f]: nt, endpoint: { [S]: "https://s3express-control-fips.{Region}.amazonaws.com/{uri_encoded_bucket}", [C]: Me, [v]: k }, [d]: E }, { endpoint: { [S]: "https://s3express-control.{Region}.amazonaws.com/{uri_encoded_bucket}", [C]: Me, [v]: k }, [d]: E }], [d]: x }], [d]: x }, { [f]: en, rules: [{ [f]: So, rules: [{ [f]: vo, rules: Ro, [d]: x }, { [f]: _o, rules: Ro, [d]: x }, Xi], [d]: x }, { [f]: vo, rules: To, [d]: x }, { [f]: _o, rules: To, [d]: x }, Xi], [d]: x }, Dr], [d]: x }, { [f]: [Zi, Vi, Ki], rules: [{ [f]: Ve, endpoint: { [S]: Xt, [C]: Me, [v]: k }, [d]: E }, { [f]: nt, endpoint: { [S]: "https://s3express-control-fips.{Region}.amazonaws.com", [C]: Me, [v]: k }, [d]: E }, { endpoint: { [S]: "https://s3express-control.{Region}.amazonaws.com", [C]: Me, [v]: k }, [d]: E }], [d]: x }, { [f]: [sr, { [m]: Be, [y]: [le, 49, 50, Se], [H]: Ec }, { [m]: Be, [y]: [le, 8, 12, Se], [H]: Ac }, { [m]: Be, [y]: [le, 0, 7, Se], [H]: Ui }, { [m]: Be, [y]: [le, 32, 49, Se], [H]: Cn }, { [m]: rr, [y]: Yr, [H]: "regionPartition" }, { [m]: L, [y]: [{ [B]: Ui }, "--op-s3"] }], rules: [{ [f]: Bo, rules: [{ [f]: [{ [m]: L, [y]: [Yi, "e"] }], rules: [{ [f]: ko, rules: [Qi, { [f]: Ve, endpoint: { [S]: "https://{Bucket}.ec2.{url#authority}", [C]: zt, [v]: k }, [d]: E }], [d]: x }, { endpoint: { [S]: "https://{Bucket}.ec2.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [C]: zt, [v]: k }, [d]: E }], [d]: x }, { [f]: [{ [m]: L, [y]: [Yi, "o"] }], rules: [{ [f]: ko, rules: [Qi, { [f]: Ve, endpoint: { [S]: "https://{Bucket}.op-{outpostId}.{url#authority}", [C]: zt, [v]: k }, [d]: E }], [d]: x }, { endpoint: { [S]: "https://{Bucket}.op-{outpostId}.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [C]: zt, [v]: k }, [d]: E }], [d]: x }, { error: 'Unrecognized hardware type: "Expected hardware type o or e but got {hardwareType}"', [d]: _ }], [d]: x }, { error: "Invalid ARN: The outpost Id must only contain a-z, A-Z, 0-9 and `-`.", [d]: _ }], [d]: x }, { [f]: vm, rules: [{ [f]: [W, { [m]: ke, [y]: [{ [m]: xe, [y]: [{ [m]: wc, [y]: Sm }] }] }], error: "Custom endpoint `{Endpoint}` was not a valid URI", [d]: _ }, { [f]: [Ur, Oc], rules: [{ [f]: De, rules: [{ [f]: No, rules: [{ [f]: [Ce, Gi], error: "S3 Accelerate cannot be used in this region", [d]: _ }, { [f]: [D, U, q, N, K], endpoint: { [S]: "https://{Bucket}.s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [C]: Y, [v]: k }, [d]: E }, { [f]: [D, U, q, N, M, Q], rules: [{ endpoint: Ji, [d]: E }], [d]: x }, { [f]: [D, U, q, N, M, J], endpoint: Ji, [d]: E }, { [f]: [O, U, q, N, K], endpoint: { [S]: "https://{Bucket}.s3-fips.us-east-1.{partitionResult#dnsSuffix}", [C]: Y, [v]: k }, [d]: E }, { [f]: [O, U, q, N, M, Q], rules: [{ endpoint: eo, [d]: E }], [d]: x }, { [f]: [O, U, q, N, M, J], endpoint: eo, [d]: E }, { [f]: [D, P, Ce, N, K], endpoint: { [S]: "https://{Bucket}.s3-accelerate.dualstack.us-east-1.{partitionResult#dnsSuffix}", [C]: Y, [v]: k }, [d]: E }, { [f]: [D, P, Ce, N, M, Q], rules: [{ endpoint: to, [d]: E }], [d]: x }, { [f]: [D, P, Ce, N, M, J], endpoint: to, [d]: E }, { [f]: [D, P, q, N, K], endpoint: { [S]: "https://{Bucket}.s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [C]: Y, [v]: k }, [d]: E }, { [f]: [D, P, q, N, M, Q], rules: [{ endpoint: ro, [d]: E }], [d]: x }, { [f]: [D, P, q, N, M, J], endpoint: ro, [d]: E }, { [f]: [O, P, q, W, de, Zt, K], endpoint: { [S]: Sc, [C]: Y, [v]: k }, [d]: E }, { [f]: [O, P, q, W, de, $r, K], endpoint: { [S]: Kt, [C]: Y, [v]: k }, [d]: E }, { [f]: [O, P, q, W, de, Zt, M, Q], rules: [{ [f]: Ue, endpoint: Lr, [d]: E }, { endpoint: Lr, [d]: E }], [d]: x }, { [f]: [O, P, q, W, de, $r, M, Q], rules: [{ [f]: Ue, endpoint: vn, [d]: E }, no], [d]: x }, { [f]: [O, P, q, W, de, Zt, M, J], endpoint: Lr, [d]: E }, { [f]: [O, P, q, W, de, $r, M, J], endpoint: vn, [d]: E }, { [f]: [O, P, Ce, N, K], endpoint: { [S]: Cc, [C]: Y, [v]: k }, [d]: E }, { [f]: [O, P, Ce, N, M, Q], rules: [{ [f]: Ue, endpoint: Hr, [d]: E }, { endpoint: Hr, [d]: E }], [d]: x }, { [f]: [O, P, Ce, N, M, J], endpoint: Hr, [d]: E }, { [f]: [O, P, q, N, K], endpoint: { [S]: $i, [C]: Y, [v]: k }, [d]: E }, { [f]: [O, P, q, N, M, Q], rules: [{ [f]: Ue, endpoint: { [S]: $i, [C]: V, [v]: k }, [d]: E }, { endpoint: so, [d]: E }], [d]: x }, { [f]: [O, P, q, N, M, J], endpoint: so, [d]: E }], [d]: x }, qt], [d]: x }], [d]: x }, { [f]: [W, de, { [m]: L, [y]: [{ [m]: z, [y]: [Nc, "scheme"] }, "http"] }, { [m]: xc, [y]: [le, Se] }, Ur, P, O, q], rules: [{ [f]: De, rules: [{ [f]: No, rules: [no], [d]: x }, qt], [d]: x }], [d]: x }, { [f]: [Ur, { [m]: vc, [y]: Cm, [H]: Rc }], rules: [{ [f]: [{ [m]: z, [y]: [pe, "resourceId[0]"], [H]: _c }, { [m]: ke, [y]: [{ [m]: L, [y]: [Mc, nr] }] }], rules: [{ [f]: [{ [m]: L, [y]: [jr, ns] }], rules: [{ [f]: tn, rules: [{ [f]: Po, rules: [io, oo, { [f]: rn, rules: [ao, { [f]: Oo, rules: [zr, { [f]: nn, rules: [{ [f]: De, rules: [{ [f]: Mo, rules: [{ [f]: sn, rules: [{ [f]: [{ [m]: L, [y]: [Fc, nr] }], error: "Invalid ARN: Missing account id", [d]: _ }, { [f]: on, rules: [{ [f]: Io, rules: [{ [f]: Ve, endpoint: { [S]: Li, [C]: qr, [v]: k }, [d]: E }, { [f]: nt, endpoint: { [S]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [C]: qr, [v]: k }, [d]: E }, { endpoint: { [S]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda.{bucketArn#region}.{bucketPartition#dnsSuffix}", [C]: qr, [v]: k }, [d]: E }], [d]: x }, co], [d]: x }, Wr], [d]: x }, Gr], [d]: x }, Vr], [d]: x }], [d]: x }], [d]: x }, uo], [d]: x }, { error: "Invalid ARN: bucket ARN is missing a region", [d]: _ }], [d]: x }, lo], [d]: x }, { error: "Invalid ARN: Object Lambda ARNs only support `accesspoint` arn types, but found: `{arnType}`", [d]: _ }], [d]: x }, { [f]: tn, rules: [{ [f]: Po, rules: [{ [f]: rn, rules: [{ [f]: tn, rules: [{ [f]: rn, rules: [ao, { [f]: Oo, rules: [zr, { [f]: nn, rules: [{ [f]: De, rules: [{ [f]: [{ [m]: L, [y]: [Ic, "{partitionResult#name}"] }], rules: [{ [f]: sn, rules: [{ [f]: [{ [m]: L, [y]: [jr, ct] }], rules: [{ [f]: on, rules: [{ [f]: Io, rules: [{ [f]: Wt, error: "Access Points do not support S3 Accelerate", [d]: _ }, { [f]: [U, D], endpoint: { [S]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [C]: kt, [v]: k }, [d]: E }, { [f]: [U, O], endpoint: { [S]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [C]: kt, [v]: k }, [d]: E }, { [f]: [P, D], endpoint: { [S]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [C]: kt, [v]: k }, [d]: E }, { [f]: [P, O, W, de], endpoint: { [S]: Li, [C]: kt, [v]: k }, [d]: E }, { [f]: [P, O], endpoint: { [S]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.{bucketArn#region}.{bucketPartition#dnsSuffix}", [C]: kt, [v]: k }, [d]: E }], [d]: x }, co], [d]: x }, Wr], [d]: x }, { error: "Invalid ARN: The ARN was not for the S3 service, found: {bucketArn#service}", [d]: _ }], [d]: x }, Gr], [d]: x }, Vr], [d]: x }], [d]: x }], [d]: x }, uo], [d]: x }], [d]: x }], [d]: x }, { [f]: [{ [m]: Je, [y]: [is, Se] }], rules: [{ [f]: Qr, error: "S3 MRAP does not support dual-stack", [d]: _ }, { [f]: nt, error: "S3 MRAP does not support FIPS", [d]: _ }, { [f]: Wt, error: "S3 MRAP does not support S3 Accelerate", [d]: _ }, { [f]: [{ [m]: te, [y]: [{ [B]: "DisableMultiRegionAccessPoints" }, Se] }], error: "Invalid configuration: Multi-Region Access Point ARNs are disabled.", [d]: _ }, { [f]: [{ [m]: rr, [y]: Yr, [H]: Hi }], rules: [{ [f]: [{ [m]: L, [y]: [{ [m]: z, [y]: [{ [B]: Hi }, ce] }, { [m]: z, [y]: [pe, "partition"] }] }], rules: [{ endpoint: { [S]: "https://{accessPointName}.accesspoint.s3-global.{mrapPartition#dnsSuffix}", [C]: { [Te]: [{ [be]: Se, name: rs, [we]: ct, [ts]: Rm }] }, [v]: k }, [d]: E }], [d]: x }, { error: "Client was configured for partition `{mrapPartition#name}` but bucket referred to partition `{bucketArn#partition}`", [d]: _ }], [d]: x }], [d]: x }, { error: "Invalid Access Point Name", [d]: _ }], [d]: x }, lo], [d]: x }, { [f]: [{ [m]: L, [y]: [jr, $t] }], rules: [{ [f]: Qr, error: "S3 Outposts does not support Dual-stack", [d]: _ }, { [f]: nt, error: "S3 Outposts does not support FIPS", [d]: _ }, { [f]: Wt, error: "S3 Outposts does not support S3 Accelerate", [d]: _ }, { [f]: [{ [m]: xe, [y]: [{ [m]: z, [y]: [pe, "resourceId[4]"] }] }], error: "Invalid Arn: Outpost Access Point ARN contains sub resources", [d]: _ }, { [f]: [{ [m]: z, [y]: _m, [H]: Cn }], rules: [{ [f]: Bo, rules: [zr, { [f]: nn, rules: [{ [f]: De, rules: [{ [f]: Mo, rules: [{ [f]: sn, rules: [{ [f]: on, rules: [{ [f]: [{ [m]: z, [y]: Tm, [H]: ji }], rules: [{ [f]: [{ [m]: z, [y]: [pe, "resourceId[3]"], [H]: ss }], rules: [{ [f]: [{ [m]: L, [y]: [{ [B]: ji }, Tc] }], rules: [{ [f]: Ve, endpoint: { [S]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.{url#authority}", [C]: fo, [v]: k }, [d]: E }, { endpoint: { [S]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.s3-outposts.{bucketArn#region}.{bucketPartition#dnsSuffix}", [C]: fo, [v]: k }, [d]: E }], [d]: x }, { error: "Expected an outpost type `accesspoint`, found {outpostType}", [d]: _ }], [d]: x }, { error: "Invalid ARN: expected an access point name", [d]: _ }], [d]: x }, { error: "Invalid ARN: Expected a 4-component resource", [d]: _ }], [d]: x }, Wr], [d]: x }, Gr], [d]: x }, Vr], [d]: x }], [d]: x }], [d]: x }, { error: "Invalid ARN: The outpost Id may only contain a-z, A-Z, 0-9 and `-`. Found: `{outpostId}`", [d]: _ }], [d]: x }, { error: "Invalid ARN: The Outpost Id was not set", [d]: _ }], [d]: x }, { error: "Invalid ARN: Unrecognized format: {Bucket} (type: {arnType})", [d]: _ }], [d]: x }, { error: "Invalid ARN: No ARN type specified", [d]: _ }], [d]: x }, { [f]: [{ [m]: Be, [y]: [le, 0, 4, Em], [H]: zi }, { [m]: L, [y]: [{ [B]: zi }, "arn:"] }, { [m]: ke, [y]: [{ [m]: xe, [y]: [ho] }] }], error: "Invalid ARN: `{Bucket}` was not a valid ARN", [d]: _ }, { [f]: [{ [m]: te, [y]: [Am, Se] }, ho], error: "Path-style addressing cannot be used with ARN buckets", [d]: _ }, { [f]: Jr, rules: [{ [f]: De, rules: [{ [f]: [q], rules: [{ [f]: [D, N, U, K], endpoint: { [S]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [C]: Y, [v]: k }, [d]: E }, { [f]: [D, N, U, M, Q], rules: [{ endpoint: po, [d]: E }], [d]: x }, { [f]: [D, N, U, M, J], endpoint: po, [d]: E }, { [f]: [O, N, U, K], endpoint: { [S]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [C]: Y, [v]: k }, [d]: E }, { [f]: [O, N, U, M, Q], rules: [{ endpoint: go, [d]: E }], [d]: x }, { [f]: [O, N, U, M, J], endpoint: go, [d]: E }, { [f]: [D, N, P, K], endpoint: { [S]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [C]: Y, [v]: k }, [d]: E }, { [f]: [D, N, P, M, Q], rules: [{ endpoint: mo, [d]: E }], [d]: x }, { [f]: [D, N, P, M, J], endpoint: mo, [d]: E }, { [f]: [O, W, de, P, K], endpoint: { [S]: Bc, [C]: Y, [v]: k }, [d]: E }, { [f]: [O, W, de, P, M, Q], rules: [{ [f]: Ue, endpoint: Kr, [d]: E }, { endpoint: Kr, [d]: E }], [d]: x }, { [f]: [O, W, de, P, M, J], endpoint: Kr, [d]: E }, { [f]: [O, N, P, K], endpoint: { [S]: qi, [C]: Y, [v]: k }, [d]: E }, { [f]: [O, N, P, M, Q], rules: [{ [f]: Ue, endpoint: { [S]: qi, [C]: V, [v]: k }, [d]: E }, { endpoint: yo, [d]: E }], [d]: x }, { [f]: [O, N, P, M, J], endpoint: yo, [d]: E }], [d]: x }, { error: "Path-style addressing cannot be used with S3 Accelerate", [d]: _ }], [d]: x }], [d]: x }], [d]: x }, { [f]: [{ [m]: xe, [y]: [bo] }, { [m]: te, [y]: [bo, Se] }], rules: [{ [f]: De, rules: [{ [f]: Fo, rules: [io, oo, { [f]: Ve, endpoint: { [S]: Xt, [C]: Xr, [v]: k }, [d]: E }, { [f]: nt, endpoint: { [S]: "https://s3-object-lambda-fips.{Region}.{partitionResult#dnsSuffix}", [C]: Xr, [v]: k }, [d]: E }, { endpoint: { [S]: "https://s3-object-lambda.{Region}.{partitionResult#dnsSuffix}", [C]: Xr, [v]: k }, [d]: E }], [d]: x }, qt], [d]: x }], [d]: x }, { [f]: [Zi], rules: [{ [f]: De, rules: [{ [f]: Fo, rules: [{ [f]: [U, D, N, K], endpoint: { [S]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [C]: Y, [v]: k }, [d]: E }, { [f]: [U, D, N, M, Q], rules: [{ endpoint: wo, [d]: E }], [d]: x }, { [f]: [U, D, N, M, J], endpoint: wo, [d]: E }, { [f]: [U, O, N, K], endpoint: { [S]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}", [C]: Y, [v]: k }, [d]: E }, { [f]: [U, O, N, M, Q], rules: [{ endpoint: xo, [d]: E }], [d]: x }, { [f]: [U, O, N, M, J], endpoint: xo, [d]: E }, { [f]: [P, D, N, K], endpoint: { [S]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [C]: Y, [v]: k }, [d]: E }, { [f]: [P, D, N, M, Q], rules: [{ endpoint: Eo, [d]: E }], [d]: x }, { [f]: [P, D, N, M, J], endpoint: Eo, [d]: E }, { [f]: [P, O, W, de, K], endpoint: { [S]: Xt, [C]: Y, [v]: k }, [d]: E }, { [f]: [P, O, W, de, M, Q], rules: [{ [f]: Ue, endpoint: Zr, [d]: E }, { endpoint: Zr, [d]: E }], [d]: x }, { [f]: [P, O, W, de, M, J], endpoint: Zr, [d]: E }, { [f]: [P, O, N, K], endpoint: { [S]: Wi, [C]: Y, [v]: k }, [d]: E }, { [f]: [P, O, N, M, Q], rules: [{ [f]: Ue, endpoint: { [S]: Wi, [C]: V, [v]: k }, [d]: E }, { endpoint: Ao, [d]: E }], [d]: x }, { [f]: [P, O, N, M, J], endpoint: Ao, [d]: E }], [d]: x }, qt], [d]: x }], [d]: x }], [d]: x }, { error: "A region must be set when sending requests to S3.", [d]: _ }] }, km = Bm, Nm = (e, t = {}) => Cl(km, {
  endpointParams: e,
  logger: t.logger
});
er.aws = ya;
const Pm = (e) => ({
  apiVersion: "2006-03-01",
  base64Decoder: (e == null ? void 0 : e.base64Decoder) ?? Bn,
  base64Encoder: (e == null ? void 0 : e.base64Encoder) ?? Nn,
  disableHostPrefix: (e == null ? void 0 : e.disableHostPrefix) ?? !1,
  endpointProvider: (e == null ? void 0 : e.endpointProvider) ?? Nm,
  extensions: (e == null ? void 0 : e.extensions) ?? [],
  getAwsChunkedEncodingStream: (e == null ? void 0 : e.getAwsChunkedEncodingStream) ?? lu,
  logger: (e == null ? void 0 : e.logger) ?? new Tn(),
  sdkStreamMixin: (e == null ? void 0 : e.sdkStreamMixin) ?? wu,
  serviceId: (e == null ? void 0 : e.serviceId) ?? "S3",
  signerConstructor: (e == null ? void 0 : e.signerConstructor) ?? xm,
  signingEscapePath: (e == null ? void 0 : e.signingEscapePath) ?? !1,
  urlParser: (e == null ? void 0 : e.urlParser) ?? tr,
  useArnRegion: (e == null ? void 0 : e.useArnRegion) ?? !1,
  utf8Decoder: (e == null ? void 0 : e.utf8Decoder) ?? Qe,
  utf8Encoder: (e == null ? void 0 : e.utf8Encoder) ?? kn
}), Om = ["in-region", "cross-region", "mobile", "standard", "legacy"], Mm = ({ defaultsMode: e } = {}) => aa(async () => {
  const t = typeof e == "function" ? await e() : e;
  switch (t == null ? void 0 : t.toLowerCase()) {
    case "auto":
      return Promise.resolve(Im() ? "mobile" : "standard");
    case "mobile":
    case "in-region":
    case "cross-region":
    case "standard":
    case "legacy":
      return Promise.resolve(t == null ? void 0 : t.toLocaleLowerCase());
    case void 0:
      return Promise.resolve("legacy");
    default:
      throw new Error(`Invalid parameter for "defaultsMode", expect ${Om.join(", ")}, got ${t}`);
  }
}), Im = () => {
  var r, n;
  const e = typeof window < "u" && ((r = window == null ? void 0 : window.navigator) != null && r.userAgent) ? gc.parse(window.navigator.userAgent) : void 0, t = (n = e == null ? void 0 : e.platform) == null ? void 0 : n.type;
  return t === "tablet" || t === "mobile";
}, Fm = (e) => {
  const t = Mm(e), r = () => t().then(qu), n = Pm(e);
  return {
    ...n,
    ...e,
    runtime: "browser",
    defaultsMode: t,
    bodyLengthChecker: (e == null ? void 0 : e.bodyLengthChecker) ?? bm,
    credentialDefaultProvider: (e == null ? void 0 : e.credentialDefaultProvider) ?? ((s) => () => Promise.reject(new Error("Credential is missing"))),
    defaultUserAgentProvider: (e == null ? void 0 : e.defaultUserAgentProvider) ?? D0({ serviceId: n.serviceId, clientVersion: $g.version }),
    eventStreamSerdeProvider: (e == null ? void 0 : e.eventStreamSerdeProvider) ?? um,
    maxAttempts: (e == null ? void 0 : e.maxAttempts) ?? $n,
    md5: (e == null ? void 0 : e.md5) ?? gm,
    region: (e == null ? void 0 : e.region) ?? fm("Region is missing"),
    requestHandler: Pn.create((e == null ? void 0 : e.requestHandler) ?? r),
    retryMode: (e == null ? void 0 : e.retryMode) ?? (async () => (await r()).retryMode || of),
    sha1: (e == null ? void 0 : e.sha1) ?? tc.Sha1,
    sha256: (e == null ? void 0 : e.sha256) ?? uc.Sha256,
    streamCollector: (e == null ? void 0 : e.streamCollector) ?? Ho,
    streamHasher: (e == null ? void 0 : e.streamHasher) ?? lm,
    useDualstackEndpoint: (e == null ? void 0 : e.useDualstackEndpoint) ?? (() => Promise.resolve(Fl)),
    useFipsEndpoint: (e == null ? void 0 : e.useFipsEndpoint) ?? (() => Promise.resolve(Dl))
  };
}, Dm = (e) => {
  let t = async () => {
    if (e.region === void 0)
      throw new Error("Region is missing from runtimeConfig");
    const r = e.region;
    return typeof r == "string" ? r : r();
  };
  return {
    setRegion(r) {
      t = r;
    },
    region() {
      return t;
    }
  };
}, Um = (e) => ({
  region: e.region()
}), an = (e) => e, $m = (e, t) => {
  const r = {
    ...an(Dm(e)),
    ...an(Xu(e)),
    ...an(qc(e))
  };
  return t.forEach((n) => n.configure(r)), {
    ...e,
    ...Um(r),
    ...Zu(r),
    ...Wc(r)
  };
};
class Lm extends au {
  constructor(...[t]) {
    const r = Fm(t || {}), n = Ff(r), s = Ul(n), i = sf(s), o = Tf(i), a = o, c = Jd(a), u = Wd(c, { session: [() => this, xg] }), l = il(u), h = $l(l), p = $m(h, (t == null ? void 0 : t.extensions) || []);
    super(p), this.config = p, this.middlewareStack.use(Mf(this.config)), this.middlewareStack.use(jl(this.config)), this.middlewareStack.use(Qc(this.config)), this.middlewareStack.use(tu(this.config)), this.middlewareStack.use(ou(this.config)), this.middlewareStack.use(sl(this.config)), this.middlewareStack.use(Yd(this.config)), this.middlewareStack.use(Xc(this.config)), this.middlewareStack.use(ld(this.config)), this.middlewareStack.use(qd(this.config)), this.middlewareStack.use(Il(this.config));
  }
  destroy() {
    super.destroy();
  }
}
function Hm(e) {
  return (t) => async (r) => {
    const n = { ...r.input }, s = [
      {
        target: "SSECustomerKey",
        hash: "SSECustomerKeyMD5"
      },
      {
        target: "CopySourceSSECustomerKey",
        hash: "CopySourceSSECustomerKeyMD5"
      }
    ];
    for (const i of s) {
      const o = n[i.target];
      if (o) {
        let a;
        typeof o == "string" ? qm(o, e) ? a = e.base64Decoder(o) : (a = e.utf8Decoder(o), n[i.target] = e.base64Encoder(a)) : (a = ArrayBuffer.isView(o) ? new Uint8Array(o.buffer, o.byteOffset, o.byteLength) : new Uint8Array(o), n[i.target] = e.base64Encoder(a));
        const c = new e.md5();
        c.update(a), n[i.hash] = e.base64Encoder(await c.digest());
      }
    }
    return t({
      ...r,
      input: n
    });
  };
}
const jm = {
  name: "ssecMiddleware",
  step: "initialize",
  tags: ["SSE"],
  override: !0
}, zm = (e) => ({
  applyToStack: (t) => {
    t.add(Hm(e), jm);
  }
});
function qm(e, t) {
  if (!/^(?:[A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e))
    return !1;
  try {
    return t.base64Decoder(e).length === 32;
  } catch {
    return !1;
  }
}
var ee;
(function(e) {
  e.MD5 = "MD5", e.CRC32 = "CRC32", e.CRC32C = "CRC32C", e.SHA1 = "SHA1", e.SHA256 = "SHA256";
})(ee || (ee = {}));
var Do;
(function(e) {
  e.HEADER = "header", e.TRAILER = "trailer";
})(Do || (Do = {}));
const Wm = ee.MD5, Gm = ee.CRC32, Rn = [
  ee.CRC32,
  ee.CRC32C,
  ee.SHA1,
  ee.SHA256
], Vm = [
  ee.CRC32,
  ee.CRC32C,
  ee.SHA1,
  ee.SHA256
], Km = (e, { requestChecksumRequired: t, requestAlgorithmMember: r }, n) => {
  const s = n ? Gm : Wm;
  if (!r || !e[r])
    return t ? s : void 0;
  const i = e[r];
  if (!Rn.includes(i))
    throw new Error(`The checksum algorithm "${i}" is not supported by the client. Select one of ${Rn}.`);
  return i;
}, os = (e) => e === ee.MD5 ? "content-md5" : `x-amz-checksum-${e.toLowerCase()}`, Xm = (e, t) => {
  const r = e.toLowerCase();
  for (const n of Object.keys(t))
    if (r === n.toLowerCase())
      return !0;
  return !1;
}, as = (e) => e !== void 0 && typeof e != "string" && !ArrayBuffer.isView(e) && !sa(e);
var cn = {}, Nt = {}, Uo;
function Zm() {
  if (Uo)
    return Nt;
  Uo = 1, Object.defineProperty(Nt, "__esModule", { value: !0 }), Nt.AwsCrc32c = void 0;
  var e = _e, t = We(), r = Dc(), n = (
    /** @class */
    function() {
      function s() {
        this.crc32c = new r.Crc32c();
      }
      return s.prototype.update = function(i) {
        (0, t.isEmptyData)(i) || this.crc32c.update((0, t.convertToBuffer)(i));
      }, s.prototype.digest = function() {
        return e.__awaiter(this, void 0, void 0, function() {
          return e.__generator(this, function(i) {
            return [2, (0, t.numToUint8)(this.crc32c.digest())];
          });
        });
      }, s.prototype.reset = function() {
        this.crc32c = new r.Crc32c();
      }, s;
    }()
  );
  return Nt.AwsCrc32c = n, Nt;
}
var $o;
function Dc() {
  return $o || ($o = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.AwsCrc32c = e.Crc32c = e.crc32c = void 0;
    var t = _e, r = We();
    function n(c) {
      return new s().update(c).digest();
    }
    e.crc32c = n;
    var s = (
      /** @class */
      function() {
        function c() {
          this.checksum = 4294967295;
        }
        return c.prototype.update = function(u) {
          var l, h;
          try {
            for (var p = t.__values(u), g = p.next(); !g.done; g = p.next()) {
              var b = g.value;
              this.checksum = this.checksum >>> 8 ^ o[(this.checksum ^ b) & 255];
            }
          } catch (A) {
            l = { error: A };
          } finally {
            try {
              g && !g.done && (h = p.return) && h.call(p);
            } finally {
              if (l)
                throw l.error;
            }
          }
          return this;
        }, c.prototype.digest = function() {
          return (this.checksum ^ 4294967295) >>> 0;
        }, c;
      }()
    );
    e.Crc32c = s;
    var i = [
      0,
      4067132163,
      3778769143,
      324072436,
      3348797215,
      904991772,
      648144872,
      3570033899,
      2329499855,
      2024987596,
      1809983544,
      2575936315,
      1296289744,
      3207089363,
      2893594407,
      1578318884,
      274646895,
      3795141740,
      4049975192,
      51262619,
      3619967088,
      632279923,
      922689671,
      3298075524,
      2592579488,
      1760304291,
      2075979607,
      2312596564,
      1562183871,
      2943781820,
      3156637768,
      1313733451,
      549293790,
      3537243613,
      3246849577,
      871202090,
      3878099393,
      357341890,
      102525238,
      4101499445,
      2858735121,
      1477399826,
      1264559846,
      3107202533,
      1845379342,
      2677391885,
      2361733625,
      2125378298,
      820201905,
      3263744690,
      3520608582,
      598981189,
      4151959214,
      85089709,
      373468761,
      3827903834,
      3124367742,
      1213305469,
      1526817161,
      2842354314,
      2107672161,
      2412447074,
      2627466902,
      1861252501,
      1098587580,
      3004210879,
      2688576843,
      1378610760,
      2262928035,
      1955203488,
      1742404180,
      2511436119,
      3416409459,
      969524848,
      714683780,
      3639785095,
      205050476,
      4266873199,
      3976438427,
      526918040,
      1361435347,
      2739821008,
      2954799652,
      1114974503,
      2529119692,
      1691668175,
      2005155131,
      2247081528,
      3690758684,
      697762079,
      986182379,
      3366744552,
      476452099,
      3993867776,
      4250756596,
      255256311,
      1640403810,
      2477592673,
      2164122517,
      1922457750,
      2791048317,
      1412925310,
      1197962378,
      3037525897,
      3944729517,
      427051182,
      170179418,
      4165941337,
      746937522,
      3740196785,
      3451792453,
      1070968646,
      1905808397,
      2213795598,
      2426610938,
      1657317369,
      3053634322,
      1147748369,
      1463399397,
      2773627110,
      4215344322,
      153784257,
      444234805,
      3893493558,
      1021025245,
      3467647198,
      3722505002,
      797665321,
      2197175160,
      1889384571,
      1674398607,
      2443626636,
      1164749927,
      3070701412,
      2757221520,
      1446797203,
      137323447,
      4198817972,
      3910406976,
      461344835,
      3484808360,
      1037989803,
      781091935,
      3705997148,
      2460548119,
      1623424788,
      1939049696,
      2180517859,
      1429367560,
      2807687179,
      3020495871,
      1180866812,
      410100952,
      3927582683,
      4182430767,
      186734380,
      3756733383,
      763408580,
      1053836080,
      3434856499,
      2722870694,
      1344288421,
      1131464017,
      2971354706,
      1708204729,
      2545590714,
      2229949006,
      1988219213,
      680717673,
      3673779818,
      3383336350,
      1002577565,
      4010310262,
      493091189,
      238226049,
      4233660802,
      2987750089,
      1082061258,
      1395524158,
      2705686845,
      1972364758,
      2279892693,
      2494862625,
      1725896226,
      952904198,
      3399985413,
      3656866545,
      731699698,
      4283874585,
      222117402,
      510512622,
      3959836397,
      3280807620,
      837199303,
      582374963,
      3504198960,
      68661723,
      4135334616,
      3844915500,
      390545967,
      1230274059,
      3141532936,
      2825850620,
      1510247935,
      2395924756,
      2091215383,
      1878366691,
      2644384480,
      3553878443,
      565732008,
      854102364,
      3229815391,
      340358836,
      3861050807,
      4117890627,
      119113024,
      1493875044,
      2875275879,
      3090270611,
      1247431312,
      2660249211,
      1828433272,
      2141937292,
      2378227087,
      3811616794,
      291187481,
      34330861,
      4032846830,
      615137029,
      3603020806,
      3314634738,
      939183345,
      1776939221,
      2609017814,
      2295496738,
      2058945313,
      2926798794,
      1545135305,
      1330124605,
      3173225534,
      4084100981,
      17165430,
      307568514,
      3762199681,
      888469610,
      3332340585,
      3587147933,
      665062302,
      2042050490,
      2346497209,
      2559330125,
      1793573966,
      3190661285,
      1279665062,
      1595330642,
      2910671697
    ], o = (0, r.uint32ArrayFrom)(i), a = Zm();
    Object.defineProperty(e, "AwsCrc32c", { enumerable: !0, get: function() {
      return a.AwsCrc32c;
    } });
  }(cn)), cn;
}
var Ym = Dc();
const Uc = (e, t) => ({
  [ee.MD5]: t.md5,
  [ee.CRC32]: Jn.AwsCrc32,
  [ee.CRC32C]: Ym.AwsCrc32c,
  [ee.SHA1]: t.sha1,
  [ee.SHA256]: t.sha256
})[e], $c = (e, t) => {
  const r = new e();
  return r.update(ot(t || "")), r.digest();
}, Qm = {
  name: "flexibleChecksumsMiddleware",
  step: "build",
  tags: ["BODY_CHECKSUM"],
  override: !0
}, Jm = (e, t) => (r, n) => async (s) => {
  if (!ge.isInstance(s.request))
    return r(s);
  const { request: i } = s, { body: o, headers: a } = i, { base64Encoder: c, streamHasher: u } = e, { input: l, requestChecksumRequired: h, requestAlgorithmMember: p } = t, g = Km(l, {
    requestChecksumRequired: h,
    requestAlgorithmMember: p
  }, !!n.isS3ExpressBucket);
  let b = o, A = a;
  if (g) {
    const T = os(g), I = Uc(g, e);
    if (as(o)) {
      const { getAwsChunkedEncodingStream: $, bodyLengthChecker: X } = e;
      b = $(o, {
        base64Encoder: c,
        bodyLengthChecker: X,
        checksumLocationName: T,
        checksumAlgorithmFn: I,
        streamHasher: u
      }), A = {
        ...a,
        "content-encoding": a["content-encoding"] ? `${a["content-encoding"]},aws-chunked` : "aws-chunked",
        "transfer-encoding": "chunked",
        "x-amz-decoded-content-length": a["content-length"],
        "x-amz-content-sha256": "STREAMING-UNSIGNED-PAYLOAD-TRAILER",
        "x-amz-trailer": T
      }, delete A["content-length"];
    } else if (!Xm(T, a)) {
      const $ = await $c(I, o);
      A = {
        ...a,
        [T]: c($)
      };
    }
  }
  return await r({
    ...s,
    request: {
      ...i,
      headers: A,
      body: b
    }
  });
}, Lc = (e = []) => {
  const t = [];
  for (const r of Vm)
    !e.includes(r) || !Rn.includes(r) || t.push(r);
  return t;
}, ey = (e) => {
  const t = e.lastIndexOf("-");
  if (t !== -1) {
    const r = e.slice(t + 1);
    if (!r.startsWith("0")) {
      const n = parseInt(r, 10);
      if (!isNaN(n) && n >= 1 && n <= 1e4)
        return !0;
    }
  }
  return !1;
};
function Lo(e) {
  return new Blob([e]).stream();
}
const ty = async (e, { streamHasher: t, checksumAlgorithmFn: r, base64Encoder: n }) => {
  const s = as(e) ? t(r, e) : $c(r, e);
  return n(await s);
}, ry = async (e, { config: t, responseAlgorithms: r }) => {
  const n = Lc(r), { body: s, headers: i } = e;
  for (const o of n) {
    const a = os(o), c = i[a];
    if (c) {
      const u = Uc(o, t), { streamHasher: l, base64Encoder: h } = t, p = await ty(s, { streamHasher: l, checksumAlgorithmFn: u, base64Encoder: h });
      if (p === c)
        break;
      throw new Error(`Checksum mismatch: expected "${p}" but received "${c}" in response header "${a}".`);
    }
  }
}, ny = {
  name: "flexibleChecksumsResponseMiddleware",
  toMiddleware: "deserializerMiddleware",
  relation: "after",
  tags: ["BODY_CHECKSUM"],
  override: !0
}, sy = (e, t) => (r, n) => async (s) => {
  if (!ge.isInstance(s.request))
    return r(s);
  const i = s.input, o = await r(s), a = o.response;
  let c;
  const { requestValidationModeMember: u, responseAlgorithms: l } = t;
  if (u && i[u] === "ENABLED") {
    const { clientName: h, commandName: p } = n;
    if (h === "S3Client" && p === "GetObjectCommand" && Lc(l).every((A) => {
      const R = os(A), T = a.headers[R];
      return !T || ey(T);
    }))
      return o;
    const b = as(a.body);
    b && (c = await e.streamCollector(a.body), a.body = Lo(c)), await ry(o.response, {
      config: e,
      responseAlgorithms: l
    }), b && c && (a.body = Lo(c));
  }
  return o;
}, iy = (e, t) => ({
  applyToStack: (r) => {
    r.add(Jm(e, t), Qm), r.addRelativeTo(sy(e, t), ny);
  }
});
class oy extends On.classBuilder().ep({
  ...Ta,
  Bucket: { type: "contextParams", name: "Bucket" },
  Key: { type: "contextParams", name: "Key" }
}).m(function(t, r, n, s) {
  return [
    xa(n, this.serialize, this.deserialize),
    Aa(n, t.getEndpointParameterInstructions()),
    od(),
    zm(n),
    iy(n, {
      input: this.input,
      requestAlgorithmMember: "ChecksumAlgorithm",
      requestChecksumRequired: !1
    })
  ];
}).s("AmazonS3", "PutObject", {}).n("S3Client", "PutObjectCommand").f(ip, sp).ser(ap).de(up).build() {
}
const ay = zc.create({});
async function cy(e, t, r) {
  return e.getSignedUrl || console.error("uploader.getSignedUrlurl"), await e.getSignedUrl(e.bucket, t, e, r);
}
async function uy(e, t) {
  const { file: r, onProgress: n, options: s } = e, o = await cy(s, t, "put"), a = decodeURIComponent(o);
  return await ay.put(a, r, {
    onUploadProgress: (c) => {
      const { loaded: u, total: l } = c;
      n({ percent: Math.round(u * 100 / l) });
    }
  });
}
async function dy(e) {
  const { file: t, fileName: r, onProgress: n, options: s } = e, i = s, o = new Lm({
    ...(i == null ? void 0 : i.sdkOpts) || {}
  }), a = await Hc(t, r, i);
  async function c() {
    const u = { url: i.sdkOpts.endpoint + "/" + i.bucket + "/" + a, key: a };
    return i.successHandle ? await i.successHandle(u) : u;
  }
  if (i.getSignedUrl)
    await uy(e, a);
  else {
    const u = {
      Bucket: i.bucket,
      Key: a
      // The name of the object. For example, 'sample_upload.txt'.
    };
    await o.send(new oy({ Body: t, ...u }));
  }
  return await c();
}
async function Ey(e) {
  const { getConfig: t } = jc(), r = t("s3"), n = e.options, s = cs.merge(cs.cloneDeep(r), n);
  return e.options = s, await dy(e);
}
export {
  cy as buildSignedUrl,
  Ey as upload,
  uy as uploadUsingSignedUrl
};
//# sourceMappingURL=uploader-s3-f214a8a0.mjs.map
