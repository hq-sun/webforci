/**
  * e-icon-picker v2.1.1
  * (c) 2019 - 2022 cnovel.club
  * @license MIT
  */
import { defineComponent as bt, openBlock as xe, createElementBlock as wt, isRef as zt, watch as de, onMounted as Me, onBeforeUnmount as Ve, unref as Ot, ref as Q, reactive as Ft, nextTick as Yt, toRefs as xt, computed as ne, watchEffect as tt, resolveComponent as Xt, normalizeStyle as $e, createElementVNode as rt, withKeys as Ut, renderSlot as nt, createBlock as ot, Teleport as Zt, createVNode as _t, Transition as Gt, withCtx as Kt, withDirectives as Jt, normalizeClass as Qt, createTextVNode as er, toDisplayString as tr, createCommentVNode as rr, vShow as nr } from "vue";
const or = bt({
  name: "e-arrow"
});
const Et = (t, e) => {
  const r = t.__vccOpts || t;
  for (const [n, o] of e)
    r[n] = o;
  return r;
}, ar = {
  ref: "arrowRef",
  class: "e-arrow",
  "data-popper-arrow": ""
};
function ir(t, e, r, n, o, a) {
  return xe(), wt("span", ar, null, 512);
}
const sr = /* @__PURE__ */ Et(or, [["render", ir], ["__scopeId", "data-v-ce01e648"]]);
function pr(t, e, r) {
  t && zt(t) ? de(t, (n, o) => {
    o == null || o.removeEventListener(e, r), n == null || n.addEventListener(e, r);
  }) : Me(() => {
    t.addEventListener(e, r);
  }), Ve(() => {
    var n;
    (n = Ot(t)) == null || n.removeEventListener(e, r);
  });
}
function lr(t, e) {
  const r = "pointerdown";
  return typeof window > "u" || !window ? void 0 : pr(window, r, (o) => {
    const a = Ot(t);
    a && (a === o.target || o.composedPath().includes(a) || e(o));
  });
}
function fr(t, e, r) {
  let n = null;
  const o = Q(!1);
  Me(() => {
    (t.content !== void 0 || r.value) && (o.value = !0), n = new MutationObserver(a), n.observe(e.value, {
      childList: !0,
      subtree: !0
    });
  }), Ve(() => n.disconnect()), de(r, (l) => {
    o.value = !!l;
  });
  const a = () => {
    o.value = !!t.content;
  };
  return {
    hasContent: o
  };
}
var k = "top", B = "bottom", j = "right", I = "left", Se = "auto", me = [k, B, j, I], oe = "start", ve = "end", ur = "clippingParents", Pt = "viewport", fe = "popper", cr = "reference", at = /* @__PURE__ */ me.reduce(function(t, e) {
  return t.concat([e + "-" + oe, e + "-" + ve]);
}, []), St = /* @__PURE__ */ [].concat(me, [Se]).reduce(function(t, e) {
  return t.concat([e, e + "-" + oe, e + "-" + ve]);
}, []), dr = "beforeRead", vr = "read", hr = "afterRead", mr = "beforeMain", gr = "main", yr = "afterMain", br = "beforeWrite", wr = "write", Or = "afterWrite", Le = [dr, vr, hr, mr, gr, yr, br, wr, Or];
function q(t) {
  return t ? (t.nodeName || "").toLowerCase() : null;
}
function M(t) {
  if (t == null)
    return window;
  if (t.toString() !== "[object Window]") {
    var e = t.ownerDocument;
    return e && e.defaultView || window;
  }
  return t;
}
function te(t) {
  var e = M(t).Element;
  return t instanceof e || t instanceof Element;
}
function L(t) {
  var e = M(t).HTMLElement;
  return t instanceof e || t instanceof HTMLElement;
}
function We(t) {
  if (typeof ShadowRoot > "u")
    return !1;
  var e = M(t).ShadowRoot;
  return t instanceof e || t instanceof ShadowRoot;
}
function xr(t) {
  var e = t.state;
  Object.keys(e.elements).forEach(function(r) {
    var n = e.styles[r] || {}, o = e.attributes[r] || {}, a = e.elements[r];
    !L(a) || !q(a) || (Object.assign(a.style, n), Object.keys(o).forEach(function(l) {
      var i = o[l];
      i === !1 ? a.removeAttribute(l) : a.setAttribute(l, i === !0 ? "" : i);
    }));
  });
}
function Er(t) {
  var e = t.state, r = {
    popper: {
      position: e.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  return Object.assign(e.elements.popper.style, r.popper), e.styles = r, e.elements.arrow && Object.assign(e.elements.arrow.style, r.arrow), function() {
    Object.keys(e.elements).forEach(function(n) {
      var o = e.elements[n], a = e.attributes[n] || {}, l = Object.keys(e.styles.hasOwnProperty(n) ? e.styles[n] : r[n]), i = l.reduce(function(s, f) {
        return s[f] = "", s;
      }, {});
      !L(o) || !q(o) || (Object.assign(o.style, i), Object.keys(a).forEach(function(s) {
        o.removeAttribute(s);
      }));
    });
  };
}
const Pr = {
  name: "applyStyles",
  enabled: !0,
  phase: "write",
  fn: xr,
  effect: Er,
  requires: ["computeStyles"]
};
function W(t) {
  return t.split("-")[0];
}
var ee = Math.max, Pe = Math.min, ae = Math.round;
function Te() {
  var t = navigator.userAgentData;
  return t != null && t.brands ? t.brands.map(function(e) {
    return e.brand + "/" + e.version;
  }).join(" ") : navigator.userAgent;
}
function At() {
  return !/^((?!chrome|android).)*safari/i.test(Te());
}
function ie(t, e, r) {
  e === void 0 && (e = !1), r === void 0 && (r = !1);
  var n = t.getBoundingClientRect(), o = 1, a = 1;
  e && L(t) && (o = t.offsetWidth > 0 && ae(n.width) / t.offsetWidth || 1, a = t.offsetHeight > 0 && ae(n.height) / t.offsetHeight || 1);
  var l = te(t) ? M(t) : window, i = l.visualViewport, s = !At() && r, f = (n.left + (s && i ? i.offsetLeft : 0)) / o, p = (n.top + (s && i ? i.offsetTop : 0)) / a, m = n.width / o, b = n.height / a;
  return {
    width: m,
    height: b,
    top: p,
    right: f + m,
    bottom: p + b,
    left: f,
    x: f,
    y: p
  };
}
function He(t) {
  var e = ie(t), r = t.offsetWidth, n = t.offsetHeight;
  return Math.abs(e.width - r) <= 1 && (r = e.width), Math.abs(e.height - n) <= 1 && (n = e.height), {
    x: t.offsetLeft,
    y: t.offsetTop,
    width: r,
    height: n
  };
}
function Dt(t, e) {
  var r = e.getRootNode && e.getRootNode();
  if (t.contains(e))
    return !0;
  if (r && We(r)) {
    var n = e;
    do {
      if (n && t.isSameNode(n))
        return !0;
      n = n.parentNode || n.host;
    } while (n);
  }
  return !1;
}
function H(t) {
  return M(t).getComputedStyle(t);
}
function Sr(t) {
  return ["table", "td", "th"].indexOf(q(t)) >= 0;
}
function _(t) {
  return ((te(t) ? t.ownerDocument : t.document) || window.document).documentElement;
}
function Ae(t) {
  return q(t) === "html" ? t : t.assignedSlot || t.parentNode || (We(t) ? t.host : null) || _(t);
}
function it(t) {
  return !L(t) || H(t).position === "fixed" ? null : t.offsetParent;
}
function Ar(t) {
  var e = /firefox/i.test(Te()), r = /Trident/i.test(Te());
  if (r && L(t)) {
    var n = H(t);
    if (n.position === "fixed")
      return null;
  }
  var o = Ae(t);
  for (We(o) && (o = o.host); L(o) && ["html", "body"].indexOf(q(o)) < 0; ) {
    var a = H(o);
    if (a.transform !== "none" || a.perspective !== "none" || a.contain === "paint" || ["transform", "perspective"].indexOf(a.willChange) !== -1 || e && a.willChange === "filter" || e && a.filter && a.filter !== "none")
      return o;
    o = o.parentNode;
  }
  return null;
}
function ge(t) {
  for (var e = M(t), r = it(t); r && Sr(r) && H(r).position === "static"; )
    r = it(r);
  return r && (q(r) === "html" || q(r) === "body" && H(r).position === "static") ? e : r || Ar(t) || e;
}
function qe(t) {
  return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y";
}
function ue(t, e, r) {
  return ee(t, Pe(e, r));
}
function Dr(t, e, r) {
  var n = ue(t, e, r);
  return n > r ? r : n;
}
function Ct() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function Nt(t) {
  return Object.assign({}, Ct(), t);
}
function Rt(t, e) {
  return e.reduce(function(r, n) {
    return r[n] = t, r;
  }, {});
}
var Cr = function(e, r) {
  return e = typeof e == "function" ? e(Object.assign({}, r.rects, {
    placement: r.placement
  })) : e, Nt(typeof e != "number" ? e : Rt(e, me));
};
function Nr(t) {
  var e, r = t.state, n = t.name, o = t.options, a = r.elements.arrow, l = r.modifiersData.popperOffsets, i = W(r.placement), s = qe(i), f = [I, j].indexOf(i) >= 0, p = f ? "height" : "width";
  if (!(!a || !l)) {
    var m = Cr(o.padding, r), b = He(a), u = s === "y" ? k : I, O = s === "y" ? B : j, c = r.rects.reference[p] + r.rects.reference[s] - l[s] - r.rects.popper[p], v = l[s] - r.rects.reference[s], y = ge(a), A = y ? s === "y" ? y.clientHeight || 0 : y.clientWidth || 0 : 0, P = c / 2 - v / 2, h = m[u], g = A - b[p] - m[O], d = A / 2 - b[p] / 2 + P, x = ue(h, d, g), S = s;
    r.modifiersData[n] = (e = {}, e[S] = x, e.centerOffset = x - d, e);
  }
}
function Rr(t) {
  var e = t.state, r = t.options, n = r.element, o = n === void 0 ? "[data-popper-arrow]" : n;
  if (o != null && !(typeof o == "string" && (o = e.elements.popper.querySelector(o), !o))) {
    if (process.env.NODE_ENV !== "production" && (L(o) || console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "))), !Dt(e.elements.popper, o)) {
      process.env.NODE_ENV !== "production" && console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
      return;
    }
    e.elements.arrow = o;
  }
}
const $t = {
  name: "arrow",
  enabled: !0,
  phase: "main",
  fn: Nr,
  effect: Rr,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function se(t) {
  return t.split("-")[1];
}
var $r = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function kr(t) {
  var e = t.x, r = t.y, n = window, o = n.devicePixelRatio || 1;
  return {
    x: ae(e * o) / o || 0,
    y: ae(r * o) / o || 0
  };
}
function st(t) {
  var e, r = t.popper, n = t.popperRect, o = t.placement, a = t.variation, l = t.offsets, i = t.position, s = t.gpuAcceleration, f = t.adaptive, p = t.roundOffsets, m = t.isFixed, b = l.x, u = b === void 0 ? 0 : b, O = l.y, c = O === void 0 ? 0 : O, v = typeof p == "function" ? p({
    x: u,
    y: c
  }) : {
    x: u,
    y: c
  };
  u = v.x, c = v.y;
  var y = l.hasOwnProperty("x"), A = l.hasOwnProperty("y"), P = I, h = k, g = window;
  if (f) {
    var d = ge(r), x = "clientHeight", S = "clientWidth";
    if (d === M(r) && (d = _(r), H(d).position !== "static" && i === "absolute" && (x = "scrollHeight", S = "scrollWidth")), d = d, o === k || (o === I || o === j) && a === ve) {
      h = B;
      var D = m && d === g && g.visualViewport ? g.visualViewport.height : d[x];
      c -= D - n.height, c *= s ? 1 : -1;
    }
    if (o === I || (o === k || o === B) && a === ve) {
      P = j;
      var E = m && d === g && g.visualViewport ? g.visualViewport.width : d[S];
      u -= E - n.width, u *= s ? 1 : -1;
    }
  }
  var w = Object.assign({
    position: i
  }, f && $r), C = p === !0 ? kr({
    x: u,
    y: c
  }) : {
    x: u,
    y: c
  };
  if (u = C.x, c = C.y, s) {
    var N;
    return Object.assign({}, w, (N = {}, N[h] = A ? "0" : "", N[P] = y ? "0" : "", N.transform = (g.devicePixelRatio || 1) <= 1 ? "translate(" + u + "px, " + c + "px)" : "translate3d(" + u + "px, " + c + "px, 0)", N));
  }
  return Object.assign({}, w, (e = {}, e[h] = A ? c + "px" : "", e[P] = y ? u + "px" : "", e.transform = "", e));
}
function Ir(t) {
  var e = t.state, r = t.options, n = r.gpuAcceleration, o = n === void 0 ? !0 : n, a = r.adaptive, l = a === void 0 ? !0 : a, i = r.roundOffsets, s = i === void 0 ? !0 : i;
  if (process.env.NODE_ENV !== "production") {
    var f = H(e.elements.popper).transitionProperty || "";
    l && ["transform", "top", "right", "bottom", "left"].some(function(m) {
      return f.indexOf(m) >= 0;
    }) && console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', `

`, 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", `

`, "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
  }
  var p = {
    placement: W(e.placement),
    variation: se(e.placement),
    popper: e.elements.popper,
    popperRect: e.rects.popper,
    gpuAcceleration: o,
    isFixed: e.options.strategy === "fixed"
  };
  e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, st(Object.assign({}, p, {
    offsets: e.modifiersData.popperOffsets,
    position: e.options.strategy,
    adaptive: l,
    roundOffsets: s
  })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, st(Object.assign({}, p, {
    offsets: e.modifiersData.arrow,
    position: "absolute",
    adaptive: !1,
    roundOffsets: s
  })))), e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-placement": e.placement
  });
}
const Lr = {
  name: "computeStyles",
  enabled: !0,
  phase: "beforeWrite",
  fn: Ir,
  data: {}
};
var Oe = {
  passive: !0
};
function Tr(t) {
  var e = t.state, r = t.instance, n = t.options, o = n.scroll, a = o === void 0 ? !0 : o, l = n.resize, i = l === void 0 ? !0 : l, s = M(e.elements.popper), f = [].concat(e.scrollParents.reference, e.scrollParents.popper);
  return a && f.forEach(function(p) {
    p.addEventListener("scroll", r.update, Oe);
  }), i && s.addEventListener("resize", r.update, Oe), function() {
    a && f.forEach(function(p) {
      p.removeEventListener("scroll", r.update, Oe);
    }), i && s.removeEventListener("resize", r.update, Oe);
  };
}
const Br = {
  name: "eventListeners",
  enabled: !0,
  phase: "write",
  fn: function() {
  },
  effect: Tr,
  data: {}
};
var jr = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function Ee(t) {
  return t.replace(/left|right|bottom|top/g, function(e) {
    return jr[e];
  });
}
var Mr = {
  start: "end",
  end: "start"
};
function pt(t) {
  return t.replace(/start|end/g, function(e) {
    return Mr[e];
  });
}
function ze(t) {
  var e = M(t), r = e.pageXOffset, n = e.pageYOffset;
  return {
    scrollLeft: r,
    scrollTop: n
  };
}
function Fe(t) {
  return ie(_(t)).left + ze(t).scrollLeft;
}
function Vr(t, e) {
  var r = M(t), n = _(t), o = r.visualViewport, a = n.clientWidth, l = n.clientHeight, i = 0, s = 0;
  if (o) {
    a = o.width, l = o.height;
    var f = At();
    (f || !f && e === "fixed") && (i = o.offsetLeft, s = o.offsetTop);
  }
  return {
    width: a,
    height: l,
    x: i + Fe(t),
    y: s
  };
}
function Wr(t) {
  var e, r = _(t), n = ze(t), o = (e = t.ownerDocument) == null ? void 0 : e.body, a = ee(r.scrollWidth, r.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0), l = ee(r.scrollHeight, r.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0), i = -n.scrollLeft + Fe(t), s = -n.scrollTop;
  return H(o || r).direction === "rtl" && (i += ee(r.clientWidth, o ? o.clientWidth : 0) - a), {
    width: a,
    height: l,
    x: i,
    y: s
  };
}
function Ye(t) {
  var e = H(t), r = e.overflow, n = e.overflowX, o = e.overflowY;
  return /auto|scroll|overlay|hidden/.test(r + o + n);
}
function kt(t) {
  return ["html", "body", "#document"].indexOf(q(t)) >= 0 ? t.ownerDocument.body : L(t) && Ye(t) ? t : kt(Ae(t));
}
function ce(t, e) {
  var r;
  e === void 0 && (e = []);
  var n = kt(t), o = n === ((r = t.ownerDocument) == null ? void 0 : r.body), a = M(n), l = o ? [a].concat(a.visualViewport || [], Ye(n) ? n : []) : n, i = e.concat(l);
  return o ? i : i.concat(ce(Ae(l)));
}
function Be(t) {
  return Object.assign({}, t, {
    left: t.x,
    top: t.y,
    right: t.x + t.width,
    bottom: t.y + t.height
  });
}
function Hr(t, e) {
  var r = ie(t, !1, e === "fixed");
  return r.top = r.top + t.clientTop, r.left = r.left + t.clientLeft, r.bottom = r.top + t.clientHeight, r.right = r.left + t.clientWidth, r.width = t.clientWidth, r.height = t.clientHeight, r.x = r.left, r.y = r.top, r;
}
function lt(t, e, r) {
  return e === Pt ? Be(Vr(t, r)) : te(e) ? Hr(e, r) : Be(Wr(_(t)));
}
function qr(t) {
  var e = ce(Ae(t)), r = ["absolute", "fixed"].indexOf(H(t).position) >= 0, n = r && L(t) ? ge(t) : t;
  return te(n) ? e.filter(function(o) {
    return te(o) && Dt(o, n) && q(o) !== "body";
  }) : [];
}
function zr(t, e, r, n) {
  var o = e === "clippingParents" ? qr(t) : [].concat(e), a = [].concat(o, [r]), l = a[0], i = a.reduce(function(s, f) {
    var p = lt(t, f, n);
    return s.top = ee(p.top, s.top), s.right = Pe(p.right, s.right), s.bottom = Pe(p.bottom, s.bottom), s.left = ee(p.left, s.left), s;
  }, lt(t, l, n));
  return i.width = i.right - i.left, i.height = i.bottom - i.top, i.x = i.left, i.y = i.top, i;
}
function It(t) {
  var e = t.reference, r = t.element, n = t.placement, o = n ? W(n) : null, a = n ? se(n) : null, l = e.x + e.width / 2 - r.width / 2, i = e.y + e.height / 2 - r.height / 2, s;
  switch (o) {
    case k:
      s = {
        x: l,
        y: e.y - r.height
      };
      break;
    case B:
      s = {
        x: l,
        y: e.y + e.height
      };
      break;
    case j:
      s = {
        x: e.x + e.width,
        y: i
      };
      break;
    case I:
      s = {
        x: e.x - r.width,
        y: i
      };
      break;
    default:
      s = {
        x: e.x,
        y: e.y
      };
  }
  var f = o ? qe(o) : null;
  if (f != null) {
    var p = f === "y" ? "height" : "width";
    switch (a) {
      case oe:
        s[f] = s[f] - (e[p] / 2 - r[p] / 2);
        break;
      case ve:
        s[f] = s[f] + (e[p] / 2 - r[p] / 2);
        break;
    }
  }
  return s;
}
function he(t, e) {
  e === void 0 && (e = {});
  var r = e, n = r.placement, o = n === void 0 ? t.placement : n, a = r.strategy, l = a === void 0 ? t.strategy : a, i = r.boundary, s = i === void 0 ? ur : i, f = r.rootBoundary, p = f === void 0 ? Pt : f, m = r.elementContext, b = m === void 0 ? fe : m, u = r.altBoundary, O = u === void 0 ? !1 : u, c = r.padding, v = c === void 0 ? 0 : c, y = Nt(typeof v != "number" ? v : Rt(v, me)), A = b === fe ? cr : fe, P = t.rects.popper, h = t.elements[O ? A : b], g = zr(te(h) ? h : h.contextElement || _(t.elements.popper), s, p, l), d = ie(t.elements.reference), x = It({
    reference: d,
    element: P,
    strategy: "absolute",
    placement: o
  }), S = Be(Object.assign({}, P, x)), D = b === fe ? S : d, E = {
    top: g.top - D.top + y.top,
    bottom: D.bottom - g.bottom + y.bottom,
    left: g.left - D.left + y.left,
    right: D.right - g.right + y.right
  }, w = t.modifiersData.offset;
  if (b === fe && w) {
    var C = w[o];
    Object.keys(E).forEach(function(N) {
      var z = [j, B].indexOf(N) >= 0 ? 1 : -1, V = [k, B].indexOf(N) >= 0 ? "y" : "x";
      E[N] += C[V] * z;
    });
  }
  return E;
}
function Fr(t, e) {
  e === void 0 && (e = {});
  var r = e, n = r.placement, o = r.boundary, a = r.rootBoundary, l = r.padding, i = r.flipVariations, s = r.allowedAutoPlacements, f = s === void 0 ? St : s, p = se(n), m = p ? i ? at : at.filter(function(O) {
    return se(O) === p;
  }) : me, b = m.filter(function(O) {
    return f.indexOf(O) >= 0;
  });
  b.length === 0 && (b = m, process.env.NODE_ENV !== "production" && console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" ")));
  var u = b.reduce(function(O, c) {
    return O[c] = he(t, {
      placement: c,
      boundary: o,
      rootBoundary: a,
      padding: l
    })[W(c)], O;
  }, {});
  return Object.keys(u).sort(function(O, c) {
    return u[O] - u[c];
  });
}
function Yr(t) {
  if (W(t) === Se)
    return [];
  var e = Ee(t);
  return [pt(t), e, pt(e)];
}
function Xr(t) {
  var e = t.state, r = t.options, n = t.name;
  if (!e.modifiersData[n]._skip) {
    for (var o = r.mainAxis, a = o === void 0 ? !0 : o, l = r.altAxis, i = l === void 0 ? !0 : l, s = r.fallbackPlacements, f = r.padding, p = r.boundary, m = r.rootBoundary, b = r.altBoundary, u = r.flipVariations, O = u === void 0 ? !0 : u, c = r.allowedAutoPlacements, v = e.options.placement, y = W(v), A = y === v, P = s || (A || !O ? [Ee(v)] : Yr(v)), h = [v].concat(P).reduce(function(re, U) {
      return re.concat(W(U) === Se ? Fr(e, {
        placement: U,
        boundary: p,
        rootBoundary: m,
        padding: f,
        flipVariations: O,
        allowedAutoPlacements: c
      }) : U);
    }, []), g = e.rects.reference, d = e.rects.popper, x = /* @__PURE__ */ new Map(), S = !0, D = h[0], E = 0; E < h.length; E++) {
      var w = h[E], C = W(w), N = se(w) === oe, z = [k, B].indexOf(C) >= 0, V = z ? "width" : "height", R = he(e, {
        placement: w,
        boundary: p,
        rootBoundary: m,
        altBoundary: b,
        padding: f
      }), $ = z ? N ? j : I : N ? B : k;
      g[V] > d[V] && ($ = Ee($));
      var Y = Ee($), F = [];
      if (a && F.push(R[C] <= 0), i && F.push(R[$] <= 0, R[Y] <= 0), F.every(function(re) {
        return re;
      })) {
        D = w, S = !1;
        break;
      }
      x.set(w, F);
    }
    if (S)
      for (var T = O ? 3 : 1, X = function(U) {
        var le = h.find(function(be) {
          var G = x.get(be);
          if (G)
            return G.slice(0, U).every(function(Ce) {
              return Ce;
            });
        });
        if (le)
          return D = le, "break";
      }, pe = T; pe > 0; pe--) {
        var ye = X(pe);
        if (ye === "break")
          break;
      }
    e.placement !== D && (e.modifiersData[n]._skip = !0, e.placement = D, e.reset = !0);
  }
}
const Lt = {
  name: "flip",
  enabled: !0,
  phase: "main",
  fn: Xr,
  requiresIfExists: ["offset"],
  data: {
    _skip: !1
  }
};
function ft(t, e, r) {
  return r === void 0 && (r = {
    x: 0,
    y: 0
  }), {
    top: t.top - e.height - r.y,
    right: t.right - e.width + r.x,
    bottom: t.bottom - e.height + r.y,
    left: t.left - e.width - r.x
  };
}
function ut(t) {
  return [k, j, B, I].some(function(e) {
    return t[e] >= 0;
  });
}
function Ur(t) {
  var e = t.state, r = t.name, n = e.rects.reference, o = e.rects.popper, a = e.modifiersData.preventOverflow, l = he(e, {
    elementContext: "reference"
  }), i = he(e, {
    altBoundary: !0
  }), s = ft(l, n), f = ft(i, o, a), p = ut(s), m = ut(f);
  e.modifiersData[r] = {
    referenceClippingOffsets: s,
    popperEscapeOffsets: f,
    isReferenceHidden: p,
    hasPopperEscaped: m
  }, e.attributes.popper = Object.assign({}, e.attributes.popper, {
    "data-popper-reference-hidden": p,
    "data-popper-escaped": m
  });
}
const Zr = {
  name: "hide",
  enabled: !0,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: Ur
};
function _r(t, e, r) {
  var n = W(t), o = [I, k].indexOf(n) >= 0 ? -1 : 1, a = typeof r == "function" ? r(Object.assign({}, e, {
    placement: t
  })) : r, l = a[0], i = a[1];
  return l = l || 0, i = (i || 0) * o, [I, j].indexOf(n) >= 0 ? {
    x: i,
    y: l
  } : {
    x: l,
    y: i
  };
}
function Gr(t) {
  var e = t.state, r = t.options, n = t.name, o = r.offset, a = o === void 0 ? [0, 0] : o, l = St.reduce(function(p, m) {
    return p[m] = _r(m, e.rects, a), p;
  }, {}), i = l[e.placement], s = i.x, f = i.y;
  e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += s, e.modifiersData.popperOffsets.y += f), e.modifiersData[n] = l;
}
const Tt = {
  name: "offset",
  enabled: !0,
  phase: "main",
  requires: ["popperOffsets"],
  fn: Gr
};
function Kr(t) {
  var e = t.state, r = t.name;
  e.modifiersData[r] = It({
    reference: e.rects.reference,
    element: e.rects.popper,
    strategy: "absolute",
    placement: e.placement
  });
}
const Jr = {
  name: "popperOffsets",
  enabled: !0,
  phase: "read",
  fn: Kr,
  data: {}
};
function Qr(t) {
  return t === "x" ? "y" : "x";
}
function en(t) {
  var e = t.state, r = t.options, n = t.name, o = r.mainAxis, a = o === void 0 ? !0 : o, l = r.altAxis, i = l === void 0 ? !1 : l, s = r.boundary, f = r.rootBoundary, p = r.altBoundary, m = r.padding, b = r.tether, u = b === void 0 ? !0 : b, O = r.tetherOffset, c = O === void 0 ? 0 : O, v = he(e, {
    boundary: s,
    rootBoundary: f,
    padding: m,
    altBoundary: p
  }), y = W(e.placement), A = se(e.placement), P = !A, h = qe(y), g = Qr(h), d = e.modifiersData.popperOffsets, x = e.rects.reference, S = e.rects.popper, D = typeof c == "function" ? c(Object.assign({}, e.rects, {
    placement: e.placement
  })) : c, E = typeof D == "number" ? {
    mainAxis: D,
    altAxis: D
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, D), w = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, C = {
    x: 0,
    y: 0
  };
  if (d) {
    if (a) {
      var N, z = h === "y" ? k : I, V = h === "y" ? B : j, R = h === "y" ? "height" : "width", $ = d[h], Y = $ + v[z], F = $ - v[V], T = u ? -S[R] / 2 : 0, X = A === oe ? x[R] : S[R], pe = A === oe ? -S[R] : -x[R], ye = e.elements.arrow, re = u && ye ? He(ye) : {
        width: 0,
        height: 0
      }, U = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : Ct(), le = U[z], be = U[V], G = ue(0, x[R], re[R]), Ce = P ? x[R] / 2 - T - G - le - E.mainAxis : X - G - le - E.mainAxis, jt = P ? -x[R] / 2 + T + G + be + E.mainAxis : pe + G + be + E.mainAxis, Ne = e.elements.arrow && ge(e.elements.arrow), Mt = Ne ? h === "y" ? Ne.clientTop || 0 : Ne.clientLeft || 0 : 0, Xe = (N = w == null ? void 0 : w[h]) != null ? N : 0, Vt = $ + Ce - Xe - Mt, Wt = $ + jt - Xe, Ue = ue(u ? Pe(Y, Vt) : Y, $, u ? ee(F, Wt) : F);
      d[h] = Ue, C[h] = Ue - $;
    }
    if (i) {
      var Ze, Ht = h === "x" ? k : I, qt = h === "x" ? B : j, K = d[g], we = g === "y" ? "height" : "width", _e = K + v[Ht], Ge = K - v[qt], Re = [k, I].indexOf(y) !== -1, Ke = (Ze = w == null ? void 0 : w[g]) != null ? Ze : 0, Je = Re ? _e : K - x[we] - S[we] - Ke + E.altAxis, Qe = Re ? K + x[we] + S[we] - Ke - E.altAxis : Ge, et = u && Re ? Dr(Je, K, Qe) : ue(u ? Je : _e, K, u ? Qe : Ge);
      d[g] = et, C[g] = et - K;
    }
    e.modifiersData[n] = C;
  }
}
const Bt = {
  name: "preventOverflow",
  enabled: !0,
  phase: "main",
  fn: en,
  requiresIfExists: ["offset"]
};
function tn(t) {
  return {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  };
}
function rn(t) {
  return t === M(t) || !L(t) ? ze(t) : tn(t);
}
function nn(t) {
  var e = t.getBoundingClientRect(), r = ae(e.width) / t.offsetWidth || 1, n = ae(e.height) / t.offsetHeight || 1;
  return r !== 1 || n !== 1;
}
function on(t, e, r) {
  r === void 0 && (r = !1);
  var n = L(e), o = L(e) && nn(e), a = _(e), l = ie(t, o, r), i = {
    scrollLeft: 0,
    scrollTop: 0
  }, s = {
    x: 0,
    y: 0
  };
  return (n || !n && !r) && ((q(e) !== "body" || Ye(a)) && (i = rn(e)), L(e) ? (s = ie(e, !0), s.x += e.clientLeft, s.y += e.clientTop) : a && (s.x = Fe(a))), {
    x: l.left + i.scrollLeft - s.x,
    y: l.top + i.scrollTop - s.y,
    width: l.width,
    height: l.height
  };
}
function an(t) {
  var e = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Set(), n = [];
  t.forEach(function(a) {
    e.set(a.name, a);
  });
  function o(a) {
    r.add(a.name);
    var l = [].concat(a.requires || [], a.requiresIfExists || []);
    l.forEach(function(i) {
      if (!r.has(i)) {
        var s = e.get(i);
        s && o(s);
      }
    }), n.push(a);
  }
  return t.forEach(function(a) {
    r.has(a.name) || o(a);
  }), n;
}
function sn(t) {
  var e = an(t);
  return Le.reduce(function(r, n) {
    return r.concat(e.filter(function(o) {
      return o.phase === n;
    }));
  }, []);
}
function pn(t) {
  var e;
  return function() {
    return e || (e = new Promise(function(r) {
      Promise.resolve().then(function() {
        e = void 0, r(t());
      });
    })), e;
  };
}
function Z(t) {
  for (var e = arguments.length, r = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
    r[n - 1] = arguments[n];
  return [].concat(r).reduce(function(o, a) {
    return o.replace(/%s/, a);
  }, t);
}
var J = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s', ln = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available', ct = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function fn(t) {
  t.forEach(function(e) {
    [].concat(Object.keys(e), ct).filter(function(r, n, o) {
      return o.indexOf(r) === n;
    }).forEach(function(r) {
      switch (r) {
        case "name":
          typeof e.name != "string" && console.error(Z(J, String(e.name), '"name"', '"string"', '"' + String(e.name) + '"'));
          break;
        case "enabled":
          typeof e.enabled != "boolean" && console.error(Z(J, e.name, '"enabled"', '"boolean"', '"' + String(e.enabled) + '"'));
          break;
        case "phase":
          Le.indexOf(e.phase) < 0 && console.error(Z(J, e.name, '"phase"', "either " + Le.join(", "), '"' + String(e.phase) + '"'));
          break;
        case "fn":
          typeof e.fn != "function" && console.error(Z(J, e.name, '"fn"', '"function"', '"' + String(e.fn) + '"'));
          break;
        case "effect":
          e.effect != null && typeof e.effect != "function" && console.error(Z(J, e.name, '"effect"', '"function"', '"' + String(e.fn) + '"'));
          break;
        case "requires":
          e.requires != null && !Array.isArray(e.requires) && console.error(Z(J, e.name, '"requires"', '"array"', '"' + String(e.requires) + '"'));
          break;
        case "requiresIfExists":
          Array.isArray(e.requiresIfExists) || console.error(Z(J, e.name, '"requiresIfExists"', '"array"', '"' + String(e.requiresIfExists) + '"'));
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + e.name + '" modifier, valid properties are ' + ct.map(function(n) {
            return '"' + n + '"';
          }).join(", ") + '; but "' + r + '" was provided.');
      }
      e.requires && e.requires.forEach(function(n) {
        t.find(function(o) {
          return o.name === n;
        }) == null && console.error(Z(ln, String(e.name), n, n));
      });
    });
  });
}
function un(t, e) {
  var r = /* @__PURE__ */ new Set();
  return t.filter(function(n) {
    var o = e(n);
    if (!r.has(o))
      return r.add(o), !0;
  });
}
function cn(t) {
  var e = t.reduce(function(r, n) {
    var o = r[n.name];
    return r[n.name] = o ? Object.assign({}, o, n, {
      options: Object.assign({}, o.options, n.options),
      data: Object.assign({}, o.data, n.data)
    }) : n, r;
  }, {});
  return Object.keys(e).map(function(r) {
    return e[r];
  });
}
var dt = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.", dn = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.", vt = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function ht() {
  for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
    e[r] = arguments[r];
  return !e.some(function(n) {
    return !(n && typeof n.getBoundingClientRect == "function");
  });
}
function vn(t) {
  t === void 0 && (t = {});
  var e = t, r = e.defaultModifiers, n = r === void 0 ? [] : r, o = e.defaultOptions, a = o === void 0 ? vt : o;
  return function(i, s, f) {
    f === void 0 && (f = a);
    var p = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, vt, a),
      modifiersData: {},
      elements: {
        reference: i,
        popper: s
      },
      attributes: {},
      styles: {}
    }, m = [], b = !1, u = {
      state: p,
      setOptions: function(y) {
        var A = typeof y == "function" ? y(p.options) : y;
        c(), p.options = Object.assign({}, a, p.options, A), p.scrollParents = {
          reference: te(i) ? ce(i) : i.contextElement ? ce(i.contextElement) : [],
          popper: ce(s)
        };
        var P = sn(cn([].concat(n, p.options.modifiers)));
        if (p.orderedModifiers = P.filter(function(w) {
          return w.enabled;
        }), process.env.NODE_ENV !== "production") {
          var h = un([].concat(P, p.options.modifiers), function(w) {
            var C = w.name;
            return C;
          });
          if (fn(h), W(p.options.placement) === Se) {
            var g = p.orderedModifiers.find(function(w) {
              var C = w.name;
              return C === "flip";
            });
            g || console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
          }
          var d = H(s), x = d.marginTop, S = d.marginRight, D = d.marginBottom, E = d.marginLeft;
          [x, S, D, E].some(function(w) {
            return parseFloat(w);
          }) && console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
        }
        return O(), u.update();
      },
      forceUpdate: function() {
        if (!b) {
          var y = p.elements, A = y.reference, P = y.popper;
          if (!ht(A, P)) {
            process.env.NODE_ENV !== "production" && console.error(dt);
            return;
          }
          p.rects = {
            reference: on(A, ge(P), p.options.strategy === "fixed"),
            popper: He(P)
          }, p.reset = !1, p.placement = p.options.placement, p.orderedModifiers.forEach(function(w) {
            return p.modifiersData[w.name] = Object.assign({}, w.data);
          });
          for (var h = 0, g = 0; g < p.orderedModifiers.length; g++) {
            if (process.env.NODE_ENV !== "production" && (h += 1, h > 100)) {
              console.error(dn);
              break;
            }
            if (p.reset === !0) {
              p.reset = !1, g = -1;
              continue;
            }
            var d = p.orderedModifiers[g], x = d.fn, S = d.options, D = S === void 0 ? {} : S, E = d.name;
            typeof x == "function" && (p = x({
              state: p,
              options: D,
              name: E,
              instance: u
            }) || p);
          }
        }
      },
      update: pn(function() {
        return new Promise(function(v) {
          u.forceUpdate(), v(p);
        });
      }),
      destroy: function() {
        c(), b = !0;
      }
    };
    if (!ht(i, s))
      return process.env.NODE_ENV !== "production" && console.error(dt), u;
    u.setOptions(f).then(function(v) {
      !b && f.onFirstUpdate && f.onFirstUpdate(v);
    });
    function O() {
      p.orderedModifiers.forEach(function(v) {
        var y = v.name, A = v.options, P = A === void 0 ? {} : A, h = v.effect;
        if (typeof h == "function") {
          var g = h({
            state: p,
            name: y,
            instance: u,
            options: P
          }), d = function() {
          };
          m.push(g || d);
        }
      });
    }
    function c() {
      m.forEach(function(v) {
        return v();
      }), m = [];
    }
    return u;
  };
}
var hn = [Br, Jr, Lr, Pr, Tt, Lt, Bt, $t, Zr], mn = /* @__PURE__ */ vn({
  defaultModifiers: hn
});
const gn = "close:popper", yn = "open:popper", ke = (t) => parseInt(t, 10);
function bn({
  arrowPadding: t,
  emit: e,
  locked: r,
  offsetDistance: n,
  offsetSkid: o,
  placement: a,
  popperNode: l,
  triggerNode: i
}) {
  const s = Ft({
    isOpen: !1,
    popperInstance: null
  }), f = (c) => {
    var v;
    (v = s.popperInstance) == null || v.setOptions((y) => ({
      ...y,
      modifiers: [...y.modifiers, { name: "eventListeners", enabled: c }]
    }));
  }, p = () => f(!0), m = () => f(!1), b = () => {
    s.isOpen && (s.isOpen = !1, e(gn));
  }, u = () => {
    s.isOpen || (s.isOpen = !0, e(yn));
  };
  de([() => s.isOpen, a], async ([c]) => {
    c ? (await O(), p()) : m();
  });
  const O = async () => {
    var c;
    await Yt(), s.popperInstance = mn(i.value, l.value, {
      placement: a.value,
      modifiers: [
        Bt,
        Lt,
        {
          name: "flip",
          enabled: !r.value
        },
        $t,
        {
          name: "arrow",
          options: {
            padding: ke(t.value)
          }
        },
        Tt,
        {
          name: "offset",
          options: {
            offset: [ke(o.value), ke(n.value)]
          }
        }
      ]
    }), (c = s.popperInstance) == null || c.update();
  };
  return Ve(() => {
    var c;
    (c = s.popperInstance) == null || c.destroy();
  }), {
    ...xt(s),
    open: u,
    close: b
  };
}
function je(t, e, r) {
  var n, o, a, l, i;
  e == null && (e = 100);
  function s() {
    var p = Date.now() - l;
    p < e && p >= 0 ? n = setTimeout(s, e - p) : (n = null, r || (i = t.apply(a, o), a = o = null));
  }
  var f = function() {
    a = this, o = arguments, l = Date.now();
    var p = r && !n;
    return n || (n = setTimeout(s, e)), p && (i = t.apply(a, o), a = o = null), i;
  };
  return f.clear = function() {
    n && (clearTimeout(n), n = null);
  }, f.flush = function() {
    n && (i = t.apply(a, o), a = o = null, clearTimeout(n), n = null);
  }, f;
}
je.debounce = je;
var Ie = je, mt;
const De = typeof window < "u";
De && ((mt = window == null ? void 0 : window.navigator) != null && mt.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
(function() {
  return De && document && document.addEventListener ? (t, e, r) => {
    t && e && r && t.addEventListener(e, r, !1);
  } : (t, e, r) => {
    t && e && r && t.attachEvent("on" + e, r);
  };
})();
(function() {
  return De && document && document.removeEventListener ? function(t, e, r) {
    t && e && t.removeEventListener(e, r, !1);
  } : function(t, e, r) {
    t && e && t.detachEvent("on" + e, r);
  };
})();
De && function(t, e, r) {
  !t.composedPath && r && (t.composedPath = function() {
    if (this.path)
      return this.path;
    let n = this.target;
    for (this.path = []; n.parentNode !== null; )
      this.path.push(n), n = n.parentNode;
    return this.path.push(e, r), this.path;
  }), String.prototype.startsWith || Object.defineProperty(String.prototype, "startsWith", {
    value: function(n, o) {
      return o = !o || o < 0 ? 0 : +o, this.substring(o, o + n.length) === n;
    }
  });
}(Event.prototype, document, window);
let wn = {
  addIconList: [],
  removeIconList: [],
  zIndex: 3e3
};
function On(t, e) {
  return wn[t] || e;
}
const gt = Q(0), xn = () => {
  const t = Q(On("zIndex", 3e3)), e = ne(() => t.value + gt.value);
  return {
    initialZIndex: t,
    currentZIndex: e,
    nextZIndex: () => (gt.value++, e.value)
  };
}, En = bt({
  name: "e-popover",
  components: {
    eArrow: sr
  },
  props: {
    placement: {
      type: String,
      default: "bottom",
      validator: (t) => [
        "auto",
        "auto-start",
        "auto-end",
        "top",
        "top-start",
        "top-end",
        "bottom",
        "bottom-start",
        "bottom-end",
        "right",
        "right-start",
        "right-end",
        "left",
        "left-start",
        "left-end"
      ].includes(t)
    },
    disableClickAway: {
      type: Boolean,
      default: !1
    },
    offsetSkid: {
      type: String,
      default: "0"
    },
    offsetDistance: {
      type: String,
      default: "12"
    },
    hover: {
      type: Boolean,
      default: !1
    },
    show: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    openDelay: {
      type: [Number],
      default: 0
    },
    closeDelay: {
      type: [Number],
      default: 0
    },
    zIndex: {
      type: [Number],
      default: 0
    },
    arrow: {
      type: Boolean,
      default: !1
    },
    arrowPadding: {
      type: String,
      default: "0"
    },
    interactive: {
      type: Boolean,
      default: !0
    },
    locked: {
      type: Boolean,
      default: !1
    },
    content: {
      type: String,
      default: null
    },
    height: {
      type: Number,
      default: 200
    },
    maxHeight: {
      type: Number,
      default: 400
    },
    width: {
      type: Number,
      default: 500
    },
    maxWidth: {
      type: Number,
      default: 800
    },
    container: {
      type: String,
      default: "body"
    },
    appendContainer: {
      type: Boolean,
      default: !1
    },
    contentClass: {
      type: String,
      default: ""
    },
    display: {
      type: String,
      default: "block"
    }
  },
  setup(t, { slots: e, attrs: r, emit: n }) {
    const o = Q(null), a = Q(null), l = Q(null), i = Q(!1), { nextZIndex: s } = xn();
    let f = t.zIndex || s();
    Me(() => {
      var X;
      const T = ((X = e.default) == null ? void 0 : X.call(e)) ?? [];
      if (T && T.length > 1)
        return console.error(
          `[Popper]: The <Popper> component expects only one child element at its root. You passed ${T.length} child nodes.`
        );
    });
    const {
      arrowPadding: p,
      closeDelay: m,
      content: b,
      disableClickAway: u,
      disabled: O,
      interactive: c,
      locked: v,
      offsetDistance: y,
      offsetSkid: A,
      openDelay: P,
      placement: h,
      show: g
    } = xt(t), { isOpen: d, open: x, close: S } = bn({
      arrowPadding: p,
      emit: n,
      locked: v,
      offsetDistance: y,
      offsetSkid: A,
      placement: h,
      popperNode: a,
      triggerNode: l
    }), { hasContent: D } = fr(e, a, b), E = ne(() => g.value !== null), w = ne(() => O.value || !D.value), C = ne(() => d.value && !w.value), N = ne(() => !u.value && !E.value), z = ne(
      () => c.value ? `border: ${y.value}px solid transparent; margin: -${y.value}px;` : null
    ), V = Ie.debounce(x, P.value), R = Ie.debounce(S, m.value), $ = async () => {
      w.value || E.value || (f = t.zIndex || s(), R.clear(), V());
    }, Y = async () => {
      E.value || (V.clear(), R());
    }, F = () => {
      d.value ? Y() : $();
    };
    return de([D, O], ([T, X]) => {
      d.value && (!T || X) && S();
    }), de(d, (T) => {
      T ? (f = t.zIndex, i.value = !0) : Ie.debounce(() => {
        i.value = !1;
      }, 200);
    }), tt(() => {
      E.value && (g.value ? V() : R());
    }), tt(() => {
      N.value && lr(o, Y);
    }), {
      interactiveStyle: z,
      closePopper: Y,
      openPopper: $,
      togglePopper: F,
      popperContainerNode: o,
      triggerNode: l,
      shouldShowPopper: C,
      popperNode: a,
      modifiedIsOpen: i,
      close: S,
      zIndex: f
    };
  }
});
function Pn(t, e, r, n, o, a) {
  const l = Xt("e-arrow");
  return xe(), wt("div", {
    class: "e-popover",
    style: $e(t.interactiveStyle),
    onMouseleave: e[5] || (e[5] = (i) => t.hover && t.closePopper()),
    ref: "popperContainerNode"
  }, [
    rt("div", {
      ref: "triggerNode",
      style: $e({ display: t.display }),
      onMouseover: e[0] || (e[0] = (i) => t.hover && t.openPopper()),
      onClick: e[1] || (e[1] = (...i) => t.togglePopper && t.togglePopper(...i)),
      onFocus: e[2] || (e[2] = (...i) => t.openPopper && t.openPopper(...i)),
      onKeyup: e[3] || (e[3] = Ut((...i) => t.closePopper && t.closePopper(...i), ["esc"]))
    }, [
      nt(t.$slots, "default")
    ], 36),
    (xe(), ot(Zt, {
      to: t.container,
      disabled: !t.appendContainer
    }, [
      _t(Gt, { name: "fade" }, {
        default: Kt(() => [
          Jt(rt("div", {
            onClick: e[4] || (e[4] = (i) => !t.interactive && t.closePopper()),
            class: Qt(["popper", t.contentClass]),
            ref: "popperNode",
            style: $e({ zIndex: t.zIndex, width: `${t.width}px`, height: `${t.height}px`, maxHeight: `${t.maxHeight}px`, maxWidth: `${t.maxWidth}px` })
          }, [
            nt(t.$slots, "content", {
              close: t.close,
              isOpen: t.modifiedIsOpen
            }, () => [
              er(tr(t.content), 1)
            ]),
            t.arrow ? (xe(), ot(l, { key: 0 })) : rr("", !0)
          ], 6), [
            [nr, t.shouldShowPopper]
          ])
        ]),
        _: 3
      })
    ], 8, ["to", "disabled"]))
  ], 36);
}
const yt = /* @__PURE__ */ Et(En, [["render", Pn]]), An = {
  install(t) {
    t.component(yt.name, yt);
  }
};
export {
  An as default,
  sr as eArrow,
  yt as ePopover
};
