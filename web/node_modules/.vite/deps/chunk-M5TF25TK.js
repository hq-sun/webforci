import {
  useRoute
} from "./chunk-4QBCRV47.js";
import {
  R,
  d
} from "./chunk-5SHNTQUO.js";
import {
  require_dayjs_min
} from "./chunk-F73GDDKZ.js";
import {
  cloneDeep_default,
  isArray_default,
  lodash_default_default
} from "./chunk-LK7GAOJV.js";
import {
  Fragment,
  TransitionGroup,
  computed,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createSlots,
  createTextVNode,
  createVNode,
  defineAsyncComponent,
  defineComponent,
  getCurrentInstance,
  guardReactiveProps,
  h,
  inject,
  isRef,
  isShallow,
  isVNode,
  markRaw,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onMounted,
  openBlock,
  provide,
  reactive,
  ref,
  render,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDirective,
  resolveDynamicComponent,
  shallowReactive,
  shallowRef,
  toDisplayString,
  toHandlerKey,
  toRaw,
  toRef,
  unref,
  useAttrs,
  useSlots,
  vShow,
  watch,
  withCtx,
  withDirectives,
  withModifiers
} from "./chunk-7PYUCYS5.js";
import {
  __toESM
} from "./chunk-PLDDJCW6.js";

// node_modules/@iconify/vue/dist/iconify.mjs
var matchIconName = /^[a-z0-9]+(-[a-z0-9]+)*$/;
var stringToIcon = (value, validate, allowSimpleName, provider = "") => {
  const colonSeparated = value.split(":");
  if (value.slice(0, 1) === "@") {
    if (colonSeparated.length < 2 || colonSeparated.length > 3) {
      return null;
    }
    provider = colonSeparated.shift().slice(1);
  }
  if (colonSeparated.length > 3 || !colonSeparated.length) {
    return null;
  }
  if (colonSeparated.length > 1) {
    const name2 = colonSeparated.pop();
    const prefix = colonSeparated.pop();
    const result = {
      // Allow provider without '@': "provider:prefix:name"
      provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,
      prefix,
      name: name2
    };
    return validate && !validateIconName(result) ? null : result;
  }
  const name = colonSeparated[0];
  const dashSeparated = name.split("-");
  if (dashSeparated.length > 1) {
    const result = {
      provider,
      prefix: dashSeparated.shift(),
      name: dashSeparated.join("-")
    };
    return validate && !validateIconName(result) ? null : result;
  }
  if (allowSimpleName && provider === "") {
    const result = {
      provider,
      prefix: "",
      name
    };
    return validate && !validateIconName(result, allowSimpleName) ? null : result;
  }
  return null;
};
var validateIconName = (icon, allowSimpleName) => {
  if (!icon) {
    return false;
  }
  return !!((icon.provider === "" || icon.provider.match(matchIconName)) && (allowSimpleName && icon.prefix === "" || icon.prefix.match(matchIconName)) && icon.name.match(matchIconName));
};
var defaultIconDimensions = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
);
var defaultIconTransformations = Object.freeze({
  rotate: 0,
  vFlip: false,
  hFlip: false
});
var defaultIconProps = Object.freeze({
  ...defaultIconDimensions,
  ...defaultIconTransformations
});
var defaultExtendedIconProps = Object.freeze({
  ...defaultIconProps,
  body: "",
  hidden: false
});
function mergeIconTransformations(obj1, obj2) {
  const result = {};
  if (!obj1.hFlip !== !obj2.hFlip) {
    result.hFlip = true;
  }
  if (!obj1.vFlip !== !obj2.vFlip) {
    result.vFlip = true;
  }
  const rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;
  if (rotate) {
    result.rotate = rotate;
  }
  return result;
}
function mergeIconData(parent, child) {
  const result = mergeIconTransformations(parent, child);
  for (const key in defaultExtendedIconProps) {
    if (key in defaultIconTransformations) {
      if (key in parent && !(key in result)) {
        result[key] = defaultIconTransformations[key];
      }
    } else if (key in child) {
      result[key] = child[key];
    } else if (key in parent) {
      result[key] = parent[key];
    }
  }
  return result;
}
function getIconsTree(data, names) {
  const icons = data.icons;
  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
  const resolved = /* @__PURE__ */ Object.create(null);
  function resolve(name) {
    if (icons[name]) {
      return resolved[name] = [];
    }
    if (!(name in resolved)) {
      resolved[name] = null;
      const parent = aliases[name] && aliases[name].parent;
      const value = parent && resolve(parent);
      if (value) {
        resolved[name] = [parent].concat(value);
      }
    }
    return resolved[name];
  }
  (names || Object.keys(icons).concat(Object.keys(aliases))).forEach(resolve);
  return resolved;
}
function internalGetIconData(data, name, tree) {
  const icons = data.icons;
  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
  let currentProps = {};
  function parse(name2) {
    currentProps = mergeIconData(
      icons[name2] || aliases[name2],
      currentProps
    );
  }
  parse(name);
  tree.forEach(parse);
  return mergeIconData(data, currentProps);
}
function parseIconSet(data, callback) {
  const names = [];
  if (typeof data !== "object" || typeof data.icons !== "object") {
    return names;
  }
  if (data.not_found instanceof Array) {
    data.not_found.forEach((name) => {
      callback(name, null);
      names.push(name);
    });
  }
  const tree = getIconsTree(data);
  for (const name in tree) {
    const item2 = tree[name];
    if (item2) {
      callback(name, internalGetIconData(data, name, item2));
      names.push(name);
    }
  }
  return names;
}
var optionalPropertyDefaults = {
  provider: "",
  aliases: {},
  not_found: {},
  ...defaultIconDimensions
};
function checkOptionalProps(item2, defaults) {
  for (const prop in defaults) {
    if (prop in item2 && typeof item2[prop] !== typeof defaults[prop]) {
      return false;
    }
  }
  return true;
}
function quicklyValidateIconSet(obj) {
  if (typeof obj !== "object" || obj === null) {
    return null;
  }
  const data = obj;
  if (typeof data.prefix !== "string" || !obj.icons || typeof obj.icons !== "object") {
    return null;
  }
  if (!checkOptionalProps(obj, optionalPropertyDefaults)) {
    return null;
  }
  const icons = data.icons;
  for (const name in icons) {
    const icon = icons[name];
    if (!name.match(matchIconName) || typeof icon.body !== "string" || !checkOptionalProps(
      icon,
      defaultExtendedIconProps
    )) {
      return null;
    }
  }
  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
  for (const name in aliases) {
    const icon = aliases[name];
    const parent = icon.parent;
    if (!name.match(matchIconName) || typeof parent !== "string" || !icons[parent] && !aliases[parent] || !checkOptionalProps(
      icon,
      defaultExtendedIconProps
    )) {
      return null;
    }
  }
  return data;
}
var dataStorage = /* @__PURE__ */ Object.create(null);
function newStorage(provider, prefix) {
  return {
    provider,
    prefix,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ new Set()
  };
}
function getStorage(provider, prefix) {
  const providerStorage = dataStorage[provider] || (dataStorage[provider] = /* @__PURE__ */ Object.create(null));
  return providerStorage[prefix] || (providerStorage[prefix] = newStorage(provider, prefix));
}
function addIconSet(storage2, data) {
  if (!quicklyValidateIconSet(data)) {
    return [];
  }
  return parseIconSet(data, (name, icon) => {
    if (icon) {
      storage2.icons[name] = icon;
    } else {
      storage2.missing.add(name);
    }
  });
}
function addIconToStorage(storage2, name, icon) {
  try {
    if (typeof icon.body === "string") {
      storage2.icons[name] = { ...icon };
      return true;
    }
  } catch (err) {
  }
  return false;
}
var simpleNames = false;
function allowSimpleNames(allow) {
  if (typeof allow === "boolean") {
    simpleNames = allow;
  }
  return simpleNames;
}
function getIconData(name) {
  const icon = typeof name === "string" ? stringToIcon(name, true, simpleNames) : name;
  if (icon) {
    const storage2 = getStorage(icon.provider, icon.prefix);
    const iconName = icon.name;
    return storage2.icons[iconName] || (storage2.missing.has(iconName) ? null : void 0);
  }
}
function addIcon(name, data) {
  const icon = stringToIcon(name, true, simpleNames);
  if (!icon) {
    return false;
  }
  const storage2 = getStorage(icon.provider, icon.prefix);
  return addIconToStorage(storage2, icon.name, data);
}
function addCollection(data, provider) {
  if (typeof data !== "object") {
    return false;
  }
  if (typeof provider !== "string") {
    provider = data.provider || "";
  }
  if (simpleNames && !provider && !data.prefix) {
    let added = false;
    if (quicklyValidateIconSet(data)) {
      data.prefix = "";
      parseIconSet(data, (name, icon) => {
        if (icon && addIcon(name, icon)) {
          added = true;
        }
      });
    }
    return added;
  }
  const prefix = data.prefix;
  if (!validateIconName({
    provider,
    prefix,
    name: "a"
  })) {
    return false;
  }
  const storage2 = getStorage(provider, prefix);
  return !!addIconSet(storage2, data);
}
var defaultIconSizeCustomisations = Object.freeze({
  width: null,
  height: null
});
var defaultIconCustomisations = Object.freeze({
  // Dimensions
  ...defaultIconSizeCustomisations,
  // Transformations
  ...defaultIconTransformations
});
var unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
var unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function calculateSize(size, ratio, precision) {
  if (ratio === 1) {
    return size;
  }
  precision = precision || 100;
  if (typeof size === "number") {
    return Math.ceil(size * ratio * precision) / precision;
  }
  if (typeof size !== "string") {
    return size;
  }
  const oldParts = size.split(unitsSplit);
  if (oldParts === null || !oldParts.length) {
    return size;
  }
  const newParts = [];
  let code = oldParts.shift();
  let isNumber = unitsTest.test(code);
  while (true) {
    if (isNumber) {
      const num = parseFloat(code);
      if (isNaN(num)) {
        newParts.push(code);
      } else {
        newParts.push(Math.ceil(num * ratio * precision) / precision);
      }
    } else {
      newParts.push(code);
    }
    code = oldParts.shift();
    if (code === void 0) {
      return newParts.join("");
    }
    isNumber = !isNumber;
  }
}
function splitSVGDefs(content, tag = "defs") {
  let defs = "";
  const index = content.indexOf("<" + tag);
  while (index >= 0) {
    const start = content.indexOf(">", index);
    const end = content.indexOf("</" + tag);
    if (start === -1 || end === -1) {
      break;
    }
    const endEnd = content.indexOf(">", end);
    if (endEnd === -1) {
      break;
    }
    defs += content.slice(start + 1, end).trim();
    content = content.slice(0, index).trim() + content.slice(endEnd + 1);
  }
  return {
    defs,
    content
  };
}
function mergeDefsAndContent(defs, content) {
  return defs ? "<defs>" + defs + "</defs>" + content : content;
}
function wrapSVGContent(body, start, end) {
  const split = splitSVGDefs(body);
  return mergeDefsAndContent(split.defs, start + split.content + end);
}
var isUnsetKeyword = (value) => value === "unset" || value === "undefined" || value === "none";
function iconToSVG(icon, customisations) {
  const fullIcon = {
    ...defaultIconProps,
    ...icon
  };
  const fullCustomisations = {
    ...defaultIconCustomisations,
    ...customisations
  };
  const box = {
    left: fullIcon.left,
    top: fullIcon.top,
    width: fullIcon.width,
    height: fullIcon.height
  };
  let body = fullIcon.body;
  [fullIcon, fullCustomisations].forEach((props) => {
    const transformations = [];
    const hFlip = props.hFlip;
    const vFlip = props.vFlip;
    let rotation = props.rotate;
    if (hFlip) {
      if (vFlip) {
        rotation += 2;
      } else {
        transformations.push(
          "translate(" + (box.width + box.left).toString() + " " + (0 - box.top).toString() + ")"
        );
        transformations.push("scale(-1 1)");
        box.top = box.left = 0;
      }
    } else if (vFlip) {
      transformations.push(
        "translate(" + (0 - box.left).toString() + " " + (box.height + box.top).toString() + ")"
      );
      transformations.push("scale(1 -1)");
      box.top = box.left = 0;
    }
    let tempValue;
    if (rotation < 0) {
      rotation -= Math.floor(rotation / 4) * 4;
    }
    rotation = rotation % 4;
    switch (rotation) {
      case 1:
        tempValue = box.height / 2 + box.top;
        transformations.unshift(
          "rotate(90 " + tempValue.toString() + " " + tempValue.toString() + ")"
        );
        break;
      case 2:
        transformations.unshift(
          "rotate(180 " + (box.width / 2 + box.left).toString() + " " + (box.height / 2 + box.top).toString() + ")"
        );
        break;
      case 3:
        tempValue = box.width / 2 + box.left;
        transformations.unshift(
          "rotate(-90 " + tempValue.toString() + " " + tempValue.toString() + ")"
        );
        break;
    }
    if (rotation % 2 === 1) {
      if (box.left !== box.top) {
        tempValue = box.left;
        box.left = box.top;
        box.top = tempValue;
      }
      if (box.width !== box.height) {
        tempValue = box.width;
        box.width = box.height;
        box.height = tempValue;
      }
    }
    if (transformations.length) {
      body = wrapSVGContent(
        body,
        '<g transform="' + transformations.join(" ") + '">',
        "</g>"
      );
    }
  });
  const customisationsWidth = fullCustomisations.width;
  const customisationsHeight = fullCustomisations.height;
  const boxWidth = box.width;
  const boxHeight = box.height;
  let width;
  let height;
  if (customisationsWidth === null) {
    height = customisationsHeight === null ? "1em" : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
    width = calculateSize(height, boxWidth / boxHeight);
  } else {
    width = customisationsWidth === "auto" ? boxWidth : customisationsWidth;
    height = customisationsHeight === null ? calculateSize(width, boxHeight / boxWidth) : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
  }
  const attributes = {};
  const setAttr = (prop, value) => {
    if (!isUnsetKeyword(value)) {
      attributes[prop] = value.toString();
    }
  };
  setAttr("width", width);
  setAttr("height", height);
  const viewBox = [box.left, box.top, boxWidth, boxHeight];
  attributes.viewBox = viewBox.join(" ");
  return {
    attributes,
    viewBox,
    body
  };
}
var regex = /\sid="(\S+)"/g;
var randomPrefix = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
var counter = 0;
function replaceIDs(body, prefix = randomPrefix) {
  const ids = [];
  let match;
  while (match = regex.exec(body)) {
    ids.push(match[1]);
  }
  if (!ids.length) {
    return body;
  }
  const suffix = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  ids.forEach((id2) => {
    const newID = typeof prefix === "function" ? prefix(id2) : prefix + (counter++).toString();
    const escapedID = id2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    body = body.replace(
      // Allowed characters before id: [#;"]
      // Allowed characters after id: [)"], .[a-z]
      new RegExp('([#;"])(' + escapedID + ')([")]|\\.[a-z])', "g"),
      "$1" + newID + suffix + "$3"
    );
  });
  body = body.replace(new RegExp(suffix, "g"), "");
  return body;
}
var storage = /* @__PURE__ */ Object.create(null);
function setAPIModule(provider, item2) {
  storage[provider] = item2;
}
function getAPIModule(provider) {
  return storage[provider] || storage[""];
}
function createAPIConfig(source) {
  let resources;
  if (typeof source.resources === "string") {
    resources = [source.resources];
  } else {
    resources = source.resources;
    if (!(resources instanceof Array) || !resources.length) {
      return null;
    }
  }
  const result = {
    // API hosts
    resources,
    // Root path
    path: source.path || "/",
    // URL length limit
    maxURL: source.maxURL || 500,
    // Timeout before next host is used.
    rotate: source.rotate || 750,
    // Timeout before failing query.
    timeout: source.timeout || 5e3,
    // Randomise default API end point.
    random: source.random === true,
    // Start index
    index: source.index || 0,
    // Receive data after time out (used if time out kicks in first, then API module sends data anyway).
    dataAfterTimeout: source.dataAfterTimeout !== false
  };
  return result;
}
var configStorage = /* @__PURE__ */ Object.create(null);
var fallBackAPISources = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
];
var fallBackAPI = [];
while (fallBackAPISources.length > 0) {
  if (fallBackAPISources.length === 1) {
    fallBackAPI.push(fallBackAPISources.shift());
  } else {
    if (Math.random() > 0.5) {
      fallBackAPI.push(fallBackAPISources.shift());
    } else {
      fallBackAPI.push(fallBackAPISources.pop());
    }
  }
}
configStorage[""] = createAPIConfig({
  resources: ["https://api.iconify.design"].concat(fallBackAPI)
});
function addAPIProvider(provider, customConfig) {
  const config2 = createAPIConfig(customConfig);
  if (config2 === null) {
    return false;
  }
  configStorage[provider] = config2;
  return true;
}
function getAPIConfig(provider) {
  return configStorage[provider];
}
var detectFetch = () => {
  let callback;
  try {
    callback = fetch;
    if (typeof callback === "function") {
      return callback;
    }
  } catch (err) {
  }
};
var fetchModule = detectFetch();
function calculateMaxLength(provider, prefix) {
  const config2 = getAPIConfig(provider);
  if (!config2) {
    return 0;
  }
  let result;
  if (!config2.maxURL) {
    result = 0;
  } else {
    let maxHostLength = 0;
    config2.resources.forEach((item2) => {
      const host = item2;
      maxHostLength = Math.max(maxHostLength, host.length);
    });
    const url = prefix + ".json?icons=";
    result = config2.maxURL - maxHostLength - config2.path.length - url.length;
  }
  return result;
}
function shouldAbort(status) {
  return status === 404;
}
var prepare = (provider, prefix, icons) => {
  const results = [];
  const maxLength = calculateMaxLength(provider, prefix);
  const type = "icons";
  let item2 = {
    type,
    provider,
    prefix,
    icons: []
  };
  let length = 0;
  icons.forEach((name, index) => {
    length += name.length + 1;
    if (length >= maxLength && index > 0) {
      results.push(item2);
      item2 = {
        type,
        provider,
        prefix,
        icons: []
      };
      length = name.length;
    }
    item2.icons.push(name);
  });
  results.push(item2);
  return results;
};
function getPath(provider) {
  if (typeof provider === "string") {
    const config2 = getAPIConfig(provider);
    if (config2) {
      return config2.path;
    }
  }
  return "/";
}
var send = (host, params, callback) => {
  if (!fetchModule) {
    callback("abort", 424);
    return;
  }
  let path = getPath(params.provider);
  switch (params.type) {
    case "icons": {
      const prefix = params.prefix;
      const icons = params.icons;
      const iconsList = icons.join(",");
      const urlParams = new URLSearchParams({
        icons: iconsList
      });
      path += prefix + ".json?" + urlParams.toString();
      break;
    }
    case "custom": {
      const uri = params.uri;
      path += uri.slice(0, 1) === "/" ? uri.slice(1) : uri;
      break;
    }
    default:
      callback("abort", 400);
      return;
  }
  let defaultError = 503;
  fetchModule(host + path).then((response) => {
    const status = response.status;
    if (status !== 200) {
      setTimeout(() => {
        callback(shouldAbort(status) ? "abort" : "next", status);
      });
      return;
    }
    defaultError = 501;
    return response.json();
  }).then((data) => {
    if (typeof data !== "object" || data === null) {
      setTimeout(() => {
        if (data === 404) {
          callback("abort", data);
        } else {
          callback("next", defaultError);
        }
      });
      return;
    }
    setTimeout(() => {
      callback("success", data);
    });
  }).catch(() => {
    callback("next", defaultError);
  });
};
var fetchAPIModule = {
  prepare,
  send
};
function sortIcons(icons) {
  const result = {
    loaded: [],
    missing: [],
    pending: []
  };
  const storage2 = /* @__PURE__ */ Object.create(null);
  icons.sort((a, b) => {
    if (a.provider !== b.provider) {
      return a.provider.localeCompare(b.provider);
    }
    if (a.prefix !== b.prefix) {
      return a.prefix.localeCompare(b.prefix);
    }
    return a.name.localeCompare(b.name);
  });
  let lastIcon = {
    provider: "",
    prefix: "",
    name: ""
  };
  icons.forEach((icon) => {
    if (lastIcon.name === icon.name && lastIcon.prefix === icon.prefix && lastIcon.provider === icon.provider) {
      return;
    }
    lastIcon = icon;
    const provider = icon.provider;
    const prefix = icon.prefix;
    const name = icon.name;
    const providerStorage = storage2[provider] || (storage2[provider] = /* @__PURE__ */ Object.create(null));
    const localStorage2 = providerStorage[prefix] || (providerStorage[prefix] = getStorage(provider, prefix));
    let list;
    if (name in localStorage2.icons) {
      list = result.loaded;
    } else if (prefix === "" || localStorage2.missing.has(name)) {
      list = result.missing;
    } else {
      list = result.pending;
    }
    const item2 = {
      provider,
      prefix,
      name
    };
    list.push(item2);
  });
  return result;
}
function removeCallback(storages, id2) {
  storages.forEach((storage2) => {
    const items = storage2.loaderCallbacks;
    if (items) {
      storage2.loaderCallbacks = items.filter((row) => row.id !== id2);
    }
  });
}
function updateCallbacks(storage2) {
  if (!storage2.pendingCallbacksFlag) {
    storage2.pendingCallbacksFlag = true;
    setTimeout(() => {
      storage2.pendingCallbacksFlag = false;
      const items = storage2.loaderCallbacks ? storage2.loaderCallbacks.slice(0) : [];
      if (!items.length) {
        return;
      }
      let hasPending = false;
      const provider = storage2.provider;
      const prefix = storage2.prefix;
      items.forEach((item2) => {
        const icons = item2.icons;
        const oldLength = icons.pending.length;
        icons.pending = icons.pending.filter((icon) => {
          if (icon.prefix !== prefix) {
            return true;
          }
          const name = icon.name;
          if (storage2.icons[name]) {
            icons.loaded.push({
              provider,
              prefix,
              name
            });
          } else if (storage2.missing.has(name)) {
            icons.missing.push({
              provider,
              prefix,
              name
            });
          } else {
            hasPending = true;
            return true;
          }
          return false;
        });
        if (icons.pending.length !== oldLength) {
          if (!hasPending) {
            removeCallback([storage2], item2.id);
          }
          item2.callback(
            icons.loaded.slice(0),
            icons.missing.slice(0),
            icons.pending.slice(0),
            item2.abort
          );
        }
      });
    });
  }
}
var idCounter = 0;
function storeCallback(callback, icons, pendingSources) {
  const id2 = idCounter++;
  const abort = removeCallback.bind(null, pendingSources, id2);
  if (!icons.pending.length) {
    return abort;
  }
  const item2 = {
    id: id2,
    icons,
    callback,
    abort
  };
  pendingSources.forEach((storage2) => {
    (storage2.loaderCallbacks || (storage2.loaderCallbacks = [])).push(item2);
  });
  return abort;
}
function listToIcons(list, validate = true, simpleNames2 = false) {
  const result = [];
  list.forEach((item2) => {
    const icon = typeof item2 === "string" ? stringToIcon(item2, validate, simpleNames2) : item2;
    if (icon) {
      result.push(icon);
    }
  });
  return result;
}
var defaultConfig = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: false,
  dataAfterTimeout: false
};
function sendQuery(config2, payload, query, done) {
  const resourcesCount = config2.resources.length;
  const startIndex = config2.random ? Math.floor(Math.random() * resourcesCount) : config2.index;
  let resources;
  if (config2.random) {
    let list = config2.resources.slice(0);
    resources = [];
    while (list.length > 1) {
      const nextIndex = Math.floor(Math.random() * list.length);
      resources.push(list[nextIndex]);
      list = list.slice(0, nextIndex).concat(list.slice(nextIndex + 1));
    }
    resources = resources.concat(list);
  } else {
    resources = config2.resources.slice(startIndex).concat(config2.resources.slice(0, startIndex));
  }
  const startTime = Date.now();
  let status = "pending";
  let queriesSent = 0;
  let lastError;
  let timer = null;
  let queue = [];
  let doneCallbacks = [];
  if (typeof done === "function") {
    doneCallbacks.push(done);
  }
  function resetTimer() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  function abort() {
    if (status === "pending") {
      status = "aborted";
    }
    resetTimer();
    queue.forEach((item2) => {
      if (item2.status === "pending") {
        item2.status = "aborted";
      }
    });
    queue = [];
  }
  function subscribe(callback, overwrite) {
    if (overwrite) {
      doneCallbacks = [];
    }
    if (typeof callback === "function") {
      doneCallbacks.push(callback);
    }
  }
  function getQueryStatus() {
    return {
      startTime,
      payload,
      status,
      queriesSent,
      queriesPending: queue.length,
      subscribe,
      abort
    };
  }
  function failQuery() {
    status = "failed";
    doneCallbacks.forEach((callback) => {
      callback(void 0, lastError);
    });
  }
  function clearQueue() {
    queue.forEach((item2) => {
      if (item2.status === "pending") {
        item2.status = "aborted";
      }
    });
    queue = [];
  }
  function moduleResponse(item2, response, data) {
    const isError = response !== "success";
    queue = queue.filter((queued) => queued !== item2);
    switch (status) {
      case "pending":
        break;
      case "failed":
        if (isError || !config2.dataAfterTimeout) {
          return;
        }
        break;
      default:
        return;
    }
    if (response === "abort") {
      lastError = data;
      failQuery();
      return;
    }
    if (isError) {
      lastError = data;
      if (!queue.length) {
        if (!resources.length) {
          failQuery();
        } else {
          execNext();
        }
      }
      return;
    }
    resetTimer();
    clearQueue();
    if (!config2.random) {
      const index = config2.resources.indexOf(item2.resource);
      if (index !== -1 && index !== config2.index) {
        config2.index = index;
      }
    }
    status = "completed";
    doneCallbacks.forEach((callback) => {
      callback(data);
    });
  }
  function execNext() {
    if (status !== "pending") {
      return;
    }
    resetTimer();
    const resource = resources.shift();
    if (resource === void 0) {
      if (queue.length) {
        timer = setTimeout(() => {
          resetTimer();
          if (status === "pending") {
            clearQueue();
            failQuery();
          }
        }, config2.timeout);
        return;
      }
      failQuery();
      return;
    }
    const item2 = {
      status: "pending",
      resource,
      callback: (status2, data) => {
        moduleResponse(item2, status2, data);
      }
    };
    queue.push(item2);
    queriesSent++;
    timer = setTimeout(execNext, config2.rotate);
    query(resource, payload, item2.callback);
  }
  setTimeout(execNext);
  return getQueryStatus;
}
function initRedundancy(cfg) {
  const config2 = {
    ...defaultConfig,
    ...cfg
  };
  let queries = [];
  function cleanup() {
    queries = queries.filter((item2) => item2().status === "pending");
  }
  function query(payload, queryCallback, doneCallback) {
    const query2 = sendQuery(
      config2,
      payload,
      queryCallback,
      (data, error) => {
        cleanup();
        if (doneCallback) {
          doneCallback(data, error);
        }
      }
    );
    queries.push(query2);
    return query2;
  }
  function find(callback) {
    return queries.find((value) => {
      return callback(value);
    }) || null;
  }
  const instance = {
    query,
    find,
    setIndex: (index) => {
      config2.index = index;
    },
    getIndex: () => config2.index,
    cleanup
  };
  return instance;
}
function emptyCallback$1() {
}
var redundancyCache = /* @__PURE__ */ Object.create(null);
function getRedundancyCache(provider) {
  if (!redundancyCache[provider]) {
    const config2 = getAPIConfig(provider);
    if (!config2) {
      return;
    }
    const redundancy = initRedundancy(config2);
    const cachedReundancy = {
      config: config2,
      redundancy
    };
    redundancyCache[provider] = cachedReundancy;
  }
  return redundancyCache[provider];
}
function sendAPIQuery(target, query, callback) {
  let redundancy;
  let send2;
  if (typeof target === "string") {
    const api = getAPIModule(target);
    if (!api) {
      callback(void 0, 424);
      return emptyCallback$1;
    }
    send2 = api.send;
    const cached = getRedundancyCache(target);
    if (cached) {
      redundancy = cached.redundancy;
    }
  } else {
    const config2 = createAPIConfig(target);
    if (config2) {
      redundancy = initRedundancy(config2);
      const moduleKey = target.resources ? target.resources[0] : "";
      const api = getAPIModule(moduleKey);
      if (api) {
        send2 = api.send;
      }
    }
  }
  if (!redundancy || !send2) {
    callback(void 0, 424);
    return emptyCallback$1;
  }
  return redundancy.query(query, send2, callback)().abort;
}
var browserCacheVersion = "iconify2";
var browserCachePrefix = "iconify";
var browserCacheCountKey = browserCachePrefix + "-count";
var browserCacheVersionKey = browserCachePrefix + "-version";
var browserStorageHour = 36e5;
var browserStorageCacheExpiration = 168;
var browserStorageLimit = 50;
function getStoredItem(func, key) {
  try {
    return func.getItem(key);
  } catch (err) {
  }
}
function setStoredItem(func, key, value) {
  try {
    func.setItem(key, value);
    return true;
  } catch (err) {
  }
}
function removeStoredItem(func, key) {
  try {
    func.removeItem(key);
  } catch (err) {
  }
}
function setBrowserStorageItemsCount(storage2, value) {
  return setStoredItem(storage2, browserCacheCountKey, value.toString());
}
function getBrowserStorageItemsCount(storage2) {
  return parseInt(getStoredItem(storage2, browserCacheCountKey)) || 0;
}
var browserStorageConfig = {
  local: true,
  session: true
};
var browserStorageEmptyItems = {
  local: /* @__PURE__ */ new Set(),
  session: /* @__PURE__ */ new Set()
};
var browserStorageStatus = false;
function setBrowserStorageStatus(status) {
  browserStorageStatus = status;
}
var _window = typeof window === "undefined" ? {} : window;
function getBrowserStorage(key) {
  const attr = key + "Storage";
  try {
    if (_window && _window[attr] && typeof _window[attr].length === "number") {
      return _window[attr];
    }
  } catch (err) {
  }
  browserStorageConfig[key] = false;
}
function iterateBrowserStorage(key, callback) {
  const func = getBrowserStorage(key);
  if (!func) {
    return;
  }
  const version = getStoredItem(func, browserCacheVersionKey);
  if (version !== browserCacheVersion) {
    if (version) {
      const total2 = getBrowserStorageItemsCount(func);
      for (let i = 0; i < total2; i++) {
        removeStoredItem(func, browserCachePrefix + i.toString());
      }
    }
    setStoredItem(func, browserCacheVersionKey, browserCacheVersion);
    setBrowserStorageItemsCount(func, 0);
    return;
  }
  const minTime = Math.floor(Date.now() / browserStorageHour) - browserStorageCacheExpiration;
  const parseItem = (index) => {
    const name = browserCachePrefix + index.toString();
    const item2 = getStoredItem(func, name);
    if (typeof item2 !== "string") {
      return;
    }
    try {
      const data = JSON.parse(item2);
      if (typeof data === "object" && typeof data.cached === "number" && data.cached > minTime && typeof data.provider === "string" && typeof data.data === "object" && typeof data.data.prefix === "string" && // Valid item: run callback
      callback(data, index)) {
        return true;
      }
    } catch (err) {
    }
    removeStoredItem(func, name);
  };
  let total = getBrowserStorageItemsCount(func);
  for (let i = total - 1; i >= 0; i--) {
    if (!parseItem(i)) {
      if (i === total - 1) {
        total--;
        setBrowserStorageItemsCount(func, total);
      } else {
        browserStorageEmptyItems[key].add(i);
      }
    }
  }
}
function initBrowserStorage() {
  if (browserStorageStatus) {
    return;
  }
  setBrowserStorageStatus(true);
  for (const key in browserStorageConfig) {
    iterateBrowserStorage(key, (item2) => {
      const iconSet = item2.data;
      const provider = item2.provider;
      const prefix = iconSet.prefix;
      const storage2 = getStorage(
        provider,
        prefix
      );
      if (!addIconSet(storage2, iconSet).length) {
        return false;
      }
      const lastModified = iconSet.lastModified || -1;
      storage2.lastModifiedCached = storage2.lastModifiedCached ? Math.min(storage2.lastModifiedCached, lastModified) : lastModified;
      return true;
    });
  }
}
function updateLastModified(storage2, lastModified) {
  const lastValue = storage2.lastModifiedCached;
  if (
    // Matches or newer
    lastValue && lastValue >= lastModified
  ) {
    return lastValue === lastModified;
  }
  storage2.lastModifiedCached = lastModified;
  if (lastValue) {
    for (const key in browserStorageConfig) {
      iterateBrowserStorage(key, (item2) => {
        const iconSet = item2.data;
        return item2.provider !== storage2.provider || iconSet.prefix !== storage2.prefix || iconSet.lastModified === lastModified;
      });
    }
  }
  return true;
}
function storeInBrowserStorage(storage2, data) {
  if (!browserStorageStatus) {
    initBrowserStorage();
  }
  function store(key) {
    let func;
    if (!browserStorageConfig[key] || !(func = getBrowserStorage(key))) {
      return;
    }
    const set = browserStorageEmptyItems[key];
    let index;
    if (set.size) {
      set.delete(index = Array.from(set).shift());
    } else {
      index = getBrowserStorageItemsCount(func);
      if (index >= browserStorageLimit || !setBrowserStorageItemsCount(func, index + 1)) {
        return;
      }
    }
    const item2 = {
      cached: Math.floor(Date.now() / browserStorageHour),
      provider: storage2.provider,
      data
    };
    return setStoredItem(
      func,
      browserCachePrefix + index.toString(),
      JSON.stringify(item2)
    );
  }
  if (data.lastModified && !updateLastModified(storage2, data.lastModified)) {
    return;
  }
  if (!Object.keys(data.icons).length) {
    return;
  }
  if (data.not_found) {
    data = Object.assign({}, data);
    delete data.not_found;
  }
  if (!store("local")) {
    store("session");
  }
}
function emptyCallback() {
}
function loadedNewIcons(storage2) {
  if (!storage2.iconsLoaderFlag) {
    storage2.iconsLoaderFlag = true;
    setTimeout(() => {
      storage2.iconsLoaderFlag = false;
      updateCallbacks(storage2);
    });
  }
}
function loadNewIcons(storage2, icons) {
  if (!storage2.iconsToLoad) {
    storage2.iconsToLoad = icons;
  } else {
    storage2.iconsToLoad = storage2.iconsToLoad.concat(icons).sort();
  }
  if (!storage2.iconsQueueFlag) {
    storage2.iconsQueueFlag = true;
    setTimeout(() => {
      storage2.iconsQueueFlag = false;
      const { provider, prefix } = storage2;
      const icons2 = storage2.iconsToLoad;
      delete storage2.iconsToLoad;
      let api;
      if (!icons2 || !(api = getAPIModule(provider))) {
        return;
      }
      const params = api.prepare(provider, prefix, icons2);
      params.forEach((item2) => {
        sendAPIQuery(provider, item2, (data) => {
          if (typeof data !== "object") {
            item2.icons.forEach((name) => {
              storage2.missing.add(name);
            });
          } else {
            try {
              const parsed = addIconSet(
                storage2,
                data
              );
              if (!parsed.length) {
                return;
              }
              const pending = storage2.pendingIcons;
              if (pending) {
                parsed.forEach((name) => {
                  pending.delete(name);
                });
              }
              storeInBrowserStorage(storage2, data);
            } catch (err) {
              console.error(err);
            }
          }
          loadedNewIcons(storage2);
        });
      });
    });
  }
}
var loadIcons = (icons, callback) => {
  const cleanedIcons = listToIcons(icons, true, allowSimpleNames());
  const sortedIcons = sortIcons(cleanedIcons);
  if (!sortedIcons.pending.length) {
    let callCallback = true;
    if (callback) {
      setTimeout(() => {
        if (callCallback) {
          callback(
            sortedIcons.loaded,
            sortedIcons.missing,
            sortedIcons.pending,
            emptyCallback
          );
        }
      });
    }
    return () => {
      callCallback = false;
    };
  }
  const newIcons = /* @__PURE__ */ Object.create(null);
  const sources = [];
  let lastProvider, lastPrefix;
  sortedIcons.pending.forEach((icon) => {
    const { provider, prefix } = icon;
    if (prefix === lastPrefix && provider === lastProvider) {
      return;
    }
    lastProvider = provider;
    lastPrefix = prefix;
    sources.push(getStorage(provider, prefix));
    const providerNewIcons = newIcons[provider] || (newIcons[provider] = /* @__PURE__ */ Object.create(null));
    if (!providerNewIcons[prefix]) {
      providerNewIcons[prefix] = [];
    }
  });
  sortedIcons.pending.forEach((icon) => {
    const { provider, prefix, name } = icon;
    const storage2 = getStorage(provider, prefix);
    const pendingQueue = storage2.pendingIcons || (storage2.pendingIcons = /* @__PURE__ */ new Set());
    if (!pendingQueue.has(name)) {
      pendingQueue.add(name);
      newIcons[provider][prefix].push(name);
    }
  });
  sources.forEach((storage2) => {
    const { provider, prefix } = storage2;
    if (newIcons[provider][prefix].length) {
      loadNewIcons(storage2, newIcons[provider][prefix]);
    }
  });
  return callback ? storeCallback(callback, sortedIcons, sources) : emptyCallback;
};
function mergeCustomisations(defaults, item2) {
  const result = {
    ...defaults
  };
  for (const key in item2) {
    const value = item2[key];
    const valueType = typeof value;
    if (key in defaultIconSizeCustomisations) {
      if (value === null || value && (valueType === "string" || valueType === "number")) {
        result[key] = value;
      }
    } else if (valueType === typeof result[key]) {
      result[key] = key === "rotate" ? value % 4 : value;
    }
  }
  return result;
}
var separator = /[\s,]+/;
function flipFromString(custom, flip) {
  flip.split(separator).forEach((str) => {
    const value = str.trim();
    switch (value) {
      case "horizontal":
        custom.hFlip = true;
        break;
      case "vertical":
        custom.vFlip = true;
        break;
    }
  });
}
function rotateFromString(value, defaultValue = 0) {
  const units = value.replace(/^-?[0-9.]*/, "");
  function cleanup(value2) {
    while (value2 < 0) {
      value2 += 4;
    }
    return value2 % 4;
  }
  if (units === "") {
    const num = parseInt(value);
    return isNaN(num) ? 0 : cleanup(num);
  } else if (units !== value) {
    let split = 0;
    switch (units) {
      case "%":
        split = 25;
        break;
      case "deg":
        split = 90;
    }
    if (split) {
      let num = parseFloat(value.slice(0, value.length - units.length));
      if (isNaN(num)) {
        return 0;
      }
      num = num / split;
      return num % 1 === 0 ? cleanup(num) : 0;
    }
  }
  return defaultValue;
}
function iconToHTML(body, attributes) {
  let renderAttribsHTML = body.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const attr in attributes) {
    renderAttribsHTML += " " + attr + '="' + attributes[attr] + '"';
  }
  return '<svg xmlns="http://www.w3.org/2000/svg"' + renderAttribsHTML + ">" + body + "</svg>";
}
function encodeSVGforURL(svg) {
  return svg.replace(/"/g, "'").replace(/%/g, "%25").replace(/#/g, "%23").replace(/</g, "%3C").replace(/>/g, "%3E").replace(/\s+/g, " ");
}
function svgToData(svg) {
  return "data:image/svg+xml," + encodeSVGforURL(svg);
}
function svgToURL(svg) {
  return 'url("' + svgToData(svg) + '")';
}
var defaultExtendedIconCustomisations = {
  ...defaultIconCustomisations,
  inline: false
};
var svgDefaults = {
  "xmlns": "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  "aria-hidden": true,
  "role": "img"
};
var commonProps = {
  display: "inline-block"
};
var monotoneProps = {
  backgroundColor: "currentColor"
};
var coloredProps = {
  backgroundColor: "transparent"
};
var propsToAdd = {
  Image: "var(--svg)",
  Repeat: "no-repeat",
  Size: "100% 100%"
};
var propsToAddTo = {
  webkitMask: monotoneProps,
  mask: monotoneProps,
  background: coloredProps
};
for (const prefix in propsToAddTo) {
  const list = propsToAddTo[prefix];
  for (const prop in propsToAdd) {
    list[prefix + prop] = propsToAdd[prop];
  }
}
var customisationAliases = {};
["horizontal", "vertical"].forEach((prefix) => {
  const attr = prefix.slice(0, 1) + "Flip";
  customisationAliases[prefix + "-flip"] = attr;
  customisationAliases[prefix.slice(0, 1) + "-flip"] = attr;
  customisationAliases[prefix + "Flip"] = attr;
});
function fixSize(value) {
  return value + (value.match(/^[-0-9.]+$/) ? "px" : "");
}
var render2 = (icon, props) => {
  const customisations = mergeCustomisations(defaultExtendedIconCustomisations, props);
  const componentProps = { ...svgDefaults };
  const mode = props.mode || "svg";
  const style = {};
  const propsStyle = props.style;
  const customStyle = typeof propsStyle === "object" && !(propsStyle instanceof Array) ? propsStyle : {};
  for (let key in props) {
    const value = props[key];
    if (value === void 0) {
      continue;
    }
    switch (key) {
      case "icon":
      case "style":
      case "onLoad":
      case "mode":
        break;
      case "inline":
      case "hFlip":
      case "vFlip":
        customisations[key] = value === true || value === "true" || value === 1;
        break;
      case "flip":
        if (typeof value === "string") {
          flipFromString(customisations, value);
        }
        break;
      case "color":
        style.color = value;
        break;
      case "rotate":
        if (typeof value === "string") {
          customisations[key] = rotateFromString(value);
        } else if (typeof value === "number") {
          customisations[key] = value;
        }
        break;
      case "ariaHidden":
      case "aria-hidden":
        if (value !== true && value !== "true") {
          delete componentProps["aria-hidden"];
        }
        break;
      default: {
        const alias = customisationAliases[key];
        if (alias) {
          if (value === true || value === "true" || value === 1) {
            customisations[alias] = true;
          }
        } else if (defaultExtendedIconCustomisations[key] === void 0) {
          componentProps[key] = value;
        }
      }
    }
  }
  const item2 = iconToSVG(icon, customisations);
  const renderAttribs = item2.attributes;
  if (customisations.inline) {
    style.verticalAlign = "-0.125em";
  }
  if (mode === "svg") {
    componentProps.style = {
      ...style,
      ...customStyle
    };
    Object.assign(componentProps, renderAttribs);
    let localCounter = 0;
    let id2 = props.id;
    if (typeof id2 === "string") {
      id2 = id2.replace(/-/g, "_");
    }
    componentProps["innerHTML"] = replaceIDs(item2.body, id2 ? () => id2 + "ID" + localCounter++ : "iconifyVue");
    return h("svg", componentProps);
  }
  const { body, width, height } = icon;
  const useMask = mode === "mask" || (mode === "bg" ? false : body.indexOf("currentColor") !== -1);
  const html = iconToHTML(body, {
    ...renderAttribs,
    width: width + "",
    height: height + ""
  });
  componentProps.style = {
    ...style,
    "--svg": svgToURL(html),
    "width": fixSize(renderAttribs.width),
    "height": fixSize(renderAttribs.height),
    ...commonProps,
    ...useMask ? monotoneProps : coloredProps,
    ...customStyle
  };
  return h("span", componentProps);
};
allowSimpleNames(true);
setAPIModule("", fetchAPIModule);
if (typeof document !== "undefined" && typeof window !== "undefined") {
  initBrowserStorage();
  const _window2 = window;
  if (_window2.IconifyPreload !== void 0) {
    const preload = _window2.IconifyPreload;
    const err = "Invalid IconifyPreload syntax.";
    if (typeof preload === "object" && preload !== null) {
      (preload instanceof Array ? preload : [preload]).forEach((item2) => {
        try {
          if (
            // Check if item is an object and not null/array
            typeof item2 !== "object" || item2 === null || item2 instanceof Array || // Check for 'icons' and 'prefix'
            typeof item2.icons !== "object" || typeof item2.prefix !== "string" || // Add icon set
            !addCollection(item2)
          ) {
            console.error(err);
          }
        } catch (e) {
          console.error(err);
        }
      });
    }
  }
  if (_window2.IconifyProviders !== void 0) {
    const providers = _window2.IconifyProviders;
    if (typeof providers === "object" && providers !== null) {
      for (let key in providers) {
        const err = "IconifyProviders[" + key + "] is invalid.";
        try {
          const value = providers[key];
          if (typeof value !== "object" || !value || value.resources === void 0) {
            continue;
          }
          if (!addAPIProvider(key, value)) {
            console.error(err);
          }
        } catch (e) {
          console.error(err);
        }
      }
    }
  }
}
var emptyIcon = {
  ...defaultIconProps,
  body: ""
};
var Icon = defineComponent({
  // Do not inherit other attributes: it is handled by render()
  inheritAttrs: false,
  // Set initial data
  data() {
    return {
      // Current icon name
      _name: "",
      // Loading
      _loadingIcon: null,
      // Mounted status
      iconMounted: false,
      // Callback counter to trigger re-render
      counter: 0
    };
  },
  mounted() {
    this.iconMounted = true;
  },
  unmounted() {
    this.abortLoading();
  },
  methods: {
    abortLoading() {
      if (this._loadingIcon) {
        this._loadingIcon.abort();
        this._loadingIcon = null;
      }
    },
    // Get data for icon to render or null
    getIcon(icon, onload) {
      if (typeof icon === "object" && icon !== null && typeof icon.body === "string") {
        this._name = "";
        this.abortLoading();
        return {
          data: icon
        };
      }
      let iconName;
      if (typeof icon !== "string" || (iconName = stringToIcon(icon, false, true)) === null) {
        this.abortLoading();
        return null;
      }
      const data = getIconData(iconName);
      if (!data) {
        if (!this._loadingIcon || this._loadingIcon.name !== icon) {
          this.abortLoading();
          this._name = "";
          if (data !== null) {
            this._loadingIcon = {
              name: icon,
              abort: loadIcons([iconName], () => {
                this.counter++;
              })
            };
          }
        }
        return null;
      }
      this.abortLoading();
      if (this._name !== icon) {
        this._name = icon;
        if (onload) {
          onload(icon);
        }
      }
      const classes = ["iconify"];
      if (iconName.prefix !== "") {
        classes.push("iconify--" + iconName.prefix);
      }
      if (iconName.provider !== "") {
        classes.push("iconify--" + iconName.provider);
      }
      return { data, classes };
    }
  },
  // Render icon
  render() {
    this.counter;
    const props = this.$attrs;
    const icon = this.iconMounted || props.ssr ? this.getIcon(props.icon, props.onLoad) : null;
    if (!icon) {
      return render2(emptyIcon, props);
    }
    let newProps = props;
    if (icon.classes) {
      newProps = {
        ...props,
        class: (typeof props["class"] === "string" ? props["class"] + " " : "") + icon.classes.join(" ")
      };
    }
    return render2({
      ...defaultIconProps,
      ...icon.data
    }, newProps);
  }
});

// node_modules/@fast-crud/fast-crud/dist/index-0bad1a5e.mjs
var import_dayjs = __toESM(require_dayjs_min(), 1);
var _i = Object.defineProperty;
var Ci = (e, t, n) => t in e ? _i(e, t, { enumerable: true, configurable: true, writable: true, value: n }) : e[t] = n;
var te = (e, t, n) => (Ci(e, typeof t != "symbol" ? t + "" : t, n), n);
var jo = (e, t, n) => {
  if (!t.has(e))
    throw TypeError("Cannot " + n);
};
var p = (e, t, n) => (jo(e, t, "read from private field"), n ? n.call(e) : t.get(e));
var ve = (e, t, n) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, n);
};
var ue = (e, t, n, o) => (jo(e, t, "write to private field"), o ? o.call(e, n) : t.set(e, n), n);
var no = (e, t, n, o) => ({
  set _(r) {
    ue(e, t, r, n);
  },
  get _() {
    return p(e, t, o);
  }
});
var re = (e, t, n) => (jo(e, t, "access private method"), n);
var Hn = {
  commonOptions(e) {
    return {};
  },
  defaultOptions(e) {
    const { t } = e, n = (r) => computed(() => t(r)), o = d.get();
    return {
      mode: {},
      status: {},
      search: {
        container: {
          is: "fs-search-layout-default",
          collapse: true,
          col: {
            span: 4
          }
        },
        options: {
          ...o.form.inlineLayout,
          // n-form 是否显示校验反馈
          showFeedback: false
        },
        onValidateError({ trigger: r }) {
          r === "search" && o.notification.error({ message: t("fs.search.error.message") });
        },
        collapse: true,
        show: true,
        buttons: {
          search: {
            className: {
              "fs-search-btn-search": true
            },
            icon: o.icons.search
          },
          reset: {
            className: {
              "fs-search-btn-reset": true
            },
            icon: o.icons.refresh
          }
        }
      },
      form: {
        labelPlacement: "left",
        labelPosition: "right",
        labelWidth: "120px",
        style: {
          "grid-template-columns": "50% 50%"
          // grid布局，默认两列
        },
        row: {
          gutter: 10
        },
        col: { span: 12 },
        labelAlign: "right",
        labelCol: { span: 4 },
        wrapperCol: { span: 18 },
        wrapper: {
          is: o.dialog.name,
          ...o.formWrapper.buildWidthBind(o.dialog.name, "960px"),
          ...o.formWrapper.buildInitBind(o.dialog.name),
          draggable: true,
          destroyOnClose: true,
          ...o.dialog.footer(),
          buttons: {
            cancel: {
              text: n("fs.form.cancel"),
              order: 1,
              click: ({ doClose: r }) => {
                r();
              }
            },
            reset: {
              text: n("fs.form.reset"),
              order: 1,
              click: ({ reset: r }) => {
                r();
              }
            },
            ok: {
              text: n("fs.form.ok"),
              order: 1,
              type: "primary",
              click: async ({ submit: r }) => {
                await r();
              }
            }
          }
        }
      },
      addForm: {
        wrapper: {
          title: n("fs.addForm.title")
        }
      },
      editForm: {
        wrapper: {
          title: n("fs.editForm.title")
        }
      },
      viewForm: {
        wrapper: {
          title: n("fs.viewForm.title"),
          buttons: {
            reset: {
              show: false
            },
            cancel: {
              show: false
            }
          }
        }
      },
      rowHandle: {
        width: "250px",
        title: n("fs.rowHandle.title"),
        order: 1e3,
        dropdown: {
          // 操作列折叠
          more: {
            text: null,
            type: "primary",
            icon: o.icons.more
          }
        }
      },
      pagination: {
        background: true,
        pageSize: 20,
        [o.pagination.currentPage]: 1,
        [o.pagination.total]: 1,
        pageSizes: [5, 10, 20, 50],
        layout: "total, sizes, prev, pager, next, jumper",
        showSizeChanger: true,
        showQuickJumper: true,
        showSizePicker: true,
        showTotal: (r) => t("fs.pagination.showTotal", [r])
        //antdv
      },
      table: {
        show: true,
        height: "100%",
        rowKey: o.table.defaultRowKey,
        stripe: true,
        border: true,
        bordered: true,
        singleLine: false,
        scrollTopOnRefreshed: true,
        editable: { enabled: false, rowKey: "$editable_id" },
        pagination: false
        //antdv 关闭默认分页
      },
      toolbar: {
        compact: true,
        buttons: {
          search: {
            className: {
              "fs-toolbar-btn-search": true
            }
          },
          compact: {
            className: {
              "fs-toolbar-btn-compact": true
            }
          },
          refresh: {
            className: {
              "fs-toolbar-btn-refresh": true
            }
          },
          export: {
            className: {
              "fs-toolbar-btn-export": true
            }
          },
          columns: {
            className: {
              "fs-toolbar-btn-columns": true
            }
          }
        }
      },
      actionbar: {
        buttons: {
          add: {
            className: {
              "fs-actionbar-btn-add": true
            },
            type: "primary",
            text: n("fs.actionbar.add")
          }
        }
      }
    };
  }
};
function Mi() {
  var t;
  return (t = new Error().stack) == null ? void 0 : t.split(`
`)[3];
}
var $t = (...e) => {
};
function tr(...e) {
  console.log.apply(this, arguments);
}
function Bi(...e) {
  console.warn.apply(this, arguments);
}
function ji(...e) {
  console.error.apply(this, arguments);
}
var Ni = (...e) => {
  ji("%c [error]", "font-weight: 600;", ...e);
};
var Li = (...e) => {
  Bi("%c [warn]", "font-weight: 600;", ...e);
};
var jr = (...e) => {
  tr("%c [info]", "font-weight: 600;", ...e);
};
var qi = (...e) => {
  if (!console.log)
    return;
  const t = Mi();
  {
    const n = ["%c [debug]", "font-weight: 600;", ...e];
    tr(...n);
    const o = ["%c " + t, "color:#999"];
    tr(...o);
  }
};
var se = {
  debug: $t,
  info: $t,
  warn: $t,
  error: $t,
  log: $t
};
function Hi(e = {}) {
  const t = (e == null ? void 0 : e.level) || "info";
  switch (se.debug = $t, se.info = $t, se.warn = $t, se.error = $t, se.log = $t, t) {
    case "debug":
      se.debug = qi;
    case "info":
      se.info = jr, se.log = jr;
    case "warn":
      se.warn = Li;
    case "error":
      se.error = Ni;
      break;
  }
}
Hi();
function zi(e) {
  return e == null || e === "";
}
function Wi(...e) {
  for (const t of e)
    if (!(t == null || t === ""))
      return false;
  return false;
}
function xi(...e) {
  for (const t of e)
    if (t == null || t === "")
      return true;
  return false;
}
var Sr = {
  isEmpty: zi,
  isAllEmpty: Wi,
  hasEmpty: xi
};
var Ui = {
  // eslint-disable-next-line @typescript-eslint/no-unused-vars,no-unused-vars
  trace(e) {
  }
};
function Fr(e) {
  return defineAsyncComponent({
    loader: e,
    onError(t, n, o, r) {
      console.error("load error", t), t.message.match(/fetch/) && r <= 3 ? n() : o();
    }
  });
}
function Ki(e, t, n, o) {
  const r = Fr(n);
  e.component(t, r, o);
}
function Yi(e, t, n, o, r) {
  const a = Jn(t, o, r);
  lodash_default_default.forEach(a, (i, s) => {
    n && n.indexOf(s) != -1 || Ki(e, s, i, null);
  });
}
function Gi(e, t, n, o, r) {
  const a = Jn(t, o, r);
  lodash_default_default.forEach(a, (i, s) => {
    n && n.indexOf(s) || e.component(s, i.default);
  });
}
function Jn(e, t, n) {
  const o = {};
  return t == null && (t = /.*\/(.+).(vue|jsx|tsx)/), lodash_default_default.forEach(e, (r, a) => {
    const i = a.match(t);
    if ((i == null ? void 0 : i.length) <= 1) {
      console.error(`"${a}" can't pick a component name,this component can't register`);
      return;
    }
    let s = i[1];
    s = lodash_default_default.camelCase(s), s = lodash_default_default.upperFirst(s), n && (r = n(r)), o[s] = r;
  }), o;
}
function Xi(e) {
  const t = Jn(e), n = {};
  return lodash_default_default.forEach(t, (o, r) => {
    n[r] = Fr(o);
  }), n;
}
function Qi(e) {
  const t = Jn(e), n = {};
  return lodash_default_default.forEach(t, (o, r) => {
    n[r] = o.default;
  }), n;
}
var Ji = {
  transformFromGlob: Jn,
  installAsyncComponents: Yi,
  installSyncComponents: Gi,
  createAsyncComponent: Fr,
  loadAsyncComponentFromGlob: Xi,
  loadComponentFromGlob: Qi
};
var va = class {
  constructor(t) {
    te(this, "key");
    te(this, "tableId");
    te(this, "remoteStorage");
    const { $router: n, tableName: o, keyType: r } = t;
    this.key = this.getItemKey(n, r), this.tableId = this.getTableId(o), this.remoteStorage = t.remoteStorage;
  }
  getTableId(t) {
    const n = "fs-crud";
    return t && typeof t == "string" ? n + "." + t : n;
  }
  async getTable() {
    const t = localStorage.getItem(this.tableId);
    if (t != null)
      return JSON.parse(t);
  }
  async saveTable(t) {
    localStorage.setItem(this.tableId, JSON.stringify(t));
  }
  async clearTable() {
    localStorage.removeItem(this.tableId);
  }
  async updateTableValue(t, n = this.key) {
    if (this.remoteStorage) {
      await this.remoteStorage.set(n, t);
      return;
    }
    let o = await this.getTable();
    o == null && (o = {}), o[n] = t, await this.saveTable(o);
  }
  getItemKey(t, n) {
    let o = location.href;
    return t && (o = t.path), n == null || typeof n != "string" || !n ? o : o + "." + n;
  }
  async getTableValue(t = this.key) {
    if (this.remoteStorage)
      return await this.remoteStorage.get(t);
    const n = await this.getTable();
    return n == null ? null : n[t];
  }
  async clearTableValue(t = this.key) {
    if (this.remoteStorage) {
      await this.remoteStorage.remove(t);
      return;
    }
    const n = await this.getTable();
    n != null && (delete n[t], await this.saveTable(n));
  }
};
var Zi = /\D/;
var es = /^[a-zA-Z_$]+([\w_$]*)$/;
var ts = /"/g;
function Nr(...e) {
  return e.reduce((t, n) => t ? !n || n.startsWith("[") ? `${t}${n}` : `${t}.${n}` : n, "");
}
function ba(e) {
  function t(n, ...o) {
    if (o = o.filter((r) => r !== void 0), e.isString(n))
      return Nr(...o, n);
    if (Array.isArray(n))
      return o = Nr(...o), n.reduce((r, a) => {
        const i = typeof a;
        return i === "number" ? a < 0 || a % 1 !== 0 ? `${r}["${a}"]` : `${r}[${a}]` : i !== "string" ? `${r}["${a}"]` : a ? Zi.test(a) ? es.test(a) ? r ? `${r}.${a}` : `${r}${a}` : `${r}["${a.replace(ts, '\\"')}"]` : `${r}[${a}]` : `${r}[""]`;
      }, o);
  }
  return t;
}
ba.notChainable = true;
var ns = /^[a-zA-Z_$]+([\w_$]*)$/;
var os = /"/g;
var ya = Object.prototype.hasOwnProperty;
function rs(e) {
  const t = typeof e;
  return e != null && (t == "object" || t == "function");
}
function as(e) {
  const t = ba(e);
  function n(a) {
    const { options: i, obj: s, callback: l } = a;
    i.pathFormatArray = i.pathFormat == "array", a.depth = 0;
    let u = false;
    const c = () => (u = true, false);
    for (; a && !u; ) {
      if (!a.inited) {
        if (a.inited = true, a.info = qr(a.value, i.ownPropertiesOnly), i.checkCircular && (a.circularParentIndex = -1, a.circularParent = null, a.isCircular = false, a.info.isObject && !a.info.isEmpty)) {
          let d2 = a.parent;
          for (; d2; ) {
            if (d2.value === a.value) {
              a.isCircular = true, a.circularParent = d2, a.circularParentIndex = a.depth - d2.depth - 1;
              break;
            }
            d2 = d2.parent;
          }
        }
        if (a.children = [], i.childrenPath && i.childrenPath.forEach((d2, f) => {
          const h2 = e.get(a.value, d2), b = qr(h2, i.ownPropertiesOnly);
          b.isEmpty || a.children.push([d2, i.strChildrenPath[f], h2, b]);
        }), a.isLeaf = a.isCircular || i.childrenPath !== void 0 && !a.children.length || !a.info.isObject || a.info.isEmpty, a.needCallback = (a.depth || i.includeRoot) && (!i.leavesOnly || a.isLeaf), a.needCallback) {
          const d2 = new Lr(s, i, c);
          d2.setItem(a, false);
          try {
            a.res = l(a.value, a.key, a.parent && a.parent.value, d2);
          } catch (f) {
            throw f.message && (f.message += `
callback failed before deep iterate at:
` + t(a.path)), f;
          }
        }
        if (u)
          break;
        a.res !== false && !u && !a.isCircular && a.info.isObject && (i.childrenPath !== void 0 && (a.depth || !i.rootIsChildren) ? (a.childrenItems = [], a.children.length && a.children.forEach(([d2, f, h2, b]) => {
          a.childrenItems = [
            ...a.childrenItems,
            ...b.isArray ? o(a, h2, i, d2, f) : r(a, h2, i, d2, f)
          ];
        })) : a.childrenItems = a.info.isArray ? o(a, a.value, i, [], "") : r(a, a.value, i, [], "")), a.currentChildIndex = -1;
      }
      if (a.childrenItems && a.currentChildIndex < a.childrenItems.length - 1) {
        a.currentChildIndex++, a.childrenItems[a.currentChildIndex].parentItem = a, a = a.childrenItems[a.currentChildIndex];
        continue;
      }
      if (a.needCallback && i.callbackAfterIterate) {
        const d2 = new Lr(s, i, c);
        d2.setItem(a, true);
        try {
          l(a.value, a.key, a.parent && a.parent.value, d2);
        } catch (f) {
          throw f.message && (f.message += `
callback failed after deep iterate at:
` + t(a.path)), f;
        }
      }
      a = a.parentItem;
    }
  }
  return n;
  function o(a, i, s, l, u) {
    let c;
    s.pathFormatArray || (c = a.strPath || "", u && c && !u.startsWith("[") && (c += "."), c += u || "");
    const d2 = [];
    for (let f = 0; f < i.length; f++) {
      const h2 = i[f];
      if (h2 === void 0 && !(f in i))
        continue;
      let b;
      const m = !s.pathFormatArray;
      m && (b = `${c}[${f}]`), d2.push({
        value: h2,
        key: f + "",
        path: [...a.path || [], ...l, f + ""],
        strPath: b,
        depth: a.depth + 1,
        parent: {
          value: a.value,
          key: a.key,
          path: m ? a.strPath : a.path,
          parent: a.parent,
          depth: a.depth,
          info: a.info
        },
        childrenPath: l.length && l || void 0,
        strChildrenPath: u || void 0
      });
    }
    return d2;
  }
  function r(a, i, s, l, u) {
    let c;
    s.pathFormatArray || (c = a.strPath || "", u && c && !u.startsWith("[") && (c += "."), c += u || "");
    const d2 = [], f = !s.pathFormatArray;
    for (const h2 in i) {
      if (s.ownPropertiesOnly && !ya.call(i, h2))
        continue;
      let b;
      f && (ns.test(h2) ? c ? b = `${c}.${h2}` : b = `${h2}` : b = `${c}["${h2.replace(os, '\\"')}"]`), d2.push({
        value: i[h2],
        key: h2,
        path: [...a.path || [], ...l, h2],
        strPath: b,
        depth: a.depth + 1,
        parent: {
          value: a.value,
          key: a.key,
          path: f ? a.strPath : a.path,
          parent: a.parent,
          depth: a.depth,
          info: a.info
        },
        childrenPath: l.length && l || void 0,
        strChildrenPath: u || void 0
      });
    }
    return d2;
  }
}
var Lr = class {
  constructor(t, n, o) {
    te(this, "_item");
    te(this, "obj");
    te(this, "_options");
    te(this, "afterIterate");
    this.obj = t, this._options = n, this.break = o;
  }
  setItem(t, n) {
    this._item = t, this.afterIterate = n;
  }
  get path() {
    return this._options.pathFormatArray ? this._item.path : this._item.strPath;
  }
  get parent() {
    return this._item.parent;
  }
  get parents() {
    if (!this._item._parents) {
      this._item._parents = [];
      let t = this._item.parent;
      for (; t; )
        this._item._parents[t.depth] = t, t = t.parent;
    }
    return this._item._parents;
  }
  get depth() {
    return this._item.depth;
  }
  get isLeaf() {
    return this._item.isLeaf;
  }
  get isCircular() {
    return this._item.isCircular;
  }
  get circularParentIndex() {
    return this._item.circularParentIndex;
  }
  get circularParent() {
    return this._item.circularParent;
  }
  get childrenPath() {
    return this._options.childrenPath !== void 0 && (this._options.pathFormatArray ? this._item.childrenPath : this._item.strChildrenPath) || void 0;
  }
  get info() {
    return this._item.info;
  }
};
function is(e, t) {
  for (const n in e)
    if (!t || ya.call(e, n))
      return false;
  return true;
}
function qr(e, t) {
  const n = { isObject: rs(e) };
  return n.isArray = n.isObject && Array.isArray(e), n.isEmpty = n.isArray ? !e.length : n.isObject ? is(e, t) : true, n;
}
function ss(e) {
  const t = as(e);
  function n(o, r, a) {
    if (r === void 0 && (r = e.identity), a = e.merge({
      includeRoot: !Array.isArray(o),
      pathFormat: "string",
      checkCircular: false,
      leavesOnly: false,
      ownPropertiesOnly: true
      //
    }, a || {}), a.childrenPath !== void 0) {
      if (!a.includeRoot && a.rootIsChildren === void 0 && (a.rootIsChildren = Array.isArray(o)), !e.isString(a.childrenPath) && !Array.isArray(a.childrenPath))
        throw Error("childrenPath can be string or array");
      e.isString(a.childrenPath) && (a.childrenPath = [a.childrenPath]), a.strChildrenPath = a.childrenPath, a.childrenPath = [];
      for (let i = a.strChildrenPath.length - 1; i >= 0; i--)
        a.childrenPath[i] = e.toPath(a.strChildrenPath[i]);
    }
    return t({
      value: o,
      callback: r,
      options: a,
      obj: o
    }), o;
  }
  return n;
}
var ls = ss(lodash_default_default);
var wa = {
  forEachDeep: ls
};
var us = {
  /**
   * 重构object，但忽略某些字段
   * @param ref
   * @param skips
   */
  omit(e, ...t) {
    const n = Object.keys(e.value), o = {};
    for (const r of n)
      r !== "loading" && (t.indexOf(r) >= 0 || (o[r] = e.value[r]));
    return o;
  }
};
var Ao = {
  logger: se,
  strings: Sr,
  trace: Ui,
  vite: Ji,
  store: va,
  deepdash: wa,
  dash: us
};
function No(e, t) {
  return e.type !== "antdv" ? {} : { labelCol: { span: t }, wrapperCol: { span: 23 - t } };
}
function cs() {
  const { ui: e } = R();
  return {
    colspan: {
      //跨列
      form: {
        col: { span: 24 },
        ...No(e, 2)
      }
    },
    colspan3: {
      //跨列
      form: {
        col: { span: 24 },
        ...No(e, 3)
      }
    },
    colspan4: {
      //跨列
      form: {
        col: { span: 24 },
        ...No(e, 4)
      }
    }
  };
}
var ds = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: cs
}, Symbol.toStringTag, { value: "Module" }));
function fs() {
  const e = d.get();
  return {
    button: {
      form: {
        component: {
          name: e.input.name,
          vModel: e.input.modelValue,
          [e.input.clearable]: true
        }
      },
      column: {
        component: {
          name: "fs-button",
          vModel: "text"
        }
      }
    },
    link: {
      form: {
        component: {
          name: e.input.name,
          vModel: e.input.modelValue,
          [e.input.clearable]: true
        }
      },
      column: {
        component: {
          name: "fs-button",
          vModel: "text",
          ...e.button.linkType
        }
      }
    }
  };
}
var hs = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: fs
}, Symbol.toStringTag, { value: "Module" }));
function ms() {
  const e = d.get();
  return {
    "dict-cascader": {
      search: {
        component: {
          clearable: true
        }
      },
      form: {
        component: {
          name: "fs-dict-cascader",
          vModel: e.cascader.modelValue,
          [e.cascader.clearable]: true
        }
      },
      column: {
        component: { name: "fs-dict-cascader-format" }
      }
    }
  };
}
var ps = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: ms
}, Symbol.toStringTag, { value: "Module" }));
var _a = {
  name: "zh-cn",
  fs: {
    component: {
      select: {
        placeholder: "请选择"
      }
    },
    addForm: { title: "添加" },
    editForm: { title: "编辑" },
    viewForm: { title: "查看" },
    rowHandle: {
      title: "操作",
      remove: {
        text: "删除",
        confirmTitle: "删除提示",
        confirmMessage: "您确定要删除该记录吗?",
        success: "删除成功!"
      },
      copy: {
        text: "复制"
      },
      edit: {
        text: "编辑"
      },
      view: {
        text: "查看"
      }
    },
    form: {
      cancel: "取消",
      ok: "确定",
      reset: "重置",
      saveRemind: {
        title: "提示",
        content: "表单数据有变更，是否保存",
        cancel: "不保存",
        ok: "保存"
      }
    },
    actionbar: { add: "添加" },
    toolbar: {
      columnFilter: {
        title: "列设置",
        fixed: "固定",
        order: "排序",
        reset: "还原",
        confirm: "确定",
        unnamed: "未命名"
      },
      search: { title: "查询显示" },
      refresh: { title: "刷新" },
      compact: { title: "紧凑模式" },
      export: { title: "导出" },
      columns: { title: "列设置" }
    },
    search: {
      container: {
        collapseButton: {
          text: {
            collapse: "收起",
            expand: "展开"
          }
        }
      },
      search: { text: "查询" },
      reset: { text: "重置" },
      error: {
        message: "查询表单校验失败"
      }
    },
    pagination: {
      showTotal: "共 {0} 条"
    },
    date: {
      formatter: { to: "至" }
    },
    extends: {
      tableSelect: {
        view: "查看",
        select: "选择"
      },
      cropper: {
        title: "图片裁剪",
        preview: "预览",
        reChoose: "重新选择",
        flipX: "左右翻转",
        flipY: "上下翻转",
        reset: "重置",
        cancel: "取消",
        confirm: "确定",
        chooseImage: "+ 选择图片",
        onlySupport: "仅支持",
        sizeLimit: "大小不能超过",
        sizeNoLimit: "大小不限制"
      },
      fileUploader: {
        text: "文件上传",
        limitTip: "文件数量不能超过 {0}",
        sizeLimitTip: "文件大小不能超过 {0},当前大小：{1}",
        loadError: "图片加载失败",
        pixelLimitTip: "图片像素尺寸不能超过 宽:{0},高:{1}",
        hasUploading: "还有文件正在上传，请等待上传完成，或删除它"
      }
    }
  }
};
var gs = {
  name: "en",
  fs: {
    component: {
      select: {
        placeholder: "please select"
      }
    },
    addForm: { title: "add" },
    editForm: { title: "edit" },
    viewForm: { title: "view" },
    rowHandle: {
      title: "handle",
      remove: {
        text: "remove",
        confirmTitle: "remove tip",
        confirmMessage: "Are you sure you want to delete this record?",
        success: "delete success!"
      },
      copy: {
        text: "copy"
      },
      edit: {
        text: "edit"
      },
      view: {
        text: "view"
      }
    },
    form: {
      cancel: "cancel",
      ok: "ok",
      reset: "reset",
      saveRemind: {
        title: "save remind",
        content: "The form data has changed, whether to save",
        cancel: "don't save",
        ok: "save"
      }
    },
    actionbar: { add: "add" },
    toolbar: {
      columnFilter: {
        title: "columns set",
        fixed: "fixed",
        order: "sort",
        reset: "reset",
        confirm: "ok",
        unnamed: "unnamed"
      },
      search: { title: "show search bar" },
      refresh: { title: "refresh" },
      compact: { title: "compact mode" },
      export: { title: "export" },
      columns: { title: "columns set" }
    },
    search: {
      container: {
        collapseButton: {
          text: {
            collapse: "collapse",
            expand: "expand"
          }
        }
      },
      search: { text: "search" },
      reset: { text: "reset" },
      error: {
        message: "form valid error"
      }
    },
    pagination: {
      showTotal: "Total {0} items"
    },
    date: { formatter: { to: "to" } },
    extends: {
      tableSelect: {
        view: "view",
        select: "select"
      },
      cropper: {
        title: "image crop",
        preview: "preview",
        reChoose: "reChoose",
        flipX: "flipX",
        flipY: "flipY",
        reset: "reset",
        cancel: "cancel",
        confirm: "confirm",
        chooseImage: "+ choose image",
        onlySupport: "only",
        sizeLimit: "size limit",
        sizeNoLimit: " no limit"
      },
      fileUploader: {
        text: "fileUpload",
        limitTip: "file count limit: {0}",
        sizeLimitTip: "file size limit:  {0}, current size: {1}",
        loadError: "image load error",
        pixelLimitTip: "pixel limit : width:{0},height:{1}",
        hasUploading: "The file is being uploaded, please wait for the upload to complete or delete"
      }
    }
  }
};
function vs(e, t) {
  let n = lodash_default_default.get(_a, e);
  return n == null ? e : t instanceof Array ? (lodash_default_default.forEach(t, (o, r) => {
    n = n.replace("{" + r + "}", o);
  }), n) : n.replace("{n}", t);
}
var bs = class {
  constructor() {
    te(this, "vueI18nInstance", null);
  }
  t(t, n) {
    return vs(t, n);
  }
  setVueI18n(t) {
    if (!t)
      return;
    t.global && (t = t.global);
    const n = t.availableLocales;
    for (const o of n) {
      if (o.startsWith("zh")) {
        const r = t.getLocaleMessage(o), a = lodash_default_default.cloneDeep(r.fs || {});
        t.mergeLocaleMessage(o, { fs: _a.fs }), t.mergeLocaleMessage(o, { fs: a });
      } else if (o.startsWith("en")) {
        const r = t.getLocaleMessage(o), a = lodash_default_default.cloneDeep(r.fs || {});
        t.mergeLocaleMessage(o, { fs: gs.fs }), t.mergeLocaleMessage(o, { fs: a });
      }
      se.debug("i18n", t.getLocaleMessage(o));
    }
    this.vueI18nInstance = t;
  }
};
var co = new bs();
function et() {
  return co.vueI18nInstance != null ? {
    // @ts-ignore
    t: co.vueI18nInstance.t
  } : { t: co.t };
}
var Io = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Vo(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Ca = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Io, function() {
    return function(n, o) {
      var r = o.prototype, a = r.format;
      r.format = function(i) {
        var s = this, l = this.$locale();
        if (!this.isValid())
          return a.bind(this)(i);
        var u = this.$utils(), c = (i || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(d2) {
          switch (d2) {
            case "Q":
              return Math.ceil((s.$M + 1) / 3);
            case "Do":
              return l.ordinal(s.$D);
            case "gggg":
              return s.weekYear();
            case "GGGG":
              return s.isoWeekYear();
            case "wo":
              return l.ordinal(s.week(), "W");
            case "w":
            case "ww":
              return u.s(s.week(), d2 === "w" ? 1 : 2, "0");
            case "W":
            case "WW":
              return u.s(s.isoWeek(), d2 === "W" ? 1 : 2, "0");
            case "k":
            case "kk":
              return u.s(String(s.$H === 0 ? 24 : s.$H), d2 === "k" ? 1 : 2, "0");
            case "X":
              return Math.floor(s.$d.getTime() / 1e3);
            case "x":
              return s.$d.getTime();
            case "z":
              return "[" + s.offsetName() + "]";
            case "zzz":
              return "[" + s.offsetName("long") + "]";
            default:
              return d2;
          }
        });
        return a.bind(this)(c);
      };
    };
  });
})(Ca);
var ys = Ca.exports;
var ws = Vo(ys);
import_dayjs.default.extend(ws);
function Lo(e, t) {
  if (!Sr.isEmpty(e))
    return (0, import_dayjs.default)(e).format(t);
}
function Sa(e, t = "YYYY-MM-DD HH:mm:ss") {
  if (e != null && e instanceof Array && e.length > 1) {
    if (Sr.hasEmpty(e))
      return;
    const { t: n } = et();
    return `${Lo(e[0], t)} ${n("fs.date.formatter.to")} ${Lo(e[1], t)}`;
  }
  return Lo(e, t);
}
function _s(e) {
  const { value: t } = e;
  return Sa(t, "YYYY-MM-DD");
}
function Cs(e) {
  const { value: t } = e;
  return Sa(t, "YYYY-MM-DD HH:mm:ss");
}
var Fa = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Io, function() {
    var n = "week", o = "year";
    return function(r, a, i) {
      var s = a.prototype;
      s.week = function(l) {
        if (l === void 0 && (l = null), l !== null)
          return this.add(7 * (l - this.week()), "day");
        var u = this.$locale().yearStart || 1;
        if (this.month() === 11 && this.date() > 25) {
          var c = i(this).startOf(o).add(1, o).date(u), d2 = i(this).endOf(n);
          if (c.isBefore(d2))
            return 1;
        }
        var f = i(this).startOf(o).date(u).startOf(n).subtract(1, "millisecond"), h2 = this.diff(f, n, true);
        return h2 < 0 ? i(this).startOf("week").week() : Math.ceil(h2);
      }, s.weeks = function(l) {
        return l === void 0 && (l = null), this.week(l);
      };
    };
  });
})(Fa);
var Ss = Fa.exports;
var Fs = Vo(Ss);
var Ra = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Io, function() {
    return function(n, o) {
      o.prototype.weekday = function(r) {
        var a = this.$locale().weekStart || 0, i = this.$W, s = (i < a ? i + 7 : i) - a;
        return this.$utils().u(r) ? s : this.subtract(s, "day").add(r, "day");
      };
    };
  });
})(Ra);
var Rs = Ra.exports;
var Es = Vo(Rs);
var Ea = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Io, function() {
    return function(n, o, r) {
      var a = o.prototype, i = function(d2) {
        return d2 && (d2.indexOf ? d2 : d2.s);
      }, s = function(d2, f, h2, b, m) {
        var _ = d2.name ? d2 : d2.$locale(), y = i(_[f]), E = i(_[h2]), k = y || E.map(function(T) {
          return T.slice(0, b);
        });
        if (!m)
          return k;
        var O = _.weekStart;
        return k.map(function(T, D) {
          return k[(D + (O || 0)) % 7];
        });
      }, l = function() {
        return r.Ls[r.locale()];
      }, u = function(d2, f) {
        return d2.formats[f] || function(h2) {
          return h2.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(b, m, _) {
            return m || _.slice(1);
          });
        }(d2.formats[f.toUpperCase()]);
      }, c = function() {
        var d2 = this;
        return { months: function(f) {
          return f ? f.format("MMMM") : s(d2, "months");
        }, monthsShort: function(f) {
          return f ? f.format("MMM") : s(d2, "monthsShort", "months", 3);
        }, firstDayOfWeek: function() {
          return d2.$locale().weekStart || 0;
        }, weekdays: function(f) {
          return f ? f.format("dddd") : s(d2, "weekdays");
        }, weekdaysMin: function(f) {
          return f ? f.format("dd") : s(d2, "weekdaysMin", "weekdays", 2);
        }, weekdaysShort: function(f) {
          return f ? f.format("ddd") : s(d2, "weekdaysShort", "weekdays", 3);
        }, longDateFormat: function(f) {
          return u(d2.$locale(), f);
        }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
      };
      a.localeData = function() {
        return c.bind(this)();
      }, r.localeData = function() {
        var d2 = l();
        return { firstDayOfWeek: function() {
          return d2.weekStart || 0;
        }, weekdays: function() {
          return r.weekdays();
        }, weekdaysShort: function() {
          return r.weekdaysShort();
        }, weekdaysMin: function() {
          return r.weekdaysMin();
        }, months: function() {
          return r.months();
        }, monthsShort: function() {
          return r.monthsShort();
        }, longDateFormat: function(f) {
          return u(d2, f);
        }, meridiem: d2.meridiem, ordinal: d2.ordinal };
      }, r.months = function() {
        return s(l(), "months");
      }, r.monthsShort = function() {
        return s(l(), "monthsShort", "months", 3);
      }, r.weekdays = function(d2) {
        return s(l(), "weekdays", null, null, d2);
      }, r.weekdaysShort = function(d2) {
        return s(l(), "weekdaysShort", "weekdays", 3, d2);
      }, r.weekdaysMin = function(d2) {
        return s(l(), "weekdaysMin", "weekdays", 2, d2);
      };
    };
  });
})(Ea);
var Ds = Ea.exports;
var ks = Vo(Ds);
import_dayjs.default.extend(Es);
import_dayjs.default.extend(ks);
import_dayjs.default.extend(Fs);
function Os() {
  const e = d.get();
  function t(o) {
    const { row: r, key: a, value: i } = o;
    i != null && (e.type === "naive" ? r[a] = (0, import_dayjs.default)(i).valueOf() : e.type === "antdv" && e.version === "4" || e.type);
  }
  return {
    datetime: {
      form: {
        component: {
          //el-date-picker,a-date-picker
          ...e.datePicker.buildDateType("datetime"),
          vModel: e.datePicker.modelValue
        }
      },
      column: {
        width: 170,
        component: { name: "fs-date-format" }
      },
      valueBuilder(o) {
        t(o);
      }
    },
    date: {
      form: {
        component: {
          //el-date-picker,a-date-picker
          ...e.datePicker.buildDateType("date"),
          vModel: e.datePicker.modelValue
        }
      },
      column: {
        align: "center",
        width: 120,
        component: { name: "fs-date-format", format: "YYYY-MM-DD" }
      },
      valueBuilder(o) {
        t(o);
      }
    },
    daterange: {
      form: {
        component: {
          //el-date-picker,a-date-picker
          ...e.datePicker.buildDateType("daterange"),
          vModel: e.datePicker.modelValue
        }
      },
      column: { width: 210, formatter: _s },
      valueBuilder({ row: o, key: r, value: a }) {
        a != null && Array.isArray(a) && a.length === 2 && a != null && (e.type === "naive" ? o[r] = [(0, import_dayjs.default)(a[0]).valueOf(), (0, import_dayjs.default)(a[1]).valueOf()] : o[r] = [(0, import_dayjs.default)(a[0]), (0, import_dayjs.default)(a[1])]);
      }
    },
    datetimerange: {
      form: {
        component: {
          ...e.datePicker.buildDateType("datetimerange"),
          vModel: e.datePicker.modelValue
        }
      },
      column: {
        width: 340,
        formatter: Cs
      },
      valueBuilder({ row: o, key: r, value: a }) {
        a != null && Array.isArray(a) && a.length === 2 && (e.type === "naive" ? o[r] = [(0, import_dayjs.default)(a[0]).valueOf(), (0, import_dayjs.default)(a[1]).valueOf()] : o[r] = [(0, import_dayjs.default)(a[0]), (0, import_dayjs.default)(a[1])]);
      }
    },
    time: {
      form: {
        component: {
          //el-time-picker,a-time-picker
          name: e.timePicker.name,
          vModel: e.timePicker.modelValue
        }
      },
      column: {
        width: 100,
        align: "center",
        component: { name: "fs-date-format", format: "HH:mm:ss" }
      },
      valueBuilder(o) {
        t(o);
      }
    },
    month: {
      form: {
        component: {
          //el-date-picker,a-date-picker
          ...e.datePicker.buildDateType("month"),
          vModel: e.datePicker.modelValue
        }
      },
      column: {
        align: "center",
        width: 120,
        component: { name: "fs-date-format", format: "YYYY-MM" }
      },
      valueBuilder(o) {
        t(o);
      }
    },
    week: {
      form: {
        component: {
          //el-date-picker,a-date-picker
          ...e.datePicker.buildDateType("week"),
          vModel: e.datePicker.modelValue
        }
      },
      column: {
        align: "center",
        width: 120,
        component: { name: "fs-date-format", format: "YYYY-ww[周]" }
      },
      valueBuilder(o) {
        t(o);
      }
    },
    quarter: {
      form: {
        component: {
          //el-date-picker,a-date-picker
          ...e.datePicker.buildDateType("quarter"),
          vModel: e.datePicker.modelValue
        }
      },
      column: {
        align: "center",
        width: 120,
        component: { name: "fs-date-format", format: "YYYY-[Q]Q" }
      },
      valueBuilder(o) {
        t(o);
      }
    },
    year: {
      form: {
        component: {
          //el-date-picker,a-date-picker
          ...e.datePicker.buildDateType("year"),
          vModel: e.datePicker.modelValue
        }
      },
      column: {
        align: "center",
        width: 120,
        component: { name: "fs-date-format", format: "YYYY" }
      },
      valueBuilder(o) {
        t(o);
      }
    }
  };
}
var $s = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: Os
}, Symbol.toStringTag, { value: "Module" }));
function Ts() {
  const { ui: e } = R();
  return {
    number: {
      form: { component: { name: e.number.name, props: {} } },
      align: "center"
    },
    switch: {
      form: { component: { name: e.switch.name, props: {} } },
      component: { name: e.switch.name, props: {} },
      align: "center"
    },
    slider: {
      form: { component: { name: "el-slider", props: {} } },
      align: "center"
    },
    rate: {
      form: { component: { name: "el-rate", props: {} } },
      align: "center"
    },
    "color-picker": {
      form: { component: { name: "el-color-picker", props: {} } },
      align: "center"
    },
    transfer: {
      form: { component: { name: "el-transfer", props: {} } },
      align: "center"
    },
    autocomplete: {
      form: { component: { name: "el-autocomplete", props: {} } }
    }
  };
}
var As = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: Ts
}, Symbol.toStringTag, { value: "Module" }));
function Is() {
  const e = d.get();
  return {
    number: {
      form: {
        component: {
          // el-input-number,a-input-number
          name: e.number.name,
          vModel: e.modelValue
        }
      }
    }
  };
}
var Vs = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: Is
}, Symbol.toStringTag, { value: "Module" }));
function Ps() {
  return {
    "phone-number": {
      form: {
        component: {
          name: "el-phone-number-input"
        }
      },
      column: {
        formatter(e, t, n) {
          let o = "";
          return n != null && (n.callingCode != null ? o += "(+" + n.callingCode + ")" : n.countryCode != null && (o += "(" + n.countryCode + ")"), n.phoneNumber != null && (o += n.phoneNumber)), o;
        }
      }
    }
  };
}
var Ms = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: Ps
}, Symbol.toStringTag, { value: "Module" }));
function Bs() {
  const e = d.get();
  return {
    select: {
      search: { autoSearchTrigger: "change" },
      form: {
        component: {
          name: e.select.name,
          [e.select.clearable]: true
        }
      }
    },
    "dict-select": {
      search: { autoSearchTrigger: "change" },
      column: { component: { name: "fs-values-format", vModel: "modelValue" } },
      form: {
        component: {
          name: "fs-dict-select",
          vModel: e.select.modelValue,
          [e.select.clearable]: true
        }
      }
    },
    "table-select": {
      column: { component: { name: "fs-values-format", vModel: "modelValue" } },
      form: {
        component: {
          name: "fs-table-select"
        }
      }
    },
    "dict-radio": {
      search: {
        component: {
          name: "fs-dict-select",
          vModel: e.select.modelValue,
          autoSearchTrigger: "change"
        }
      },
      form: {
        component: {
          name: "fs-dict-radio",
          vModel: e.radioGroup.modelValue,
          [e.select.clearable]: true
        }
      },
      column: { component: { name: "fs-values-format", vModel: "modelValue" } }
    },
    "dict-checkbox": {
      search: {
        component: { name: "fs-dict-select" },
        autoSearchTrigger: "change"
      },
      form: {
        component: {
          name: "fs-dict-checkbox",
          vModel: e.radioGroup.modelValue,
          [e.select.clearable]: true
        }
      },
      column: { component: { name: "fs-values-format", vModel: "modelValue" } }
    },
    "dict-switch": {
      search: {
        component: { name: "fs-dict-select", vModel: e.select.modelValue },
        autoSearchTrigger: "change"
      },
      form: {
        component: {
          name: "fs-dict-switch",
          vModel: e.switch.modelValue,
          [e.select.clearable]: true
        }
      },
      column: { component: { name: "fs-values-format", vModel: "modelValue" } }
    }
  };
}
var js = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: Bs
}, Symbol.toStringTag, { value: "Module" }));
function Ns() {
  const e = d.get();
  return {
    text: {
      form: {
        component: {
          // el-input, a-input
          name: e.input.name,
          vModel: e.textArea.modelValue,
          [e.input.clearable]: true
        }
      },
      search: {
        autoSearchTrigger: "enter"
      }
    },
    password: {
      form: {
        component: {
          // el-input / a-input-password
          name: e.inputPassword.name,
          vModel: e.inputPassword.modelValue,
          ...e.inputPassword.passwordType
        }
      },
      search: {
        autoSearchTrigger: "enter"
      }
    },
    textarea: {
      search: {
        component: {
          // el-input / a-input
          name: e.input.name,
          type: "text",
          [e.input.clearable]: true
        },
        autoSearchTrigger: "enter"
      },
      form: {
        component: {
          // el-input / a-textarea
          name: e.textArea.name,
          type: e.textArea.type,
          vModel: e.textArea.modelValue,
          [e.input.clearable]: true
        }
      }
    }
  };
}
var Ls = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: Ns
}, Symbol.toStringTag, { value: "Module" }));
function qs() {
  const e = d.get();
  return {
    "dict-tree": {
      search: { autoSearchTrigger: "change" },
      column: { component: { name: "fs-values-format", vModel: "modelValue" } },
      form: {
        component: {
          name: "fs-dict-tree",
          vModel: e.treeSelect.modelValue,
          [e.treeSelect.clearable]: true
        }
      }
    }
  };
}
var Hs = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: qs
}, Symbol.toStringTag, { value: "Module" }));
var zs = Object.assign({ "./list/assist.ts": ds, "./list/button.ts": hs, "./list/cascader.ts": ps, "./list/date.ts": $s, "./list/el.ts": As, "./list/number.ts": Vs, "./list/phone.ts": Ms, "./list/select.ts": js, "./list/text.ts": Ls, "./list/tree.ts": Hs });
var Da = [];
lodash_default_default.forEach(zs, (e) => {
  Da.push(e.default);
});
var zn = {};
function Ws() {
  return zn;
}
function xs(e) {
  return zn[e];
}
function Us(e) {
  for (const t in e)
    zn[t] = e[t];
}
var gn = {
  getType: xs,
  addTypes: Us,
  getTypes: Ws,
  install() {
    for (const e of Da)
      lodash_default_default.forEach(e(), (t, n) => {
        zn[n] = t;
      });
    se.debug("types installed:", zn);
  }
};
var Ks = defineComponent({
  name: "FsPage",
  setup() {
    const e = ref();
    return onMounted(() => {
      window.getComputedStyle(e.value.parentNode).getPropertyValue("position") !== "relative" && Ao.logger.warn(
        "fs-page父节点的position建议为relative,因为fs-page为相对定位（position:absolute），如果样式没有异常，你可以忽略此警告"
      );
    }), {
      pageRef: e
    };
  }
});
var Ee = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [o, r] of t)
    n[o] = r;
  return n;
};
var Ys = {
  ref: "pageRef",
  class: "fs-page"
};
var Gs = {
  key: 0,
  class: "fs-page-header"
};
var Xs = { class: "fs-page-content" };
var Qs = {
  key: 1,
  class: "fs-page-footer"
};
function Js(e, t, n, o, r, a) {
  return openBlock(), createElementBlock("div", Ys, [
    e.$slots.header != null ? (openBlock(), createElementBlock("div", Gs, [
      renderSlot(e.$slots, "header")
    ])) : createCommentVNode("", true),
    createBaseVNode("div", Xs, [
      renderSlot(e.$slots, "default")
    ]),
    e.$slots.footer != null ? (openBlock(), createElementBlock("div", Qs, [
      renderSlot(e.$slots, "footer")
    ])) : createCommentVNode("", true)
  ], 512);
}
var Zs = Ee(Ks, [["render", Js]]);
function nr(e) {
  return e != null && (e instanceof ka || isRef(e));
}
function Hr(e) {
  return nr(e) && !e.cloneable;
}
function el(e, ...t) {
  function n(r, a) {
    if (a != null && (lodash_default_default.isArray(r) || nr(a)))
      return a;
  }
  let o = null;
  for (const r of t)
    nr(r) && (o = r);
  return o || lodash_default_default.mergeWith(e, ...t, n);
}
function tl(e) {
  if (Hr(e))
    return e;
  function t(n) {
    if (Hr(n))
      return n;
  }
  return lodash_default_default.cloneDeepWith(e, t);
}
var ka = class {
  constructor() {
    te(this, "cloneable", false);
  }
  setCloneable(t) {
    this.cloneable = t;
  }
};
function Re() {
  return {
    merge: el,
    cloneDeep: tl,
    UnMergeable: ka
  };
}
var { cloneDeep: nl } = Re();
function ol(e) {
  return e instanceof Rr;
}
function rl(e) {
  return e instanceof Po;
}
function zr(e, t, n) {
  const o = {};
  if (e == null)
    return o;
  const r = n ? ol : rl;
  return wa.forEachDeep(e, (a, i, s, l) => {
    if (r(a)) {
      const u = l.path;
      if (t) {
        for (const c of t)
          if (typeof c == "string") {
            if (u.startsWith(c))
              return false;
          } else if (c instanceof RegExp && c.test(u))
            return true;
      }
      return o[u] = a, false;
    }
    return !isShallow(a);
  }, {
    // https://deepdash.io/#eachdeep-foreachdeep
    checkCircular: true
  }), o;
}
function al(e, t) {
  if (e == null || Object.keys(e).length <= 0)
    return null;
  const n = {};
  return lodash_default_default.forEach(e, (o, r) => {
    n[r] = o.buildAsyncRef(t);
  }), n;
}
function il(e, t) {
  t == null || Object.keys(t).length <= 0 || lodash_default_default.forEach(t, (n, o) => {
    lodash_default_default.set(e, o, n.value == null ? null : n.value);
  });
}
function sl(e, t, n, o) {
  const r = computed(() => {
    const s = e();
    return zr(s, n, false);
  }), a = computed(() => {
    const s = e();
    return zr(s, n, true);
  }), i = computed(() => al(a.value, t));
  return computed(() => {
    let s = e();
    const l = Object.keys(a.value).length, u = Object.keys(r.value).length;
    if (l > 0 || u > 0) {
      if (s = nl(s), u > 0) {
        const c = t ? t() : {};
        lodash_default_default.forEach(r.value, (d2, f) => {
          lodash_default_default.set(s, f, d2.computeFn(c));
        });
      }
      l > 0 && il(s, i.value);
    }
    return o ? o(s) : s;
  });
}
var Po = class {
  constructor(t) {
    te(this, "computeFn");
    this.computeFn = t;
  }
};
function ll(e) {
  return new Po(e);
}
var Rr = class {
  constructor(t) {
    te(this, "watch");
    te(this, "asyncFn");
    te(this, "defaultValue");
    const { asyncFn: n, defaultValue: o } = t;
    this.watch = t.watch, this.asyncFn = n, this.defaultValue = o;
  }
  buildAsyncRef(t) {
    t = t || function() {
    };
    const n = ref(this.defaultValue), o = computed(() => this.watch ? this.watch(t()) : null);
    return watch(() => o.value, async (r) => {
      n.value = await this.asyncFn(r, t());
    }, { immediate: true }), n;
  }
};
function ul(e) {
  return new Rr(e);
}
function It() {
  return {
    ComputeValue: Po,
    compute: ll,
    AsyncComputeValue: Rr,
    asyncCompute: ul,
    doComputed: sl
  };
}
var Gt = {
  orderDefault: 1
};
var {
  merge: Ft,
  cloneDeep: Pt
} = Re();
var kn = [];
function Mo(e) {
  lodash_default_default.remove(kn, (t) => t.name === e.name), kn.push(e), kn.sort((t, n) => t.order - n.order), se.debug("mergeColumnPlugin register success: current:", e, "registered:", kn);
}
function cl(e) {
  var t, n;
  if (e.dict) {
    if ((t = e.column) != null && t.component) {
      const o = Pt(e.dict);
      e.column.component.dict = Ft(o, e.column.component.dict);
    }
    if ((n = e.form) != null && n.component) {
      const o = Pt(e.dict);
      e.form.component.dict = Ft(o, e.form.component.dict);
    }
  }
  return e;
}
function dl(e) {
  if (!e.type)
    return e;
  let t = [];
  typeof e.type == "string" ? t = [e.type] : e.type instanceof Array && (t = e.type);
  const n = {};
  for (const o of t) {
    const r = gn.getType(o);
    r && Ft(n, r);
  }
  return e = Ft(n, e), e;
}
var fl = {
  name: "type",
  handle: dl,
  order: -2
};
var hl = {
  name: "dict",
  handle: cl,
  order: -1
};
var ml = {
  name: "viewFormUseCellComponent",
  order: 10,
  handle: (e = {}, t = {}) => {
    var r, a;
    if (!((r = t.settings) != null && r.viewFormUseCellComponent))
      return e;
    const o = {
      component: ((a = e.column) == null ? void 0 : a.component) || {}
    };
    return (e.type === "text" || e.type instanceof Array && e.type.includes("text")) && (o.render = (i) => {
      const {
        value: s
      } = i;
      return createVNode("span", null, [s]);
    }), Ft(e, {
      viewForm: o
    }), e;
  }
};
Mo(fl);
Mo(hl);
Mo(ml);
function Er(e, t) {
  const n = {};
  return lodash_default_default.forEach(e, (o, r) => {
    if (o.key = r, o.children)
      o.children = Er(o.children, t);
    else
      for (const a of kn)
        o = a.handle(o, t);
    n[r] = o;
  }), n;
}
function Dr(e = {}, t) {
  return lodash_default_default.forEach(t, (n, o) => {
    n.children ? Dr(e, n.children) : e[o] = n;
  }), e;
}
function kr(e = {}, t) {
  return lodash_default_default.forEach(t, (n, o) => {
    n.children ? kr(e, n.children) : e[o] = n;
  }), e;
}
function pl(e) {
  const t = e, n = t.column || {};
  return n.title == null && (n.title = t.title), n.key = t.key, t.children && (n.children = $a(t.children)), Oa(n), reactive(n);
}
function Oa(e) {
  var t;
  e && (t = e.component) != null && t.name && typeof e.component.name != "string" && (isRef(e.component.name) || (e.component.name = shallowRef(e.component.name)));
}
function $a(e) {
  let t = {};
  return lodash_default_default.forEach(e, (n, o) => {
    t[o] = pl(n);
  }), t = Ta(t), t;
}
function gl(e) {
  return lodash_default_default.sortBy(e, (t) => t.order ?? Gt.orderDefault);
}
function Ta(e) {
  const t = [];
  for (const r in e) {
    const a = e[r];
    a.key = r, a.children && lodash_default_default.size(a.children) > 0 && (a.children = Ta(a.children)), t.push(a);
  }
  const n = gl(t), o = {};
  for (const r of n)
    o[r.key] = r;
  return o;
}
function Aa(e, t) {
  const n = {};
  return lodash_default_default.forEach(e, (o) => {
    const r = Pt(o[t]) || {};
    t === "form" && r.title == null && (r.title = o.title), r.key = o.key, n[o.key] = r, Oa(r);
  }), n;
}
function On(e, t, n, o) {
  const r = Aa(n, t), a = Ft(Pt(e.form), e[t], {
    columns: r
  });
  return o && o(a), a;
}
function vl(e, t = "search", n) {
  var s;
  const o = Aa(n, t), r = {}, a = ((s = e.settings) == null ? void 0 : s.searchCopyFormProps) ?? ["component", "valueChange", "title", "key", "label", "render"];
  function i(l, u, c) {
    if (lodash_default_default.includes(a, c) && e.columns[u]) {
      const f = e.columns[u][c];
      f && (l[c] = f);
    }
  }
  return lodash_default_default.forEach(Pt(e.form.columns), (l, u) => {
    const c = {};
    i(c, u, "valueResolve"), i(c, u, "valueBuilder"), r[u] = Ft(c, lodash_default_default.pick(l, a));
  }), Ft({
    columns: r
  }, {
    columns: o
  }, e.search);
}
function bl(e, t) {
  const {
    t: n
  } = et(), {
    merge: o
  } = Re();
  t = t || {};
  const r = o(Hn.defaultOptions({
    t: n
  }), Hn.commonOptions({
    crudOptions: e,
    context: t,
    crudExpose: null
  }), e), a = Er(Pt(r.columns), r), i = Dr({}, a);
  return On(r, "form", i);
}
function yl(e) {
  lodash_default_default.forEach(e.columns, (o, r) => {
    o.key = r;
  });
  const t = Er(Pt(e.columns), e);
  e.columns = t;
  const n = Dr({}, t);
  return e.table.columns = $a(Pt(t)), e.table.columnsMap = kr({}, e.table.columns), Ft(e.toolbar, {
    columnsFilter: {
      originalColumns: Pt(e.table.columns)
    }
  }), e.form = On(e, "form", n), e.addForm = On(e, "addForm", n), e.editForm = On(e, "editForm", n), e.viewForm = On(e, "viewForm", n, (o) => {
    lodash_default_default.forEach(o.columns, (r) => {
      r.component || (r.component = {}), r.component.disabled = true;
    });
  }), e.search = vl(e, "search", n), e.table.editable && (e.table.editable.addForm = Ft(e.addForm.columns, e.table.editable.addForm), e.table.editable.editForm = Ft(e.editForm.columns, e.table.editable.editForm)), e;
}
function or(e, t) {
  lodash_default_default.forEach(e, (n, o) => {
    n.key || (n.key = o), n.children ? or(n.children, t) : t(n, o);
  });
}
function _o(e, t) {
  lodash_default_default.forEach(e, (n, o) => {
    n.key || (n.key = o), n.children ? _o(n.children, t) : t(n, o);
  });
}
function Ia() {
  return {
    buildFormOptions: bl,
    buildColumns: yl,
    registerMergeColumnPlugin: Mo,
    forEachColumns: _o
  };
}
var wl = 0;
var qo = {};
async function _l(e) {
  const t = e.id || `${wl++}`, n = document.createElement("div");
  return new Promise((o, r) => {
    let a = qo[t];
    a != null && (a.vm.exposed.open(e), o(a));
    const i = createVNode(Wn, {
      id: t,
      onClosed() {
        e.id || delete qo[t];
      }
    });
    i.appContext = Wn._context, render(i, n), document.body.appendChild(n);
    const l = i.component;
    a = {
      id: t,
      vNode: i,
      vm: l,
      props: i.component.props
    }, qo[t] = a, a.vm.exposed.open(e), o(a.vm.exposed);
  });
}
function Cl() {
  let e = null;
  try {
    e = inject("use:form:wrapper", () => {
    })();
  } catch (o) {
    se.warn("cant inject use:form:wrapper，建议在App.vue中使用<fs-form-provider>组件包裹<router-view/>", o);
  }
  let t = null;
  e == null ? t = async (o) => await _l(o) : t = async (o) => await e.open(o);
  async function n(o) {
    const { buildFormOptions: r } = Ia(), a = r(o.crudOptions, o.context);
    return await t(a);
  }
  return {
    openDialog: t,
    openCrudFormDialog: n
  };
}
var { merge: Va } = Re();
var Sl = Va;
function Fl(e) {
  const { crudExpose: t } = e, { crudBinding: n } = t;
  R(), et();
  const { merge: o } = Re();
  watch(() => {
    var a, i, s;
    return (s = (i = (a = n.value) == null ? void 0 : a.table) == null ? void 0 : i.editable) == null ? void 0 : s.enabled;
  }, (a) => {
    a ? n.value.table.editable.mode === "row" ? n.value.rowHandle.active = "editRow" : n.value.rowHandle.active = "editable" : n.value.rowHandle.active = "default";
  });
  const r = {
    /**
     * 启用编辑
     * @param opts
     */
    async enable(a, i) {
      const s = n.value.table.editable;
      o(s, { enabled: true }, a), i && i({ editable: s });
    },
    /**
     * 禁用编辑
     */
    disable() {
      var a;
      (a = t.getTableRef()) == null || a.editable.resume(), n.value.table.editable.enabled = false, n.value.rowHandle.active = "default";
    },
    /**
     * 激活所有编辑
     */
    active(a) {
      t.getTableRef().editable.active(a);
    },
    /**
     * 退出编辑
     */
    inactive() {
      t.getTableRef().editable.inactive();
    },
    /**
     * 添加行
     */
    addRow(a) {
      t.getTableRef().editable.addRow(a);
    },
    activeCols(a) {
      t.getTableRef().editable.activeCols(a);
    },
    /**
     * 还原，取消编辑
     */
    resume() {
      t.getTableRef().editable.resume();
    },
    /**
     * 还原，取消编辑,同resume
     */
    cancel() {
      t.getTableRef().editable.cancelAll();
    },
    /**
     * 本地保存，不提交到后台
     */
    persist() {
      t.getTableRef().editable.persist();
    },
    removeRow(a) {
      t.getTableRef().editable.removeRow(a);
    },
    getEditableRow(a) {
      var i, s;
      return (s = (i = t.getTableRef()) == null ? void 0 : i.editable) == null ? void 0 : s.getEditableRow(a);
    },
    getActiveRows() {
      var a, i;
      return (i = (a = t.getTableRef()) == null ? void 0 : a.editable) == null ? void 0 : i.getActiveRows();
    },
    async doSaveRow(a) {
      let i = a.editableId;
      i || (i = a.row[n.value.table.editable.rowKey]);
      const s = r.getEditableRow(i);
      await s.save({
        async doSave(l) {
          var h2, b;
          const { isAdd: u, row: c, setData: d2 } = l, f = c;
          if (((b = (h2 = n.value) == null ? void 0 : h2.mode) == null ? void 0 : b.name) !== "local")
            try {
              if (s.loading = true, u) {
                const m = await n.value.request.addRequest({ form: f });
                d2(m);
              } else
                await n.value.request.editRequest({ form: f, row: f });
            } finally {
              s.loading = false;
            }
        }
      });
    },
    async doCancelRow(a) {
      let i = a.editableId;
      i || (i = a.row[n.value.table.editable.rowKey]);
      const s = r.getEditableRow(i);
      if (s.isAdd) {
        r.removeRow(i);
        return;
      }
      s.cancel();
    },
    async doRemoveRow(a) {
      let i = a.editableId;
      i || (i = a.row[n.value.table.editable.rowKey]);
      const s = r.getEditableRow(i);
      return await t.doRemove(a, {
        async handle() {
          return s.isAdd ? (r.removeRow(i), false) : n.value.mode.name === "local" ? (r.removeRow(i), { isLocal: true }) : await n.value.request.delRequest(a);
        }
      });
    },
    getInstance() {
      t.getTableRef().editable;
    },
    eachCells(a) {
      var i;
      (i = t.getTableRef().editable) == null || i.eachCells(a);
    },
    eachRows(a) {
      var i;
      (i = t.getTableRef().editable) == null || i.eachRows(a);
    },
    async validate() {
      var a;
      return await ((a = t.getTableRef().editable) == null ? void 0 : a.validate());
    },
    getTableData(a) {
      var i;
      return (i = t.getTableRef().editable) == null ? void 0 : i.getCleanTableData(a);
    },
    getCleanTableData(a) {
      var i;
      return (i = t.getTableRef().editable) == null ? void 0 : i.getCleanTableData(a);
    }
  };
  return r;
}
function Or(e) {
  const { crudRef: t, crudBinding: n } = e, { ui: o } = R(), { t: r } = et(), a = Cl();
  function i() {
    t.value == null && se.warn("crudRef还未初始化，请在onMounted之后调用");
  }
  function s() {
    n.value == null && se.warn("crudBinding还未初始化，请在useFs或useCrud之后调用");
  }
  const l = {
    crudRef: t,
    crudBinding: n,
    getFormWrapperRef() {
      return t.value.formWrapperRef;
    },
    getFormRef: () => {
      const u = l.getFormWrapperRef();
      if (u == null || (u == null ? void 0 : u.formRef) == null) {
        se.error("当前无法获取FormRef，请在编辑对话框已打开的状态下调用此方法，如果是在打开对话框时调用，可以尝试先nextTick");
        return;
      }
      return u == null ? void 0 : u.formRef;
    },
    getFormData: () => {
      const u = l.getFormRef();
      return u == null ? void 0 : u.getFormData();
    },
    setFormData: (u, c) => {
      var d2;
      (d2 = l.getFormRef()) == null || d2.setFormData(u, c);
    },
    getFormComponentRef(u, c = false) {
      const d2 = l.getFormRef();
      return d2 == null ? void 0 : d2.getComponentRef(u, c);
    },
    doValueBuilder(u, c) {
      c == null && (c = toRaw(n.value.columns)), se.debug("doValueBuilder ,columns=", c);
      const d2 = [];
      _o(c, (f) => {
        f.valueBuilder != null && d2.push(f);
      }), d2.length !== 0 && (lodash_default_default.forEach(u, (f, h2) => {
        lodash_default_default.forEach(d2, (b) => {
          b.valueBuilder({
            value: f[b.key],
            row: f,
            form: f,
            index: h2,
            key: b.key,
            column: b
          });
        }), f.children && isArray_default(f.children) && l.doValueBuilder(f.children, c);
      }), se.debug("valueBuilder success:", u));
    },
    doValueResolve({ form: u }, c) {
      c == null && (c = toRaw(n.value.columns));
      const d2 = [];
      _o(c, (f) => {
        f.valueResolve != null && d2.push(f);
      }), d2.length !== 0 && (se.debug("doValueResolve ,columns=", c), lodash_default_default.forEach(d2, (f) => {
        const h2 = f.key;
        f.valueResolve({
          value: u[h2],
          row: u,
          form: u,
          key: h2,
          column: f
        });
      }), se.debug("valueResolve success:", u));
    },
    doSearchValidate() {
      l.getSearchRef().doValidate();
    },
    getSearchFormData() {
      return n.value.search.validatedForm;
    },
    getSearchValidatedFormData() {
      return n.value.search.validatedForm;
    },
    /**
     * {form,mergeForm}
     */
    setSearchFormData(u) {
      if (t.value && t.value.setSearchFormData({
        form: u.form,
        mergeForm: u.mergeForm
      }), u.mergeForm === false)
        for (const d2 in n.value.search.validatedForm)
          delete n.value.search.validatedForm[d2];
      const { merge: c } = Re();
      c(n.value.search.validatedForm, u.form), u.triggerSearch && l.doRefresh();
    },
    /**
     * 获取search组件ref
     */
    getSearchRef() {
      var u;
      return i(), (u = t.value) == null ? void 0 : u.getSearchRef();
    },
    buildPageQuery(u) {
      var m, _;
      const c = u.page;
      let d2 = u.form;
      d2 == null && (d2 = lodash_default_default.cloneDeep(l.getSearchValidatedFormData()) || {}, (_ = (m = n.value) == null ? void 0 : m.search) != null && _.columns && l.doValueResolve({ form: d2 }, toRaw(n.value.search.columns)));
      let f = u.sort;
      f == null && (f = n.value.table.sort || {});
      const h2 = { page: c, form: d2, sort: f };
      let b = h2;
      return n.value.request.transformQuery && (b = n.value.request.transformQuery(h2)), b;
    },
    async search(u, c = {}) {
      const d2 = l.buildPageQuery(u);
      let f;
      try {
        c.silence !== true && (n.value.table.loading = true), se.debug("pageRequest", d2), f = await n.value.request.pageRequest(d2);
      } finally {
        c.silence !== true && (n.value.table.loading = false);
      }
      if (f == null) {
        se.warn("pageRequest返回结果不能为空");
        return;
      }
      let h2 = f;
      return n.value.request.transformRes && (h2 = n.value.request.transformRes({
        res: f,
        query: d2
      })), h2.records && l.doValueBuilder(h2.records), h2;
    },
    getPage() {
      let u = {
        currentPage: 1,
        pageSize: 10
      };
      return n.value.pagination && (u = {
        currentPage: n.value.pagination[o.pagination.currentPage],
        pageSize: n.value.pagination.pageSize
      }), u;
    },
    async doRefresh(u) {
      var _, y;
      if (n.value.request.pageRequest == null)
        return;
      se.debug("do refresh:", u), n.value.pagination && u != null && u.goFirstPage && (n.value.pagination[o.pagination.currentPage] = 1);
      const c = l.getPage(), d2 = await l.search({ page: c }, { silence: u == null ? void 0 : u.silence });
      if (d2 == null) {
        se.error("pageRequest返回结构不正确，请配置正确的request.transformRes，期望：{currentPage>0, pageSize>0, total, records:[]},实际返回：", d2);
        return;
      }
      const { currentPage: f = c.currentPage || 1, pageSize: h2 = c.pageSize, total: b } = d2, { records: m } = d2;
      if (m == null || !(m instanceof Array) || b == null || f == null || f <= 0 || isNaN(f) || h2 == null || h2 <= 0 || isNaN(h2)) {
        se.error("pageRequest返回结构不正确，请配置正确的request.transformRes，期望：{currentPage>0, pageSize>0, total, records:[]},实际返回：", d2), se.info("如果你的不需要分页，也需要按照上面的格式返回，可以让pageSize=99999，然后配置crudOptions.pagination.show=false来隐藏分页组件");
        return;
      }
      if (n.value.data = m, n.value.pagination && (n.value.pagination[o.pagination.currentPage] = f, n.value.pagination.pageSize = h2, n.value.pagination[o.pagination.total] = b || m.length), (u == null ? void 0 : u.scrollTop) ?? n.value.table.scrollTopOnRefreshed) {
        const E = l.getTableRef();
        E == null || E.scrollTo(0);
      }
      (y = (_ = n.value) == null ? void 0 : _.table) != null && y.onRefreshed && n.value.table.onRefreshed({
        data: m
      });
    },
    /**
     * 获取toolbar组件Ref
     */
    getToolbarRef: () => t.value.toolbarRef,
    /**
     * 获取列设置组件Ref
     */
    getColumnsFilterRef: () => l.getToolbarRef().columnsFilterRef,
    /**
     * 获取列设置的原始列配置Ref
     * 可以修改列设置的原始配置
     */
    getColumnsFilterOriginalColumnsRef: () => l.getColumnsFilterRef().original,
    /**
     * 获取列设置的列配置Ref
     * 可以动态修改列设置每列的配置
     */
    getColumnsFilterColumnsRef: () => l.getColumnsFilterRef().columns,
    doPageTurn(u) {
      n.value.pagination[o.pagination.currentPage] = u;
    },
    /**
     *
     * @param opts = {
     *   form
     *   goFirstPage =true
     *   mergeForm=false
     * }
     */
    async doSearch(u) {
      se.debug("do search:", u), u = Va({ goFirstPage: true }, u), u.goFirstPage && l.doPageTurn(1), u.form && t.value && l.setSearchFormData({
        form: u.form,
        mergeForm: u.mergeForm,
        refWarning: false,
        triggerSearch: false
      }), await l.doRefresh();
    },
    /**
     * 获取FsTable实例
     */
    getTableRef() {
      var u;
      return i(), (u = t.value) == null ? void 0 : u.tableRef;
    },
    /**
     * 获取x-Table实例
     */
    getBaseTableRef() {
      const u = this.getTableRef();
      if (u == null) {
        se.warn("fs-table还未挂载");
        return;
      }
      return u.tableRef;
    },
    /**
     * 获取表格数据
     */
    getTableData() {
      return s(), n.value.data;
    },
    setTableData(u) {
      s(), n.value.data = u;
    },
    insertTableRow(u, c) {
      s(), n.value.data.splice(u, 0, c);
    },
    updateTableRow(u, c, d2 = true) {
      d2 ? n.value.data[u] = Sl(n.value.data[u], c) : n.value.data[u] = c;
    },
    removeTableRow(u) {
      s(), n.value.data.splice(u, 1);
    },
    removeTableRowByRowKey: (u, c) => {
      s(), c == null && (c = n.value.data);
      for (let d2 = 0; d2 < c.length; d2++) {
        const f = c[d2];
        if (f[n.value.table.rowKey] === u)
          return c.splice(d2, 1), true;
        if (f.children && isArray_default(f.children) && l.removeTableRowByRowKey(u, f.children))
          return true;
      }
    },
    getTableDataRow(u) {
      const c = l.getTableData();
      if (c == null)
        throw new Error("table data is not init");
      if (c.length <= u)
        throw new Error("index over array length");
      return c[u];
    },
    /**
     * 选择某一行
     * @param index
     * @param row
     */
    doSelectCurrentRow({ row: u }) {
      l.getTableRef().value.setCurrentRow(u);
    },
    /**
     * 删除行按钮
     * @param context
     * @param opts
     */
    async doRemove(u, c) {
      var m;
      const d2 = n.value.table.remove ?? c ?? {};
      try {
        d2.confirmFn ? await d2.confirmFn(u) : await o.messageBox.confirm({
          title: d2.confirmTitle || r("fs.rowHandle.remove.confirmTitle"),
          message: d2.confirmMessage || r("fs.rowHandle.remove.confirmMessage"),
          type: "warn",
          ...d2.confirmProps
        });
      } catch {
        d2.onCanceled && await d2.onCanceled(u);
        return;
      }
      let f = null;
      const h2 = ((m = n.value.mode) == null ? void 0 : m.name) === "local";
      if (c != null && c.handle ? f = await c.handle(u) : h2 ? l.removeTableRow(u == null ? void 0 : u.index) : f = await n.value.request.delRequest(u), f === false)
        return;
      const b = { ...u, res: f };
      if (d2.afterRemove && await d2.afterRemove(b) === false)
        return false;
      d2.showSuccessNotification !== false && o.notification.success(r("fs.rowHandle.remove.success")), h2 || d2.refreshTable !== false && await l.doRefresh({ scrollTop: false }), d2.onRemoved && await d2.onRemoved({ ...u, res: f });
    },
    /**
     *
     * 打开表单对话框
     * @param formOpts ={mode, initialForm: row, index,...formOptions}
     */
    async openDialog(u) {
      if (u.newInstance === true && a)
        return await a.openDialog(u);
      const c = this.getFormWrapperRef();
      return c.open(u), c;
    },
    async _openDialog(u, c, d2) {
      var _, y;
      const { merge: f } = Re();
      let h2 = c.row || c[o.tableColumn.row];
      delete c.row, h2 == null && c.index != null && (h2 = l.getTableDataRow(c.index)), (y = (_ = n.value) == null ? void 0 : _.request) != null && y.infoRequest && (h2 = await n.value.request.infoRequest({ mode: u, row: h2 }));
      const b = {
        mode: u
      }, m = toRaw(n.value[u + "Form"]);
      return f(b, m, { initialForm: h2 }, c, d2), await this.openDialog(b);
    },
    async openAdd(u, c = {}) {
      return this._openDialog("add", u, c);
    },
    async openEdit(u, c = {}) {
      return this._openDialog("edit", u, c);
    },
    async openView(u, c = {}) {
      return this._openDialog("view", u, c);
    },
    async openCopy(u, c = {}) {
      return this._openDialog("add", u, c);
    },
    editable: void 0
  };
  return l.editable = Fl({ crudExpose: l }), { expose: l, crudExpose: l };
}
async function Rl() {
  const e = await Object.assign({ "./lib/index.ts": () => import("./index-e3d68631-ES6B3SJU.js") });
  let t = null;
  return lodash_default_default.each(e, (o) => {
    t = o;
  }), (await t()).exportUtil;
}
async function El() {
  const e = await Object.assign({ "./lib/index.ts": () => import("./index-e3d68631-ES6B3SJU.js") });
  let t = null;
  return lodash_default_default.each(e, (o) => {
    t = o;
  }), (await t()).importUtil;
}
function Dl({ originalRow: e, row: t, key: n, col: o }) {
  var i;
  const r = e[n], a = (i = o.component) == null ? void 0 : i.dict;
  if (a && r != null) {
    const s = a.getNodesFromDataMap(r);
    if (s != null && s.length > 0) {
      const l = lodash_default_default.map(s, (u) => a.getLabel(u) || a.getValue(u)).join("|");
      l != null && l !== "" && (t[n] = l);
    }
  }
  return t;
}
async function kl(e, t = {}) {
  if (t.server) {
    const u = e.getPage(), c = e.buildPageQuery({ page: u });
    await t.server(c);
    return;
  }
  const n = e.crudBinding;
  let o = t.columns;
  o == null && (o = [], lodash_default_default.each(n.value.table.columnsMap, (u) => {
    if (!(t.columnFilter && t.columnFilter(u) === false) && !(t.onlyShow && unref(u.show) === false) && u.exportable !== false && u.key !== "_index") {
      const c = {
        key: u.key,
        title: u.title
      };
      o.push(c);
    }
  }));
  for (const u of o) {
    const c = n.value.table.columnsMap[u.key];
    u.columnProps = c || {}, t.columnBuilder && t.columnBuilder({ col: u });
  }
  const { merge: r } = Re(), a = await Rl(), i = [];
  let s = n.value.data;
  if (t.dataFrom === "search") {
    const u = r({
      page: {
        currentPage: 1,
        pageSize: 99999999
      }
    }, n.value.toolbar.export.searchParams);
    s = (await e.search(u, { silence: true })).records;
  }
  for (const u of s) {
    const c = lodash_default_default.cloneDeep(u);
    lodash_default_default.each(o, (d2) => {
      const f = d2.columnProps, h2 = {
        row: c,
        originalRow: u,
        key: d2.key,
        col: f,
        exportCol: d2
      };
      t.autoUseDictLabel !== false && Dl(h2), t.dataFormatter && t.dataFormatter(h2);
    }), i.push(c);
  }
  const l = lodash_default_default.merge({
    columns: o,
    data: i,
    filename: "table",
    noHeader: false,
    separator: ",",
    quoted: false
    //每项数据是否加引号
  }, {
    ...t
  });
  t.fileType === "excel" ? await a.excel(l) : await a.csv(l);
}
async function rm(e, t) {
  const o = await (await El()).csv(t.file), r = e.crudBinding;
  t.append === false && (r.value.data.length = 0);
  const a = r.value.table.editable.enabled;
  for (const i of o.data)
    a ? e.editable.addRow({ row: i, active: false }) : r.value.data.push(i);
}
var Pa = {};
function Ol(e, t) {
  Pa[e] = t;
}
function $l(e) {
  return Pa[e];
}
Ol("rowSelection", (e, t) => {
  const o = t.crudExpose.crudBinding;
  function r() {
    return o.value.table.rowKey || "id";
  }
  const { ui: a } = R();
  if (!e) {
    se.warn("请配置settings.plugins.rowSelection.props参数");
    return;
  }
  return a.table.buildSelectionCrudOptions({
    crossPage: e.crossPage,
    getRowKey: r,
    getPageData() {
      return o.value.data;
    },
    useCompute: () => It(),
    multiple: e.multiple,
    selectedRowKeys: e.selectedRowKeys,
    onSelectedKeysChanged: async (i) => {
      e.selectedRowKeys.value = [...i], await nextTick(), e.onSelectedChanged && e.onSelectedChanged(e.selectedRowKeys.value);
    }
  });
});
var { merge: Nt } = Re();
function Tl(e) {
  e.context == null && (e.context = {});
  const t = d.get(), { t: n } = et(), o = (F) => computed(() => n(F));
  let r = e.crudOptions;
  const a = e.expose || e.crudExpose;
  if (!a)
    throw new Error("crudExpose不能为空，请给useCrud传入{crudExpose}参数");
  const i = a, { crudBinding: s } = i, { doRefresh: l, doValueResolve: u } = i;
  function c() {
    return {
      pagination: {
        ...t.pagination.onChange({
          setCurrentPage(M) {
            s.value.pagination[t.pagination.currentPage] = M;
          },
          setPageSize(M) {
            s.value.pagination.pageSize = M, s.value.pagination[t.pagination.currentPage] = 1;
          },
          async doAfterChange() {
            return await l();
          }
        })
      }
    };
  }
  function d2() {
    return {
      form: {
        async doSubmit(F) {
          var M, ie, Q, V;
          if (F.mode === "edit")
            if (u(F), ((M = r.mode) == null ? void 0 : M.name) === "local")
              i.updateTableRow(F.index, F.form, r.mode.isMergeWhenUpdate);
            else
              return (ie = s.value.request) != null && ie.editRequest || se.warn("request.editRequest 未定义，无法保存"), await s.value.request.editRequest(F);
          else if (F.mode === "add")
            if (u(F), ((Q = r.mode) == null ? void 0 : Q.name) === "local") {
              const N = r.mode.isAppendWhenAdd ? i.getTableData().length : 0;
              i.insertTableRow(N, F.form);
            } else
              return (V = s.value.request) != null && V.addRequest || se.warn("request.addRequest 未定义，无法保存"), await s.value.request.addRequest(F);
        },
        async onSuccess({ mode: F }) {
          F === "edit" ? await l({ scrollTop: false }) : F === "add" ? await l({ scrollTop: true, goFirstPage: true }) : await l();
        }
      }
    };
  }
  function f() {
    return {
      rowHandle: {
        buttons: {
          remove: {
            click: async (F) => {
              F.row = F[t.tableColumn.row], await i.doRemove(F);
            }
          },
          copy: {
            show: false,
            click: async (F) => {
              F.row = F[t.tableColumn.row], await i.openCopy({
                row: F.row,
                index: F.index
              });
            }
          },
          edit: {
            click: async (F) => {
              F.row = F[t.tableColumn.row], await i.openEdit({
                row: F.row,
                index: F.index
              });
            }
          },
          view: {
            click: async (F) => {
              F.row = F[t.tableColumn.row], await i.openView({
                row: F.row,
                index: F.index
              });
            }
          }
        }
      }
    };
  }
  function h2() {
    return {
      search: {
        buttons: {
          search: {
            loading: computed(() => {
              var F, M;
              return (M = (F = s.value) == null ? void 0 : F.table) == null ? void 0 : M.loading;
            })
          }
        },
        on_reset() {
          s.value.table.sort = {}, or(s.value.table.columns, (M) => {
            M.sortOrder = false;
          });
          const F = a.getBaseTableRef();
          F != null && F.clearSort && F.clearSort();
        },
        on_search() {
          a.doRefresh({ goFirstPage: true });
        },
        "onUpdate:form": (F) => {
          s.value.search.form = F;
        },
        "onUpdate:validatedForm": (F) => {
          s.value.search.validatedForm = F;
        },
        "onUpdate:collapse": (F) => {
          s.value.search.collapse = F;
        },
        container: {
          collapse: true,
          "onUpdate:collapse": (F) => {
            s.value.search.container.collapse = F;
          }
        }
      }
    };
  }
  function b() {
    return {
      tabs: {},
      onTabChange(F) {
        a.setSearchFormData({ form: F, mergeForm: true }), l();
      }
    };
  }
  function m() {
    const F = ref(false);
    return {
      toolbar: {
        buttons: {
          refresh: {
            type: "primary",
            icon: t.icons.refresh,
            title: o("fs.toolbar.refresh.title"),
            order: 1,
            circle: true,
            click: async () => {
              await a.doRefresh({ scrollTop: false });
            }
          },
          search: {
            type: computed(() => s.value.search.show !== false ? "primary" : "default"),
            icon: t.icons.search,
            title: o("fs.toolbar.search.title"),
            order: 2,
            circle: true,
            click: () => {
              s.value.search.show = !s.value.search.show;
            }
          },
          compact: {
            type: computed(() => s.value.toolbar.compact ? "primary" : "default"),
            icon: t.icons.compact,
            title: o("fs.toolbar.compact.title"),
            order: 3,
            circle: true,
            click: () => {
              s.value.toolbar.compact = !s.value.toolbar.compact;
            }
          },
          export: {
            show: true,
            type: "primary",
            icon: t.icons.export,
            order: 4,
            loading: F,
            title: o("fs.toolbar.export.title"),
            circle: true,
            click: async () => {
              F.value = true;
              try {
                await kl(a, s.value.toolbar.export);
              } finally {
                F.value = false;
              }
            }
          },
          columns: {
            type: "primary",
            icon: t.icons.columnsFilter,
            title: o("fs.toolbar.columns.title"),
            circle: true,
            order: 5
          }
        },
        "onUpdate:columns"(M) {
          const ie = s.value.table.columns;
          function Q(N, Y) {
            const me = {};
            return lodash_default_default.forEach(Y, (pe) => {
              const Se = N[pe.key];
              if (Se) {
                delete Se.order;
                const Ce = Nt({ ...Se }, pe);
                me[pe.key] = Ce, Se.children && (Ce.children = Q(Se.children, pe.children));
              }
            }), me;
          }
          const V = Q(ie, M);
          s.value.table.columns = V, s.value.table.columnsMap = kr({}, V);
        }
      }
    };
  }
  function _() {
    return {
      table: {
        onSortChange(F) {
          const { isServerSort: M, prop: ie, asc: Q, order: V } = F;
          or(s.value.table.columns, (Y) => {
            Y.key === ie ? Y.sortOrder = V : Y.sortOrder = false;
          });
          const N = s.value.table.sort;
          s.value.table.sort = M ? { prop: ie, order: V, asc: Q } : null, (M || N != null) && i.doRefresh();
        }
      }
    };
  }
  function y() {
    return {
      actionbar: {
        buttons: {
          add: {
            click() {
              i.openAdd({});
            }
          }
        }
      }
    };
  }
  function E() {
    const { compute: F } = It();
    return {
      actionbar: {
        buttons: {
          addRow: {
            show: false,
            text: o("fs.actionbar.add"),
            type: "primary",
            click: () => {
              i.editable.addRow();
            }
          }
        }
      },
      rowHandle: {
        group: {
          editable: {
            remove: {
              text: "删除",
              ...t.button.colors("danger"),
              click: async (M) => {
                const { index: ie, row: Q } = M, V = Q[s.value.table.editable.rowKey];
                await i.editable.doRemoveRow({ editableId: V, row: Q });
              }
            }
          },
          editRow: {
            edit: {
              text: "编辑",
              loading: F((M) => {
                const { index: ie, row: Q } = M, V = Q[s.value.table.editable.rowKey], N = i.editable.getEditableRow(V);
                return !!(N != null && N.loading);
              }),
              click: async (M) => {
                var N;
                const { index: ie, row: Q } = M, V = Q[s.value.table.editable.rowKey];
                if (s.value.table.editable.exclusive) {
                  const Y = i.editable.getActiveRows();
                  lodash_default_default.forEach(Y, (me) => {
                    s.value.table.editable.exclusiveEffect === "save" ? i.editable.doSaveRow({ row: me.rowData }) : i.editable.doCancelRow({ row: me.rowData });
                  });
                }
                (N = i.editable.getEditableRow(V)) == null || N.active();
              },
              show: F((M) => {
                var N, Y;
                const { index: ie, row: Q } = M, V = Q[s.value.table.editable.rowKey];
                return !((Y = (N = i.editable) == null ? void 0 : N.getEditableRow(V)) != null && Y.isEditing);
              })
            },
            save: {
              text: "保存",
              loading: false,
              click: async (M) => {
                const { index: ie, row: Q } = M;
                await i.editable.doSaveRow({ row: Q });
              },
              show: F((M) => {
                var N, Y;
                const { index: ie, row: Q } = M, V = Q[s.value.table.editable.rowKey];
                return !!((Y = (N = i.editable) == null ? void 0 : N.getEditableRow(V)) != null && Y.isEditing);
              })
            },
            cancel: {
              text: "取消",
              click: async (M) => {
                var V;
                const { index: ie, row: Q } = M;
                await ((V = i.editable) == null ? void 0 : V.doCancelRow({ row: Q }));
              },
              show: F((M) => {
                var N, Y;
                const { index: ie, row: Q } = M, V = Q[s.value.table.editable.rowKey];
                return !!((Y = (N = i.editable) == null ? void 0 : N.getEditableRow(V)) != null && Y.isEditing);
              })
            },
            remove: {
              text: "删除",
              ...t.button.colors("danger"),
              click: async (M) => {
                var N;
                const { index: ie, row: Q } = M, V = Q[s.value.table.editable.rowKey];
                await ((N = i.editable) == null ? void 0 : N.doRemoveRow({ row: Q, editableId: V }));
              }
            }
          }
        }
      }
    };
  }
  function k(F) {
    F.search.validatedForm = lodash_default_default.cloneDeep(F.search.initialForm);
  }
  function O(F) {
    F = Nt(Hn.commonOptions(e), F);
    const M = unref(F.settings);
    if (M) {
      const N = unref(M.plugins);
      lodash_default_default.forEach(N, (Y, me) => {
        if (Y.enabled === false)
          return;
        let pe = Y.handle;
        if (pe == null && (pe = $l(me)), pe == null)
          return;
        const Se = Y.before, Ce = pe(Y.props, e);
        Se !== false ? F = Nt(Ce, F) : Nt(F, Ce);
      });
    }
    const ie = Nt(Hn.defaultOptions({ t: n }), c(), d2(), f(), h2(), b(), m(), _(), y(), E(), F), { buildColumns: Q } = Ia(), V = Q(ie);
    return k(V), V;
  }
  function T(F) {
    s.value = O(F), se.info("fast-crud inited, crudBinding=", s.value);
  }
  function D(F) {
    const M = Nt({}, r, F);
    return T(M), r = M, M;
  }
  T(r);
  function $(F) {
    Nt(s.value, F);
  }
  return {
    appendCrudOptions: D,
    resetCrudOptions: T,
    appendCrudBinding: $
  };
}
function Ma(e) {
  const { createCrudOptions: t, crudExposeRef: n } = e, o = e.crudRef || ref(), r = e.crudBinding || ref({});
  let a = e.crudExpose;
  a || (a = Or({ crudRef: o, crudBinding: r }).crudExpose), n && !n.value && (n.value = a), e.context == null && (e.context = {});
  const i = e.context;
  e.onExpose && e.onExpose({ crudRef: o, crudBinding: r, crudExpose: a, context: i });
  const s = t({
    ...e,
    crudExpose: a,
    expose: a,
    context: i
  });
  function l(u) {
    const c = { crudExpose: a, ...u, context: i };
    Nt(u.crudOptions, e.crudOptionsOverride);
    const d2 = Tl(c);
    return {
      ...u,
      ...d2,
      crudRef: o,
      crudExpose: a,
      crudBinding: r,
      context: i
    };
  }
  return s instanceof Promise ? s.then((u) => l(u)) : l(s);
}
function am(e) {
  return Ma(e);
}
function Al(e) {
  return Ma(e);
}
function Il() {
  const e = ref(), t = ref(), n = {}, { crudExpose: o } = Or({ crudBinding: t, crudRef: e });
  return {
    crudRef: e,
    crudBinding: t,
    context: n,
    crudExpose: o
  };
}
function Xt(e, t, n = "modelValue") {
  const o = d.get();
  let r = e.dict;
  r && r.prototype && (r.clear(), r = shallowReactive(lodash_default_default.cloneDeep(e.dict)), r.clear());
  function a() {
    return computed(() => {
      let D = [];
      if (e.options ? D = e.options : r && r.data != null && (r.data instanceof Array || Ao.logger.warn("dict.data类型错误，期望为数组，实际：" + r.data), D = r.data, e.transformDictData && (D = e.transformDictData(lodash_default_default.cloneDeep(r.data)))), o.type === "naive") {
        const $ = [];
        for (const F of D)
          $.push({
            ...F,
            value: E(F),
            label: O(F)
          });
        return $;
      }
      return D;
    });
  }
  function i() {
    return r;
  }
  const s = inject("get:scope", function() {
  });
  function l() {
    const D = e[n] || t.attrs[n];
    return {
      ...s(),
      componentRef: u,
      value: D
    };
  }
  const { proxy: u } = getCurrentInstance(), c = async (D = false) => {
    if (!r)
      return;
    if (r.getNodesByValues) {
      const F = l();
      if (F.value == null)
        return;
      let M = F.value;
      Array.isArray(F.value) || (M = [F.value]), await r.appendByValues(M);
      return;
    }
    if (r.loading)
      return;
    const $ = l();
    if (D) {
      await r.reloadDict($);
      return;
    }
    await r.loadDict($);
  };
  c();
  const d2 = async () => {
    await c(true);
  }, f = () => {
    r && r.clear();
  }, h2 = () => {
    r != null && (!r.prototype && !r.cloneable || watch(() => e[n], () => {
      d2();
    }));
  };
  (() => {
    watch(() => r == null ? void 0 : r.data, () => {
      const D = l();
      t.attrs.onDictChange, t.emit("dict-change", { dict: r, ...D });
    }, {
      immediate: true
    });
  })();
  const m = () => {
    var D;
    return (D = i()) == null ? void 0 : D.data;
  }, _ = (D, $) => {
    let F = $;
    return i() && (F = i()[$]), D[F];
  }, y = (D, $) => {
    let F = $;
    i() && (F = i()[$]), delete D[F];
  }, E = (D) => _(D, "value"), k = (D) => _(D, "children"), O = (D) => {
    if (e.labelFormatter)
      return e.labelFormatter(D);
    const $ = _(D, "label");
    return $ == null ? "" : String($);
  };
  return {
    createComputedOptions: a,
    loadDict: c,
    reloadDict: d2,
    clearDict: f,
    getDictData: m,
    getDict: i,
    watchValue: h2,
    getValue: E,
    getLabel: O,
    getChildren: k,
    getColor: (D) => _(D, "color"),
    removePropValue: y,
    curDict: r
  };
}
var dn = typeof performance == "object" && performance && typeof performance.now == "function" ? performance : Date;
var Ba = /* @__PURE__ */ new Set();
var rr = typeof process == "object" && process ? process : {};
var ja = (e, t, n, o) => {
  typeof rr.emitWarning == "function" ? rr.emitWarning(e, t, n, o) : console.error(`[${n}] ${t}: ${e}`);
};
var Co = globalThis.AbortController;
var Wr = globalThis.AbortSignal;
var fa;
if (typeof Co > "u") {
  Wr = class {
    constructor() {
      te(this, "onabort");
      te(this, "_onabort", []);
      te(this, "reason");
      te(this, "aborted", false);
    }
    addEventListener(o, r) {
      this._onabort.push(r);
    }
  }, Co = class {
    constructor() {
      te(this, "signal", new Wr());
      t();
    }
    abort(o) {
      var r, a;
      if (!this.signal.aborted) {
        this.signal.reason = o, this.signal.aborted = true;
        for (const i of this.signal._onabort)
          i(o);
        (a = (r = this.signal).onabort) == null || a.call(r, o);
      }
    }
  };
  let e = ((fa = rr.env) == null ? void 0 : fa.LRU_CACHE_IGNORE_AC_WARNING) !== "1";
  const t = () => {
    e && (e = false, ja("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", t));
  };
}
var Vl = (e) => !Ba.has(e);
var Lt = (e) => e && e === Math.floor(e) && e > 0 && isFinite(e);
var Na = (e) => Lt(e) ? e <= Math.pow(2, 8) ? Uint8Array : e <= Math.pow(2, 16) ? Uint16Array : e <= Math.pow(2, 32) ? Uint32Array : e <= Number.MAX_SAFE_INTEGER ? fo : null : null;
var fo = class extends Array {
  constructor(t) {
    super(t), this.fill(0);
  }
};
var yn;
var on = class on2 {
  constructor(t, n) {
    te(this, "heap");
    te(this, "length");
    if (!p(on2, yn))
      throw new TypeError("instantiate Stack using Stack.create(n)");
    this.heap = new n(t), this.length = 0;
  }
  static create(t) {
    const n = Na(t);
    if (!n)
      return [];
    ue(on2, yn, true);
    const o = new on2(t, n);
    return ue(on2, yn, false), o;
  }
  push(t) {
    this.heap[this.length++] = t;
  }
  pop() {
    return this.heap[--this.length];
  }
};
yn = /* @__PURE__ */ new WeakMap(), // private constructor
ve(on, yn, false);
var ar = on;
var mt;
var it;
var pt;
var gt;
var wn;
var Ne;
var vt;
var Be;
var Oe;
var he;
var Je;
var st;
var Ye;
var We;
var bt;
var xe;
var yt;
var wt;
var lt;
var _t;
var xt;
var Ze;
var Un;
var sr;
var an;
var Vt;
var Kn;
var ut;
var Oo;
var La;
var sn;
var _n;
var Yn;
var Dt;
var qt;
var kt;
var Ht;
var Gn;
var lr;
var Gh;
var Cn;
var ho;
var Sn;
var mo;
var De;
var ke;
var Xn;
var ur;
var ln;
var $n;
var Vr = class Vr2 {
  constructor(t) {
    ve(this, Un);
    ve(this, Oo);
    ve(this, Dt);
    ve(this, kt);
    ve(this, Gn);
    ve(this, Cn);
    ve(this, Sn);
    ve(this, De);
    ve(this, Xn);
    ve(this, ln);
    ve(this, mt, void 0);
    ve(this, it, void 0);
    ve(this, pt, void 0);
    ve(this, gt, void 0);
    ve(this, wn, void 0);
    te(this, "ttl");
    te(this, "ttlResolution");
    te(this, "ttlAutopurge");
    te(this, "updateAgeOnGet");
    te(this, "updateAgeOnHas");
    te(this, "allowStale");
    te(this, "noDisposeOnSet");
    te(this, "noUpdateTTL");
    te(this, "maxEntrySize");
    te(this, "sizeCalculation");
    te(this, "noDeleteOnFetchRejection");
    te(this, "noDeleteOnStaleGet");
    te(this, "allowStaleOnFetchAbort");
    te(this, "allowStaleOnFetchRejection");
    te(this, "ignoreFetchAbort");
    ve(this, Ne, void 0);
    ve(this, vt, void 0);
    ve(this, Be, void 0);
    ve(this, Oe, void 0);
    ve(this, he, void 0);
    ve(this, Je, void 0);
    ve(this, st, void 0);
    ve(this, Ye, void 0);
    ve(this, We, void 0);
    ve(this, bt, void 0);
    ve(this, xe, void 0);
    ve(this, yt, void 0);
    ve(this, wt, void 0);
    ve(this, lt, void 0);
    ve(this, _t, void 0);
    ve(this, xt, void 0);
    ve(this, Ze, void 0);
    ve(this, an, () => {
    });
    ve(this, Vt, () => {
    });
    ve(this, Kn, () => {
    });
    ve(this, ut, () => false);
    ve(this, sn, (t2) => {
    });
    ve(this, _n, (t2, n2, o2) => {
    });
    ve(this, Yn, (t2, n2, o2, r2) => {
      if (o2 || r2)
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      return 0;
    });
    te(this, Gh, "LRUCache");
    const { max: n = 0, ttl: o, ttlResolution: r = 1, ttlAutopurge: a, updateAgeOnGet: i, updateAgeOnHas: s, allowStale: l, dispose: u, disposeAfter: c, noDisposeOnSet: d2, noUpdateTTL: f, maxSize: h2 = 0, maxEntrySize: b = 0, sizeCalculation: m, fetchMethod: _, noDeleteOnFetchRejection: y, noDeleteOnStaleGet: E, allowStaleOnFetchRejection: k, allowStaleOnFetchAbort: O, ignoreFetchAbort: T } = t;
    if (n !== 0 && !Lt(n))
      throw new TypeError("max option must be a nonnegative integer");
    const D = n ? Na(n) : Array;
    if (!D)
      throw new Error("invalid max value: " + n);
    if (ue(this, mt, n), ue(this, it, h2), this.maxEntrySize = b || p(this, it), this.sizeCalculation = m, this.sizeCalculation) {
      if (!p(this, it) && !this.maxEntrySize)
        throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
      if (typeof this.sizeCalculation != "function")
        throw new TypeError("sizeCalculation set to non-function");
    }
    if (_ !== void 0 && typeof _ != "function")
      throw new TypeError("fetchMethod must be a function if specified");
    if (ue(this, wn, _), ue(this, xt, !!_), ue(this, Be, /* @__PURE__ */ new Map()), ue(this, Oe, new Array(n).fill(void 0)), ue(this, he, new Array(n).fill(void 0)), ue(this, Je, new D(n)), ue(this, st, new D(n)), ue(this, Ye, 0), ue(this, We, 0), ue(this, bt, ar.create(n)), ue(this, Ne, 0), ue(this, vt, 0), typeof u == "function" && ue(this, pt, u), typeof c == "function" ? (ue(this, gt, c), ue(this, xe, [])) : (ue(this, gt, void 0), ue(this, xe, void 0)), ue(this, _t, !!p(this, pt)), ue(this, Ze, !!p(this, gt)), this.noDisposeOnSet = !!d2, this.noUpdateTTL = !!f, this.noDeleteOnFetchRejection = !!y, this.allowStaleOnFetchRejection = !!k, this.allowStaleOnFetchAbort = !!O, this.ignoreFetchAbort = !!T, this.maxEntrySize !== 0) {
      if (p(this, it) !== 0 && !Lt(p(this, it)))
        throw new TypeError("maxSize must be a positive integer if specified");
      if (!Lt(this.maxEntrySize))
        throw new TypeError("maxEntrySize must be a positive integer if specified");
      re(this, Oo, La).call(this);
    }
    if (this.allowStale = !!l, this.noDeleteOnStaleGet = !!E, this.updateAgeOnGet = !!i, this.updateAgeOnHas = !!s, this.ttlResolution = Lt(r) || r === 0 ? r : 1, this.ttlAutopurge = !!a, this.ttl = o || 0, this.ttl) {
      if (!Lt(this.ttl))
        throw new TypeError("ttl must be a positive integer if specified");
      re(this, Un, sr).call(this);
    }
    if (p(this, mt) === 0 && this.ttl === 0 && p(this, it) === 0)
      throw new TypeError("At least one of max, maxSize, or ttl is required");
    if (!this.ttlAutopurge && !p(this, mt) && !p(this, it)) {
      const $ = "LRU_CACHE_UNBOUNDED";
      Vl($) && (Ba.add($), ja("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", $, Vr2));
    }
  }
  /**
   * Do not call this method unless you need to inspect the
   * inner workings of the cache.  If anything returned by this
   * object is modified in any way, strange breakage may occur.
   *
   * These fields are private for a reason!
   *
   * @internal
   */
  static unsafeExposeInternals(t) {
    return {
      // properties
      starts: p(t, wt),
      ttls: p(t, lt),
      sizes: p(t, yt),
      keyMap: p(t, Be),
      keyList: p(t, Oe),
      valList: p(t, he),
      next: p(t, Je),
      prev: p(t, st),
      get head() {
        return p(t, Ye);
      },
      get tail() {
        return p(t, We);
      },
      free: p(t, bt),
      // methods
      isBackgroundFetch: (n) => {
        var o;
        return re(o = t, De, ke).call(o, n);
      },
      backgroundFetch: (n, o, r, a) => {
        var i;
        return re(i = t, Sn, mo).call(i, n, o, r, a);
      },
      moveToTail: (n) => {
        var o;
        return re(o = t, ln, $n).call(o, n);
      },
      indexes: (n) => {
        var o;
        return re(o = t, Dt, qt).call(o, n);
      },
      rindexes: (n) => {
        var o;
        return re(o = t, kt, Ht).call(o, n);
      },
      isStale: (n) => {
        var o;
        return p(o = t, ut).call(o, n);
      }
    };
  }
  // Protected read-only members
  /**
   * {@link LRUCache.OptionsBase.max} (read-only)
   */
  get max() {
    return p(this, mt);
  }
  /**
   * {@link LRUCache.OptionsBase.maxSize} (read-only)
   */
  get maxSize() {
    return p(this, it);
  }
  /**
   * The total computed size of items in the cache (read-only)
   */
  get calculatedSize() {
    return p(this, vt);
  }
  /**
   * The number of items stored in the cache (read-only)
   */
  get size() {
    return p(this, Ne);
  }
  /**
   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
   */
  get fetchMethod() {
    return p(this, wn);
  }
  /**
   * {@link LRUCache.OptionsBase.dispose} (read-only)
   */
  get dispose() {
    return p(this, pt);
  }
  /**
   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
   */
  get disposeAfter() {
    return p(this, gt);
  }
  /**
   * Return the remaining TTL time for a given entry key
   */
  getRemainingTTL(t) {
    return p(this, Be).has(t) ? 1 / 0 : 0;
  }
  /**
   * Return a generator yielding `[key, value]` pairs,
   * in order from most recently used to least recently used.
   */
  *entries() {
    for (const t of re(this, Dt, qt).call(this))
      p(this, he)[t] !== void 0 && p(this, Oe)[t] !== void 0 && !re(this, De, ke).call(this, p(this, he)[t]) && (yield [p(this, Oe)[t], p(this, he)[t]]);
  }
  /**
   * Inverse order version of {@link LRUCache.entries}
   *
   * Return a generator yielding `[key, value]` pairs,
   * in order from least recently used to most recently used.
   */
  *rentries() {
    for (const t of re(this, kt, Ht).call(this))
      p(this, he)[t] !== void 0 && p(this, Oe)[t] !== void 0 && !re(this, De, ke).call(this, p(this, he)[t]) && (yield [p(this, Oe)[t], p(this, he)[t]]);
  }
  /**
   * Return a generator yielding the keys in the cache,
   * in order from most recently used to least recently used.
   */
  *keys() {
    for (const t of re(this, Dt, qt).call(this)) {
      const n = p(this, Oe)[t];
      n !== void 0 && !re(this, De, ke).call(this, p(this, he)[t]) && (yield n);
    }
  }
  /**
   * Inverse order version of {@link LRUCache.keys}
   *
   * Return a generator yielding the keys in the cache,
   * in order from least recently used to most recently used.
   */
  *rkeys() {
    for (const t of re(this, kt, Ht).call(this)) {
      const n = p(this, Oe)[t];
      n !== void 0 && !re(this, De, ke).call(this, p(this, he)[t]) && (yield n);
    }
  }
  /**
   * Return a generator yielding the values in the cache,
   * in order from most recently used to least recently used.
   */
  *values() {
    for (const t of re(this, Dt, qt).call(this))
      p(this, he)[t] !== void 0 && !re(this, De, ke).call(this, p(this, he)[t]) && (yield p(this, he)[t]);
  }
  /**
   * Inverse order version of {@link LRUCache.values}
   *
   * Return a generator yielding the values in the cache,
   * in order from least recently used to most recently used.
   */
  *rvalues() {
    for (const t of re(this, kt, Ht).call(this))
      p(this, he)[t] !== void 0 && !re(this, De, ke).call(this, p(this, he)[t]) && (yield p(this, he)[t]);
  }
  /**
   * Iterating over the cache itself yields the same results as
   * {@link LRUCache.entries}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Find a value for which the supplied fn method returns a truthy value,
   * similar to Array.find().  fn is called as fn(value, key, cache).
   */
  find(t, n = {}) {
    for (const o of re(this, Dt, qt).call(this)) {
      const r = p(this, he)[o], a = re(this, De, ke).call(this, r) ? r.__staleWhileFetching : r;
      if (a !== void 0 && t(a, p(this, Oe)[o], this))
        return this.get(p(this, Oe)[o], n);
    }
  }
  /**
   * Call the supplied function on each item in the cache, in order from
   * most recently used to least recently used.  fn is called as
   * fn(value, key, cache).  Does not update age or recenty of use.
   * Does not iterate over stale values.
   */
  forEach(t, n = this) {
    for (const o of re(this, Dt, qt).call(this)) {
      const r = p(this, he)[o], a = re(this, De, ke).call(this, r) ? r.__staleWhileFetching : r;
      a !== void 0 && t.call(n, a, p(this, Oe)[o], this);
    }
  }
  /**
   * The same as {@link LRUCache.forEach} but items are iterated over in
   * reverse order.  (ie, less recently used items are iterated over first.)
   */
  rforEach(t, n = this) {
    for (const o of re(this, kt, Ht).call(this)) {
      const r = p(this, he)[o], a = re(this, De, ke).call(this, r) ? r.__staleWhileFetching : r;
      a !== void 0 && t.call(n, a, p(this, Oe)[o], this);
    }
  }
  /**
   * Delete any stale entries. Returns true if anything was removed,
   * false otherwise.
   */
  purgeStale() {
    let t = false;
    for (const n of re(this, kt, Ht).call(this, { allowStale: true }))
      p(this, ut).call(this, n) && (this.delete(p(this, Oe)[n]), t = true);
    return t;
  }
  /**
   * Get the extended info about a given entry, to get its value, size, and
   * TTL info simultaneously. Like {@link LRUCache#dump}, but just for a
   * single key. Always returns stale values, if their info is found in the
   * cache, so be sure to check for expired TTLs if relevant.
   */
  info(t) {
    const n = p(this, Be).get(t);
    if (n === void 0)
      return;
    const o = p(this, he)[n], r = re(this, De, ke).call(this, o) ? o.__staleWhileFetching : o;
    if (r === void 0)
      return;
    const a = { value: r };
    if (p(this, lt) && p(this, wt)) {
      const i = p(this, lt)[n], s = p(this, wt)[n];
      if (i && s) {
        const l = i - (dn.now() - s);
        a.ttl = l, a.start = Date.now();
      }
    }
    return p(this, yt) && (a.size = p(this, yt)[n]), a;
  }
  /**
   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
   * passed to cache.load()
   */
  dump() {
    const t = [];
    for (const n of re(this, Dt, qt).call(this, { allowStale: true })) {
      const o = p(this, Oe)[n], r = p(this, he)[n], a = re(this, De, ke).call(this, r) ? r.__staleWhileFetching : r;
      if (a === void 0 || o === void 0)
        continue;
      const i = { value: a };
      if (p(this, lt) && p(this, wt)) {
        i.ttl = p(this, lt)[n];
        const s = dn.now() - p(this, wt)[n];
        i.start = Math.floor(Date.now() - s);
      }
      p(this, yt) && (i.size = p(this, yt)[n]), t.unshift([o, i]);
    }
    return t;
  }
  /**
   * Reset the cache and load in the items in entries in the order listed.
   * Note that the shape of the resulting cache may be different if the
   * same options are not used in both caches.
   */
  load(t) {
    this.clear();
    for (const [n, o] of t) {
      if (o.start) {
        const r = Date.now() - o.start;
        o.start = dn.now() - r;
      }
      this.set(n, o.value, o);
    }
  }
  /**
   * Add a value to the cache.
   *
   * Note: if `undefined` is specified as a value, this is an alias for
   * {@link LRUCache#delete}
   */
  set(t, n, o = {}) {
    var f, h2, b, m, _;
    if (n === void 0)
      return this.delete(t), this;
    const { ttl: r = this.ttl, start: a, noDisposeOnSet: i = this.noDisposeOnSet, sizeCalculation: s = this.sizeCalculation, status: l } = o;
    let { noUpdateTTL: u = this.noUpdateTTL } = o;
    const c = p(this, Yn).call(this, t, n, o.size || 0, s);
    if (this.maxEntrySize && c > this.maxEntrySize)
      return l && (l.set = "miss", l.maxEntrySizeExceeded = true), this.delete(t), this;
    let d2 = p(this, Ne) === 0 ? void 0 : p(this, Be).get(t);
    if (d2 === void 0)
      d2 = p(this, Ne) === 0 ? p(this, We) : p(this, bt).length !== 0 ? p(this, bt).pop() : p(this, Ne) === p(this, mt) ? re(this, Cn, ho).call(this, false) : p(this, Ne), p(this, Oe)[d2] = t, p(this, he)[d2] = n, p(this, Be).set(t, d2), p(this, Je)[p(this, We)] = d2, p(this, st)[d2] = p(this, We), ue(this, We, d2), no(this, Ne)._++, p(this, _n).call(this, d2, c, l), l && (l.set = "add"), u = false;
    else {
      re(this, ln, $n).call(this, d2);
      const y = p(this, he)[d2];
      if (n !== y) {
        if (p(this, xt) && re(this, De, ke).call(this, y)) {
          y.__abortController.abort(new Error("replaced"));
          const { __staleWhileFetching: E } = y;
          E !== void 0 && !i && (p(this, _t) && ((f = p(this, pt)) == null || f.call(this, E, t, "set")), p(this, Ze) && ((h2 = p(this, xe)) == null || h2.push([E, t, "set"])));
        } else
          i || (p(this, _t) && ((b = p(this, pt)) == null || b.call(this, y, t, "set")), p(this, Ze) && ((m = p(this, xe)) == null || m.push([y, t, "set"])));
        if (p(this, sn).call(this, d2), p(this, _n).call(this, d2, c, l), p(this, he)[d2] = n, l) {
          l.set = "replace";
          const E = y && re(this, De, ke).call(this, y) ? y.__staleWhileFetching : y;
          E !== void 0 && (l.oldValue = E);
        }
      } else
        l && (l.set = "update");
    }
    if (r !== 0 && !p(this, lt) && re(this, Un, sr).call(this), p(this, lt) && (u || p(this, Kn).call(this, d2, r, a), l && p(this, Vt).call(this, l, d2)), !i && p(this, Ze) && p(this, xe)) {
      const y = p(this, xe);
      let E;
      for (; E = y == null ? void 0 : y.shift(); )
        (_ = p(this, gt)) == null || _.call(this, ...E);
    }
    return this;
  }
  /**
   * Evict the least recently used item, returning its value or
   * `undefined` if cache is empty.
   */
  pop() {
    var t;
    try {
      for (; p(this, Ne); ) {
        const n = p(this, he)[p(this, Ye)];
        if (re(this, Cn, ho).call(this, true), re(this, De, ke).call(this, n)) {
          if (n.__staleWhileFetching)
            return n.__staleWhileFetching;
        } else if (n !== void 0)
          return n;
      }
    } finally {
      if (p(this, Ze) && p(this, xe)) {
        const n = p(this, xe);
        let o;
        for (; o = n == null ? void 0 : n.shift(); )
          (t = p(this, gt)) == null || t.call(this, ...o);
      }
    }
  }
  /**
   * Check if a key is in the cache, without updating the recency of use.
   * Will return false if the item is stale, even though it is technically
   * in the cache.
   *
   * Will not update item age unless
   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
   */
  has(t, n = {}) {
    const { updateAgeOnHas: o = this.updateAgeOnHas, status: r } = n, a = p(this, Be).get(t);
    if (a !== void 0) {
      const i = p(this, he)[a];
      if (re(this, De, ke).call(this, i) && i.__staleWhileFetching === void 0)
        return false;
      if (p(this, ut).call(this, a))
        r && (r.has = "stale", p(this, Vt).call(this, r, a));
      else
        return o && p(this, an).call(this, a), r && (r.has = "hit", p(this, Vt).call(this, r, a)), true;
    } else
      r && (r.has = "miss");
    return false;
  }
  /**
   * Like {@link LRUCache#get} but doesn't update recency or delete stale
   * items.
   *
   * Returns `undefined` if the item is stale, unless
   * {@link LRUCache.OptionsBase.allowStale} is set.
   */
  peek(t, n = {}) {
    const { allowStale: o = this.allowStale } = n, r = p(this, Be).get(t);
    if (r === void 0 || !o && p(this, ut).call(this, r))
      return;
    const a = p(this, he)[r];
    return re(this, De, ke).call(this, a) ? a.__staleWhileFetching : a;
  }
  async fetch(t, n = {}) {
    const {
      // get options
      allowStale: o = this.allowStale,
      updateAgeOnGet: r = this.updateAgeOnGet,
      noDeleteOnStaleGet: a = this.noDeleteOnStaleGet,
      // set options
      ttl: i = this.ttl,
      noDisposeOnSet: s = this.noDisposeOnSet,
      size: l = 0,
      sizeCalculation: u = this.sizeCalculation,
      noUpdateTTL: c = this.noUpdateTTL,
      // fetch exclusive options
      noDeleteOnFetchRejection: d2 = this.noDeleteOnFetchRejection,
      allowStaleOnFetchRejection: f = this.allowStaleOnFetchRejection,
      ignoreFetchAbort: h2 = this.ignoreFetchAbort,
      allowStaleOnFetchAbort: b = this.allowStaleOnFetchAbort,
      context: m,
      forceRefresh: _ = false,
      status: y,
      signal: E
    } = n;
    if (!p(this, xt))
      return y && (y.fetch = "get"), this.get(t, {
        allowStale: o,
        updateAgeOnGet: r,
        noDeleteOnStaleGet: a,
        status: y
      });
    const k = {
      allowStale: o,
      updateAgeOnGet: r,
      noDeleteOnStaleGet: a,
      ttl: i,
      noDisposeOnSet: s,
      size: l,
      sizeCalculation: u,
      noUpdateTTL: c,
      noDeleteOnFetchRejection: d2,
      allowStaleOnFetchRejection: f,
      allowStaleOnFetchAbort: b,
      ignoreFetchAbort: h2,
      status: y,
      signal: E
    };
    let O = p(this, Be).get(t);
    if (O === void 0) {
      y && (y.fetch = "miss");
      const T = re(this, Sn, mo).call(this, t, O, k, m);
      return T.__returned = T;
    } else {
      const T = p(this, he)[O];
      if (re(this, De, ke).call(this, T)) {
        const ie = o && T.__staleWhileFetching !== void 0;
        return y && (y.fetch = "inflight", ie && (y.returnedStale = true)), ie ? T.__staleWhileFetching : T.__returned = T;
      }
      const D = p(this, ut).call(this, O);
      if (!_ && !D)
        return y && (y.fetch = "hit"), re(this, ln, $n).call(this, O), r && p(this, an).call(this, O), y && p(this, Vt).call(this, y, O), T;
      const $ = re(this, Sn, mo).call(this, t, O, k, m), M = $.__staleWhileFetching !== void 0 && o;
      return y && (y.fetch = D ? "stale" : "refresh", M && D && (y.returnedStale = true)), M ? $.__staleWhileFetching : $.__returned = $;
    }
  }
  /**
   * Return a value from the cache. Will update the recency of the cache
   * entry found.
   *
   * If the key is not found, get() will return `undefined`.
   */
  get(t, n = {}) {
    const { allowStale: o = this.allowStale, updateAgeOnGet: r = this.updateAgeOnGet, noDeleteOnStaleGet: a = this.noDeleteOnStaleGet, status: i } = n, s = p(this, Be).get(t);
    if (s !== void 0) {
      const l = p(this, he)[s], u = re(this, De, ke).call(this, l);
      return i && p(this, Vt).call(this, i, s), p(this, ut).call(this, s) ? (i && (i.get = "stale"), u ? (i && o && l.__staleWhileFetching !== void 0 && (i.returnedStale = true), o ? l.__staleWhileFetching : void 0) : (a || this.delete(t), i && o && (i.returnedStale = true), o ? l : void 0)) : (i && (i.get = "hit"), u ? l.__staleWhileFetching : (re(this, ln, $n).call(this, s), r && p(this, an).call(this, s), l));
    } else
      i && (i.get = "miss");
  }
  /**
   * Deletes a key out of the cache.
   * Returns true if the key was deleted, false otherwise.
   */
  delete(t) {
    var o, r, a, i;
    let n = false;
    if (p(this, Ne) !== 0) {
      const s = p(this, Be).get(t);
      if (s !== void 0)
        if (n = true, p(this, Ne) === 1)
          this.clear();
        else {
          p(this, sn).call(this, s);
          const l = p(this, he)[s];
          if (re(this, De, ke).call(this, l) ? l.__abortController.abort(new Error("deleted")) : (p(this, _t) || p(this, Ze)) && (p(this, _t) && ((o = p(this, pt)) == null || o.call(this, l, t, "delete")), p(this, Ze) && ((r = p(this, xe)) == null || r.push([l, t, "delete"]))), p(this, Be).delete(t), p(this, Oe)[s] = void 0, p(this, he)[s] = void 0, s === p(this, We))
            ue(this, We, p(this, st)[s]);
          else if (s === p(this, Ye))
            ue(this, Ye, p(this, Je)[s]);
          else {
            const u = p(this, st)[s];
            p(this, Je)[u] = p(this, Je)[s];
            const c = p(this, Je)[s];
            p(this, st)[c] = p(this, st)[s];
          }
          no(this, Ne)._--, p(this, bt).push(s);
        }
    }
    if (p(this, Ze) && ((a = p(this, xe)) != null && a.length)) {
      const s = p(this, xe);
      let l;
      for (; l = s == null ? void 0 : s.shift(); )
        (i = p(this, gt)) == null || i.call(this, ...l);
    }
    return n;
  }
  /**
   * Clear the cache entirely, throwing away all values.
   */
  clear() {
    var t, n, o;
    for (const r of re(this, kt, Ht).call(this, { allowStale: true })) {
      const a = p(this, he)[r];
      if (re(this, De, ke).call(this, a))
        a.__abortController.abort(new Error("deleted"));
      else {
        const i = p(this, Oe)[r];
        p(this, _t) && ((t = p(this, pt)) == null || t.call(this, a, i, "delete")), p(this, Ze) && ((n = p(this, xe)) == null || n.push([a, i, "delete"]));
      }
    }
    if (p(this, Be).clear(), p(this, he).fill(void 0), p(this, Oe).fill(void 0), p(this, lt) && p(this, wt) && (p(this, lt).fill(0), p(this, wt).fill(0)), p(this, yt) && p(this, yt).fill(0), ue(this, Ye, 0), ue(this, We, 0), p(this, bt).length = 0, ue(this, vt, 0), ue(this, Ne, 0), p(this, Ze) && p(this, xe)) {
      const r = p(this, xe);
      let a;
      for (; a = r == null ? void 0 : r.shift(); )
        (o = p(this, gt)) == null || o.call(this, ...a);
    }
  }
};
Gh = Symbol.toStringTag, mt = /* @__PURE__ */ new WeakMap(), it = /* @__PURE__ */ new WeakMap(), pt = /* @__PURE__ */ new WeakMap(), gt = /* @__PURE__ */ new WeakMap(), wn = /* @__PURE__ */ new WeakMap(), Ne = /* @__PURE__ */ new WeakMap(), vt = /* @__PURE__ */ new WeakMap(), Be = /* @__PURE__ */ new WeakMap(), Oe = /* @__PURE__ */ new WeakMap(), he = /* @__PURE__ */ new WeakMap(), Je = /* @__PURE__ */ new WeakMap(), st = /* @__PURE__ */ new WeakMap(), Ye = /* @__PURE__ */ new WeakMap(), We = /* @__PURE__ */ new WeakMap(), bt = /* @__PURE__ */ new WeakMap(), xe = /* @__PURE__ */ new WeakMap(), yt = /* @__PURE__ */ new WeakMap(), wt = /* @__PURE__ */ new WeakMap(), lt = /* @__PURE__ */ new WeakMap(), _t = /* @__PURE__ */ new WeakMap(), xt = /* @__PURE__ */ new WeakMap(), Ze = /* @__PURE__ */ new WeakMap(), Un = /* @__PURE__ */ new WeakSet(), sr = function() {
  const t = new fo(p(this, mt)), n = new fo(p(this, mt));
  ue(this, lt, t), ue(this, wt, n), ue(this, Kn, (a, i, s = dn.now()) => {
    if (n[a] = i !== 0 ? s : 0, t[a] = i, i !== 0 && this.ttlAutopurge) {
      const l = setTimeout(() => {
        p(this, ut).call(this, a) && this.delete(p(this, Oe)[a]);
      }, i + 1);
      l.unref && l.unref();
    }
  }), ue(this, an, (a) => {
    n[a] = t[a] !== 0 ? dn.now() : 0;
  }), ue(this, Vt, (a, i) => {
    if (t[i]) {
      const s = t[i], l = n[i];
      if (!s || !l)
        return;
      a.ttl = s, a.start = l, a.now = o || r();
      const u = a.now - l;
      a.remainingTTL = s - u;
    }
  });
  let o = 0;
  const r = () => {
    const a = dn.now();
    if (this.ttlResolution > 0) {
      o = a;
      const i = setTimeout(() => o = 0, this.ttlResolution);
      i.unref && i.unref();
    }
    return a;
  };
  this.getRemainingTTL = (a) => {
    const i = p(this, Be).get(a);
    if (i === void 0)
      return 0;
    const s = t[i], l = n[i];
    if (!s || !l)
      return 1 / 0;
    const u = (o || r()) - l;
    return s - u;
  }, ue(this, ut, (a) => {
    const i = n[a], s = t[a];
    return !!s && !!i && (o || r()) - i > s;
  });
}, an = /* @__PURE__ */ new WeakMap(), Vt = /* @__PURE__ */ new WeakMap(), Kn = /* @__PURE__ */ new WeakMap(), ut = /* @__PURE__ */ new WeakMap(), Oo = /* @__PURE__ */ new WeakSet(), La = function() {
  const t = new fo(p(this, mt));
  ue(this, vt, 0), ue(this, yt, t), ue(this, sn, (n) => {
    ue(this, vt, p(this, vt) - t[n]), t[n] = 0;
  }), ue(this, Yn, (n, o, r, a) => {
    if (re(this, De, ke).call(this, o))
      return 0;
    if (!Lt(r))
      if (a) {
        if (typeof a != "function")
          throw new TypeError("sizeCalculation must be a function");
        if (r = a(o, n), !Lt(r))
          throw new TypeError("sizeCalculation return invalid (expect positive integer)");
      } else
        throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
    return r;
  }), ue(this, _n, (n, o, r) => {
    if (t[n] = o, p(this, it)) {
      const a = p(this, it) - t[n];
      for (; p(this, vt) > a; )
        re(this, Cn, ho).call(this, true);
    }
    ue(this, vt, p(this, vt) + t[n]), r && (r.entrySize = o, r.totalCalculatedSize = p(this, vt));
  });
}, sn = /* @__PURE__ */ new WeakMap(), _n = /* @__PURE__ */ new WeakMap(), Yn = /* @__PURE__ */ new WeakMap(), Dt = /* @__PURE__ */ new WeakSet(), qt = function* ({ allowStale: t = this.allowStale } = {}) {
  if (p(this, Ne))
    for (let n = p(this, We); !(!re(this, Gn, lr).call(this, n) || ((t || !p(this, ut).call(this, n)) && (yield n), n === p(this, Ye))); )
      n = p(this, st)[n];
}, kt = /* @__PURE__ */ new WeakSet(), Ht = function* ({ allowStale: t = this.allowStale } = {}) {
  if (p(this, Ne))
    for (let n = p(this, Ye); !(!re(this, Gn, lr).call(this, n) || ((t || !p(this, ut).call(this, n)) && (yield n), n === p(this, We))); )
      n = p(this, Je)[n];
}, Gn = /* @__PURE__ */ new WeakSet(), lr = function(t) {
  return t !== void 0 && p(this, Be).get(p(this, Oe)[t]) === t;
}, Cn = /* @__PURE__ */ new WeakSet(), ho = function(t) {
  var a, i;
  const n = p(this, Ye), o = p(this, Oe)[n], r = p(this, he)[n];
  return p(this, xt) && re(this, De, ke).call(this, r) ? r.__abortController.abort(new Error("evicted")) : (p(this, _t) || p(this, Ze)) && (p(this, _t) && ((a = p(this, pt)) == null || a.call(this, r, o, "evict")), p(this, Ze) && ((i = p(this, xe)) == null || i.push([r, o, "evict"]))), p(this, sn).call(this, n), t && (p(this, Oe)[n] = void 0, p(this, he)[n] = void 0, p(this, bt).push(n)), p(this, Ne) === 1 ? (ue(this, Ye, ue(this, We, 0)), p(this, bt).length = 0) : ue(this, Ye, p(this, Je)[n]), p(this, Be).delete(o), no(this, Ne)._--, n;
}, Sn = /* @__PURE__ */ new WeakSet(), mo = function(t, n, o, r) {
  const a = n === void 0 ? void 0 : p(this, he)[n];
  if (re(this, De, ke).call(this, a))
    return a;
  const i = new Co(), { signal: s } = o;
  s == null || s.addEventListener("abort", () => i.abort(s.reason), {
    signal: i.signal
  });
  const l = {
    signal: i.signal,
    options: o,
    context: r
  }, u = (m, _ = false) => {
    const { aborted: y } = i.signal, E = o.ignoreFetchAbort && m !== void 0;
    if (o.status && (y && !_ ? (o.status.fetchAborted = true, o.status.fetchError = i.signal.reason, E && (o.status.fetchAbortIgnored = true)) : o.status.fetchResolved = true), y && !E && !_)
      return d2(i.signal.reason);
    const k = h2;
    return p(this, he)[n] === h2 && (m === void 0 ? k.__staleWhileFetching ? p(this, he)[n] = k.__staleWhileFetching : this.delete(t) : (o.status && (o.status.fetchUpdated = true), this.set(t, m, l.options))), m;
  }, c = (m) => (o.status && (o.status.fetchRejected = true, o.status.fetchError = m), d2(m)), d2 = (m) => {
    const { aborted: _ } = i.signal, y = _ && o.allowStaleOnFetchAbort, E = y || o.allowStaleOnFetchRejection, k = E || o.noDeleteOnFetchRejection, O = h2;
    if (p(this, he)[n] === h2 && (!k || O.__staleWhileFetching === void 0 ? this.delete(t) : y || (p(this, he)[n] = O.__staleWhileFetching)), E)
      return o.status && O.__staleWhileFetching !== void 0 && (o.status.returnedStale = true), O.__staleWhileFetching;
    if (O.__returned === O)
      throw m;
  }, f = (m, _) => {
    var E;
    const y = (E = p(this, wn)) == null ? void 0 : E.call(this, t, a, l);
    y && y instanceof Promise && y.then((k) => m(k === void 0 ? void 0 : k), _), i.signal.addEventListener("abort", () => {
      (!o.ignoreFetchAbort || o.allowStaleOnFetchAbort) && (m(void 0), o.allowStaleOnFetchAbort && (m = (k) => u(k, true)));
    });
  };
  o.status && (o.status.fetchDispatched = true);
  const h2 = new Promise(f).then(u, c), b = Object.assign(h2, {
    __abortController: i,
    __staleWhileFetching: a,
    __returned: void 0
  });
  return n === void 0 ? (this.set(t, b, { ...l.options, status: void 0 }), n = p(this, Be).get(t)) : p(this, he)[n] = b, b;
}, De = /* @__PURE__ */ new WeakSet(), ke = function(t) {
  if (!p(this, xt))
    return false;
  const n = t;
  return !!n && n instanceof Promise && n.hasOwnProperty("__staleWhileFetching") && n.__abortController instanceof Co;
}, Xn = /* @__PURE__ */ new WeakSet(), ur = function(t, n) {
  p(this, st)[n] = t, p(this, Je)[t] = n;
}, ln = /* @__PURE__ */ new WeakSet(), $n = function(t) {
  t !== p(this, We) && (t === p(this, Ye) ? ue(this, Ye, p(this, Je)[t]) : re(this, Xn, ur).call(this, p(this, st)[t], p(this, Je)[t]), re(this, Xn, ur).call(this, p(this, We), t), ue(this, We, t));
};
var ir = Vr;
var oo = new ir({
  max: 500,
  maxSize: 5e3,
  ttl: 1e3 * 60 * 30,
  sizeCalculation: (e, t) => 1
});
var { UnMergeable: Pl } = Re();
function Ml(e) {
  qa = e;
}
var qa = async (e) => (se.warn("请配置 app.use(FsCrud,{dictRequest:(context)=>{ 你的字典请求方法 }})"), []);
var Ha = class extends Pl {
  //loadDict成功后的通知
  constructor(n) {
    super();
    te(this, "cache", false);
    te(this, "prototype", false);
    te(this, "immediate", true);
    te(this, "url");
    te(this, "getData");
    te(this, "value", "value");
    te(this, "label", "label");
    te(this, "labelBuilder");
    te(this, "children", "children");
    te(this, "color", "color");
    te(this, "isTree", false);
    te(this, "_data", null);
    te(this, "originalData");
    te(this, "dataMap", {});
    te(this, "loading", false);
    te(this, "custom", {});
    te(this, "getNodesByValues");
    te(this, "onReady");
    te(this, "notifies", []);
    te(this, "_unfetchValues", {});
    Object.defineProperty(this, "loading", {
      value: false,
      enumerable: false
    }), Object.defineProperty(this, "notifies", {
      value: false,
      enumerable: false
    }), Object.defineProperty(this, "originalData", {
      value: null,
      enumerable: false
    }), this.loading = false, lodash_default_default.merge(this, n), n.data != null && (this.originalData = n.data, this.setData(n.data)), this.toMap();
  }
  get data() {
    return this._data;
  }
  set data(n) {
    this._data = n, this.toMap();
  }
  isDynamic() {
    return this.url instanceof Function || this.getData instanceof Function || this.prototype;
  }
  setData(n) {
    this.data = n;
  }
  /**
   * 加载字典
   */
  async _loadDict(n) {
    if (this.data && !n.reload)
      return this.data;
    if (this.loading)
      return this._registerNotify();
    let o = null;
    if (this.getNodesByValues) {
      if (n.value) {
        let r = null;
        this.cache && this.url && (r = this.url + n.value);
        let a = null;
        if (r && (a = oo.get(r)), a)
          o = a;
        else {
          const i = Array.isArray(n.value) ? n.value : [n.value];
          if (o = await this.getNodesByValues(i, n), o != null && !(o instanceof Array)) {
            se.error("getNodesByValues需要返回数组，当前返回值：", o);
            return;
          }
          r && oo.set(r, o);
        }
      }
    } else if (this.originalData)
      o = this.originalData;
    else {
      this.loading = true;
      try {
        o = await this.getRemoteDictData(n);
      } finally {
        this.loading = false;
      }
    }
    this.data = o, this.onReady && this.onReady({ dict: this, ...n }), this._triggerNotify();
  }
  _triggerNotify() {
    this.notifies && this.notifies.length > 0 && (lodash_default_default.forEach(this.notifies, (n) => {
      n(this.data);
    }), this.notifies.length = 0);
  }
  _registerNotify() {
    let n = null;
    const o = new Promise((r) => {
      n = (a) => {
        r(a);
      };
    });
    return this.notifies || (this.notifies = []), this.notifies.push(n), o;
  }
  /**
   * 加载字典
   * @param context 当prototype=true时会传入
   */
  async loadDict(n) {
    return await this._loadDict({ ...n });
  }
  async reloadDict(n) {
    return await this.loadDict({ ...n, reload: true });
  }
  /**
   * 根据value获取nodes 追加数据
   * @param values
   */
  async appendByValues(n) {
    if (this.getNodesByValues == null) {
      se.warn("请配置getNodesByValues");
      return;
    }
    for (const r of n)
      this.dataMap[r] || this._unfetchValues[r] || (this._unfetchValues[r] = {
        loading: false,
        value: r
      });
    await nextTick(), await nextTick(), await nextTick();
    const o = [];
    if (lodash_default_default.forEach(this._unfetchValues, (r) => {
      r.loading || (r.loading = true, o.push(r.value));
    }), o.length > 0) {
      const r = await this.getNodesByValues(o);
      this.setData([...this.data || [], ...r]);
      for (const a of o)
        delete this._unfetchValues[a];
      return Object.keys(this._unfetchValues).length === 0 && this._triggerNotify(), this.data;
    } else
      return this._registerNotify();
  }
  clear() {
    this.originalData = null, this.setData(null);
  }
  async getRemoteDictData(n) {
    let o, r, a;
    if (this.url && (a = this.url, a instanceof Function && (a = a({ ...n, dict: this })), r = a), this.getData != null)
      o = async () => {
        const i = await this.getData({ url: a, dict: this, ...n });
        return Array.isArray(i) ? i : [];
      };
    else if (a)
      o = async () => {
        const i = await qa({ url: a, dict: this });
        return Array.isArray(i) ? i : [];
      };
    else
      return [];
    if (this.cache && r) {
      let i = oo.get(r);
      if (i == null)
        i = {
          loaded: false,
          loading: true,
          data: void 0,
          callback: []
        }, oo.set(r, i);
      else {
        if (i.loaded)
          return i.data;
        if (i.loading)
          return new Promise((s) => {
            const l = (u) => {
              s(u);
            };
            i.callback.push(l);
          });
      }
      try {
        i.loaded = false, i.loading = true;
        let s = await o();
        s = s || [], s instanceof Array || se.warn("dict data 格式有误，期望格式为数组，实际格式为：", s), i.data = s, i.loaded = true, i.loading = false;
        for (const l of i.callback)
          l(s);
        return i.callback = [], s;
      } catch (s) {
        i.loading = false, i.loaded = false, se.error("load dict error:", s);
      }
    }
    return await o();
  }
  toMap() {
    if (this._data == null) {
      this.dataMap = {};
      return;
    }
    const n = {};
    this.data && this.buildMap(n, this.data || []), this.dataMap = n;
  }
  buildMap(n, o) {
    lodash_default_default.forEach(o, (r) => {
      n[this.getValue(r)] = r, this.isTree && this.getChildren(r) && this.buildMap(n, this.getChildren(r));
    });
  }
  getValue(n) {
    return n[this.value];
  }
  getLabel(n) {
    return this.labelBuilder ? this.labelBuilder(n) : n[this.label];
  }
  getChildren(n) {
    return n[this.children];
  }
  getColor(n) {
    return n[this.color];
  }
  getDictData() {
    return this.data;
  }
  getDictMap() {
    return this.dataMap;
  }
  getNodeByValue(n) {
    return this.dataMap[n];
  }
  getNodesFromDataMap(n) {
    if (n == null)
      return [];
    lodash_default_default.isArray(n) || (n = [n]);
    const o = [];
    return lodash_default_default.forEach(n, (r) => {
      const a = this.dataMap[r];
      a ? o.push(a) : o.push({ [this.value]: r });
    }), o;
  }
};
function Bl(e) {
  const t = shallowReactive(new Ha(e));
  return !t.prototype && t.immediate && t.loadDict(), t;
}
function jl() {
  return {
    dict: Bl,
    setDictRequest: Ml,
    Dict: Ha
  };
}
function lm() {
  return {
    addTypes: gn.addTypes,
    getType: gn.getType,
    getTypes: gn.getTypes,
    install: gn.install
  };
}
async function Nl(e) {
  await nextTick();
  const t = e.getModal();
  if (t == null)
    return;
  const n = t.querySelector(".ant-modal-header");
  if (n == null)
    return;
  const o = t, a = t.style;
  n.style.cursor = "move", n.onmousedown = (i) => {
    const s = i.clientX, l = i.clientY;
    o.style.transform = "translate(0px, 0px)";
    let u, c;
    a.left.includes("%") ? (u = +document.body.clientWidth * (+a.left.replace(/%/g, "") / 100), c = +document.body.clientHeight * (+a.top.replace(/%/g, "") / 100)) : (u = +a.left.replace(/px/g, ""), c = +a.top.replace(/px/g, ""), c = c === 0 ? 100 : c), document.onmousemove = function(d2) {
      const f = d2.clientX - s, h2 = d2.clientY - l;
      o.style.left = `${f + u}px`, o.style.top = `${h2 + c}px`;
    }, document.onmouseup = function(d2) {
      document.onmousemove = null, document.onmouseup = null;
    };
  };
}
async function Ll(e) {
  await nextTick();
  const t = e.getModal();
  if (t == null)
    return;
  const n = t.querySelector(".n-card-header");
  if (n == null)
    return;
  const o = t, a = t.style;
  n.style.cursor = "move", n.onmousedown = (i) => {
    const s = i.clientX, l = i.clientY;
    o.style.transform = "translate(0px, 0px)";
    let u, c;
    a.left.includes("%") ? (u = +document.body.clientWidth * (+a.left.replace(/%/g, "") / 100), c = +document.body.clientHeight * (+a.top.replace(/%/g, "") / 100)) : (u = +a.left.replace(/px/g, ""), c = +a.top.replace(/px/g, "")), document.ondrag = async function(d2) {
      if (d2.clientX == 0 && d2.clientY == 0)
        return;
      const f = d2.clientX - s, h2 = d2.clientY - l;
      o.style.left = `${f + u}px`, o.style.top = `${h2 + c}px`;
    }, document.ondragend = function(d2) {
      document.ondrag = null, document.ondragend = null;
    };
  };
}
async function ql(e) {
  const { ui: t } = R();
  t.type === "antdv" ? await Nl(e) : t.type === "element" || await Ll(e);
}
function Hl() {
  return {
    dragModal: ql
  };
}
var zl = {
  logger: {
    off: {
      tableColumns: false
    }
  }
};
var Wl = defineComponent({
  name: "FsContainer",
  props: {
    /**
     * 是否固定高度
     */
    fixedHeight: {
      type: Boolean,
      default: true
    },
    /**
     * body的样式
     */
    bodyStyle: {
      type: Object,
      default: () => ({})
    },
    /**
     * inner的样式
     */
    innerStyle: {
      type: Object,
      default: () => ({})
    }
  },
  setup(e, t) {
    const { merge: n } = Re(), o = computed(() => e.fixedHeight === false ? n({ position: "relative" }, e.innerStyle) : e.innerStyle), r = computed(() => e.fixedHeight === false ? n({ flex: "unset" }, e.bodyStyle) : e.bodyStyle);
    return {
      computedInnerStyle: o,
      computedBodyStyle: r
    };
  }
});
var xl = { class: "fs-container" };
var Ul = { class: "box" };
var Kl = { class: "header" };
var Yl = { class: "footer" };
function Gl(e, t, n, o, r, a) {
  return openBlock(), createElementBlock("div", xl, [
    createBaseVNode("div", Ul, [
      createBaseVNode("div", {
        class: "inner",
        style: normalizeStyle(e.computedInnerStyle)
      }, [
        createBaseVNode("div", Kl, [
          renderSlot(e.$slots, "header")
        ]),
        createBaseVNode("div", {
          class: "body",
          style: normalizeStyle(e.computedBodyStyle)
        }, [
          renderSlot(e.$slots, "default")
        ], 4),
        createBaseVNode("div", Yl, [
          renderSlot(e.$slots, "footer")
        ])
      ], 4)
    ]),
    renderSlot(e.$slots, "box")
  ]);
}
var Xl = Ee(Wl, [["render", Gl]]);
var Ql = defineComponent({
  name: "FsLayoutDefault"
});
var Jl = { class: "fs-crud-header" };
var Zl = { class: "fs-header-top" };
var eu = { class: "fs-header-middle" };
var tu = { class: "fs-header-bottom" };
var nu = { class: "fs-crud-footer" };
function ou(e, t, n, o, r, a) {
  const i = resolveComponent("fs-container");
  return openBlock(), createBlock(i, { class: "fs-layout-default" }, {
    header: withCtx(() => [
      createBaseVNode("div", Jl, [
        createBaseVNode("div", Zl, [
          renderSlot(e.$slots, "header-top")
        ]),
        renderSlot(e.$slots, "search"),
        createBaseVNode("div", eu, [
          renderSlot(e.$slots, "header-middle")
        ]),
        renderSlot(e.$slots, "actionbar"),
        renderSlot(e.$slots, "toolbar"),
        createBaseVNode("div", tu, [
          renderSlot(e.$slots, "header-bottom")
        ]),
        renderSlot(e.$slots, "tabs")
      ])
    ]),
    footer: withCtx(() => [
      createBaseVNode("div", nu, [
        renderSlot(e.$slots, "footer-top"),
        renderSlot(e.$slots, "pagination"),
        renderSlot(e.$slots, "footer-bottom")
      ])
    ]),
    default: withCtx(() => [
      renderSlot(e.$slots, "default"),
      renderSlot(e.$slots, "table"),
      renderSlot(e.$slots, "form")
    ]),
    _: 3
  });
}
var ru = Ee(Ql, [["render", ou]]);
var au = defineComponent({
  name: "FsLayoutCard",
  setup() {
    const e = inject("get:crudBinding"), t = computed(() => {
      var r, a;
      return e == null ? true : (a = (r = e()) == null ? void 0 : r.search) == null ? void 0 : a.show;
    }), { ui: n } = R(), o = ref(n.card.name);
    return {
      searchShow: t,
      cardComponentName: o
    };
  }
});
var iu = { class: "fs-header-top" };
var su = { class: "fs-header-bottom" };
var lu = { class: "top-bar" };
var uu = { class: "top-bar" };
var cu = { class: "fs-crud-footer" };
function du(e, t, n, o, r, a) {
  const i = resolveComponent("fs-container");
  return openBlock(), createBlock(i, { class: "fs-layout-card" }, createSlots({
    default: withCtx(() => [
      createVNode(i, null, {
        header: withCtx(() => [
          renderSlot(e.$slots, "tabs")
        ]),
        default: withCtx(() => [
          (openBlock(), createBlock(resolveDynamicComponent(e.cardComponentName), { class: "fs-layout-card-body" }, {
            title: withCtx(() => [
              createBaseVNode("div", lu, [
                renderSlot(e.$slots, "actionbar"),
                renderSlot(e.$slots, "toolbar")
              ])
            ]),
            header: withCtx(() => [
              createBaseVNode("div", uu, [
                renderSlot(e.$slots, "actionbar"),
                renderSlot(e.$slots, "toolbar")
              ])
            ]),
            default: withCtx(() => [
              createVNode(i, null, {
                footer: withCtx(() => [
                  createBaseVNode("div", cu, [
                    renderSlot(e.$slots, "footer-top"),
                    renderSlot(e.$slots, "pagination"),
                    renderSlot(e.$slots, "footer-bottom")
                  ])
                ]),
                default: withCtx(() => [
                  renderSlot(e.$slots, "default"),
                  renderSlot(e.$slots, "table"),
                  renderSlot(e.$slots, "form")
                ]),
                _: 3
              })
            ]),
            _: 3
          }))
        ]),
        _: 3
      })
    ]),
    _: 2
  }, [
    e.searchShow ? {
      name: "header",
      fn: withCtx(() => [
        createBaseVNode("div", iu, [
          renderSlot(e.$slots, "header-top")
        ]),
        (openBlock(), createBlock(resolveDynamicComponent(e.cardComponentName), null, {
          default: withCtx(() => [
            renderSlot(e.$slots, "search")
          ]),
          _: 3
        })),
        createBaseVNode("div", su, [
          renderSlot(e.$slots, "header-bottom")
        ])
      ]),
      key: "0"
    } : void 0
  ]), 1024);
}
var fu = Ee(au, [["render", du]]);
function hu(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !isVNode(e);
}
var mu = defineComponent({
  name: "FsButton",
  inheritAttrs: false,
  props: {
    /**
     * 文字
     */
    text: {
      type: String,
      default: "",
      required: false
    },
    /**
     * 图标
     */
    icon: {
      type: [String, Object, Function],
      default: "",
      required: false
    },
    /**
     * 右边的图标
     */
    iconRight: {
      type: [String, Object, Function],
      default: "",
      required: false
    },
    /**
     * 是否圆形按钮，text需配置为null
     */
    circle: {
      type: Boolean,
      default: false,
      required: false
    },
    /**
     * tooltip配置，为空不显示tooltip
     */
    tooltip: {
      type: Object,
      default: void 0
    },
    /**
     * x-button的配置，当x-button的配置与fs-button的配置有冲突时可以配置在此处
     * 比如：n-button的text
     */
    buttonProps: {
      type: Object,
      default: void 0
    },
    className: {}
  },
  setup(e, t) {
    const {
      ui: n
    } = R(), {
      merge: o
    } = Re(), r = (u, c = "fs-button-icon") => {
      if (u != null)
        return typeof u == "string" ? createVNode(resolveComponent("fs-icon"), {
          icon: u,
          class: c
        }, null) : typeof u == "function" ? u() : createVNode(resolveComponent("fs-icon"), mergeProps(u, {
          class: c
        }), null);
    }, a = () => {
      const u = e.icon, c = e.iconRight, d2 = n.type !== "element", f = !d2;
      let h2;
      const b = {
        ...t.slots
      };
      (u && !d2 && !f || t.slots.default || e.text || c) && (b.default = () => {
        const E = [];
        return u && !d2 && !f && E.push(r(u)), t.slots.default && E.push(t.slots.default()), e.text && E.push(e.text), c && E.push(r(c, "fs-button-icon-right")), E;
      }), u && (d2 && !b.icon ? b.icon = () => r(u) : f && !b.icon && (h2 = r(u)));
      const m = e.circle ? n.button.circle : {}, _ = resolveDynamicComponent(n.button.name), y = o({
        ...m,
        //icon,
        class: {
          "fs-button": true,
          "is-thin": !e.text && !t.slots.default
        }
      }, {
        class: e.className,
        ...t.attrs,
        ...e.buttonProps
      });
      return h2 && (y.icon = h2), h(_, y, b);
    };
    if (!e.tooltip)
      return a;
    const i = resolveDynamicComponent(n.tooltip.name), s = computed(() => lodash_default_default.omit(e.tooltip, "slots")), l = n.tooltip.trigger;
    return () => {
      var c;
      const u = {
        ...(c = e.tooltip) == null ? void 0 : c.slots,
        [l]: a
      };
      return createVNode(i, s.value, hu(u) ? u : {
        default: () => [u]
      });
    };
  }
});
var pu = defineComponent({
  name: "FsIcon",
  inheritAttrs: false,
  props: {
    /**
     * icon名称
     */
    icon: {
      type: String,
      default: void 0,
      require: true
    }
  },
  setup(e, t) {
    const {
      ui: n
    } = R(), o = computed(() => {
      var a;
      if (e.icon && ((a = e.icon) == null ? void 0 : a.indexOf(":")) >= 0) {
        if (e.icon.startsWith("svg:")) {
          const s = resolveDynamicComponent("FsIconSvg");
          return () => {
            const l = e.icon.replace("svg:", "");
            return createVNode(s, mergeProps({
              class: "fs-icon",
              icon: l
            }, t.attrs), null);
          };
        }
        const i = resolveDynamicComponent("FsIconify");
        return () => createVNode(i, mergeProps({
          class: "fs-icon",
          icon: e.icon
        }, t.attrs), null);
      }
      const r = resolveDynamicComponent(e.icon);
      return typeof r == "string" ? () => createVNode("span", {
        title: "error icon name"
      }, [r]) : n.icon.isComponent ? () => createVNode(r, mergeProps({
        class: "fs-icon"
      }, t.attrs), null) : () => createVNode(resolveComponent("el-icon"), mergeProps({
        class: "fs-icon"
      }, t.attrs), {
        default: () => [createVNode(r, null, null)]
      });
    });
    return () => o.value();
  }
});
var gu = defineComponent({
  name: "FsIconify",
  components: { Icon },
  props: {
    /**
     * 图标名称
     */
    icon: {
      type: String
    },
    /**
     * 旋转
     */
    spin: {
      type: Boolean,
      default: false
    }
  },
  setup(e, t) {
    return { iconifyRef: ref(null) };
  }
});
function vu(e, t, n, o, r, a) {
  const i = resolveComponent("Icon");
  return openBlock(), createElementBlock("span", {
    class: normalizeClass(["fs-iconify", { "fs-iconify-spin": e.spin }])
  }, [
    createVNode(i, {
      ref: "iconifyRef",
      icon: e.icon
    }, null, 8, ["icon"])
  ], 2);
}
var bu = Ee(gu, [["render", vu]]);
var yu = defineComponent({
  name: "FsSvgIcon",
  props: {
    icon: {
      type: String,
      required: true
    },
    size: {
      type: [Number, String],
      default: 16
    },
    spin: {
      type: Boolean,
      default: false
    }
  },
  setup(e) {
    const t = computed(() => `#${e.icon}`), n = computed(() => {
      const { size: o } = e;
      let r = `${o}`;
      return r = `${r.replace("px", "")}px`, {
        width: r,
        height: r
      };
    });
    return { symbolId: t, getStyle: n };
  }
});
var wu = {
  class: "fs-icon-svg-content",
  "aria-hidden": "true"
};
var _u = ["xlink:href"];
function Cu(e, t, n, o, r, a) {
  return openBlock(), createElementBlock("span", {
    class: normalizeClass(["fs-icon-svg", e.spin && "fs-icon-spin"])
  }, [
    (openBlock(), createElementBlock("svg", wu, [
      createBaseVNode("use", { "xlink:href": e.symbolId }, null, 8, _u)
    ]))
  ], 2);
}
var Su = Ee(yu, [["render", Cu]]);
var Fu = defineComponent({
  name: "FsLabel",
  props: {
    label: {
      type: String,
      default: ""
    },
    labelAttrs: {
      type: Object,
      default: () => ({})
    },
    contentAttrs: {
      type: Object,
      default: () => ({})
    }
  }
});
var Ru = { class: "fs-label" };
function Eu(e, t, n, o, r, a) {
  return openBlock(), createElementBlock("div", Ru, [
    createBaseVNode("div", mergeProps({ class: "label" }, e.labelAttrs), [
      createTextVNode(toDisplayString(e.label) + " ", 1),
      renderSlot(e.$slots, "label")
    ], 16),
    createBaseVNode("div", mergeProps({ class: "content" }, e.contentAttrs), [
      renderSlot(e.$slots, "default")
    ], 16)
  ]);
}
var Du = Ee(Fu, [["render", Eu]]);
var ku = defineComponent({
  name: "FsLoading",
  props: {
    /**
     * 是否loading中
     */
    loading: {},
    icon: {}
  },
  setup(e) {
    const {
      ui: t
    } = R();
    return () => e.loading ? createVNode("div", {
      class: "fs-loading"
    }, [createVNode(resolveComponent("fs-icon"), {
      class: "fs-icon-spin",
      icon: t.icons.refresh
    }, null)]) : null;
  }
});
var Ou = defineComponent({
  name: "FsBox"
});
var $u = { class: "fs-box" };
function Tu(e, t, n, o, r, a) {
  return openBlock(), createElementBlock("div", $u, [
    renderSlot(e.$slots, "default")
  ]);
}
var Au = Ee(Ou, [["render", Tu]]);
function Iu(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !isVNode(e);
}
function xr(e, t) {
  if (e[t] instanceof Array) {
    const n = e[t];
    e[t] = (o) => {
      for (const r of n)
        r(o);
    };
  }
}
var Vu = ["div", "span", "a", "p", "pre", "li", "ol", "ul"];
var Pu = defineComponent({
  name: "FsComponentRender",
  inheritAttrs: false,
  props: {
    /**
     * modelValue
     */
    modelValue: {},
    /**
     * 组件名称
     */
    name: {},
    /**
     * 插槽
     */
    slots: {
      type: Object
    },
    /**
     * 子元素，同slots
     */
    children: {
      type: Object
    },
    /**
     * 事件监听
     */
    on: {
      type: Object
    },
    /**
     * 同 on
     */
    events: {
      type: Object
    },
    /**
     * 上下文scope
     */
    scope: {
      type: Object
    },
    /**
     * modelValue的属性名
     */
    vModel: {
      type: [String, Object]
    },
    /**
     * 组件参数，会与attrs合并
     */
    props: {},
    /**
     * 自定义render
     */
    render: {},
    /**
     * 当输入框的值上报为undefine时，转为null
     */
    undefineToNull: {
      type: Boolean,
      default: true
    }
  },
  emits: ["update:dict", "update:modelValue", "mounted"],
  setup(e, t) {
    const {
      ui: n
    } = R(), {
      merge: o
    } = Re();
    provide("get:scope", () => e.scope), onMounted(() => {
      t.emit("mounted", e.scope);
    });
    const r = ref(), a = computed(() => {
      const h2 = {
        name: "modelValue",
        trim: false,
        number: false,
        transform: void 0
      };
      e.vModel && (typeof e.vModel == "string" ? h2.name = e.vModel : o(h2, e.vModel));
      const b = e.modelValue ?? (n.type === "antdv" ? void 0 : null), m = "onUpdate:" + h2.name, _ = {
        ref: r,
        // scope: props.scope,
        // fix element display false bug
        [h2.name]: b,
        [m]: (E) => {
          if (E && (h2.trim && (E = E.trim()), h2.number)) {
            const k = Number(E);
            isNaN(k) || (E = k);
          }
          h2.transform && (E = h2.transform(E)), E === void 0 && e.undefineToNull && (E = null), t.emit("update:modelValue", E);
        },
        ...e.props
      }, y = {
        ...e.events,
        ...e.on
      };
      return lodash_default_default.forEach(y, (E, k) => {
        const O = E;
        k.startsWith("on") || (k = lodash_default_default.camelCase("on_" + k)), _[k] = (T) => O({
          ...e.scope,
          $event: T
        });
      }), _;
    }), i = () => {
      const h2 = {}, b = (m, _) => {
        m instanceof Function ? h2[_] = (y) => m({
          ...e.scope,
          scope: y
        }) : h2[_] = () => m;
      };
      return lodash_default_default.forEach(e.children, b), lodash_default_default.forEach(e.slots, b), h2;
    }, s = computed(() => {
      const h2 = {
        isAsyncComponent: false,
        component: unref(e.name) || n.input.name
      };
      let b = h2.component;
      return Vu.includes(b) || (typeof b == "string" && (b = resolveComponent(b)), (b == null ? void 0 : b.name) === "AsyncComponentWrapper" && (h2.isAsyncComponent = true)), h2.component = b, h2;
    }), l = i;
    function u() {
      return s.value.isAsyncComponent ? d2() : c();
    }
    function c() {
      return r.value;
    }
    async function d2() {
      const h2 = c();
      return h2 ?? new Promise((b, m) => {
        f(b, m, 0);
      });
    }
    function f(h2, b, m) {
      setTimeout(() => {
        const _ = c();
        if (_ != null) {
          h2(_);
          return;
        }
        if (m++, m > 20) {
          b(new Error("异步组件加载超时"));
          return;
        }
        f(h2, b, m);
      }, 200);
    }
    return t.expose({
      props: e,
      getTargetRefSync: c,
      getTargetRef: u,
      getTargetRefAsync: d2
    }), () => {
      let h2;
      const b = mergeProps(a.value, t.attrs);
      if (xr(b, "onChange"), xr(b, "onBlur"), e.render)
        return e.render({
          ...e.scope,
          attrs: b
        });
      const m = markRaw(s.value.component);
      return createVNode(m, b, Iu(h2 = l()) ? h2 : {
        default: () => [h2]
      });
    };
  }
});
var Mu = defineComponent({
  name: "FsSlotRender",
  inheritAttrs: false,
  props: {
    /**
     * 插槽
     */
    slots: {
      type: Function
    },
    /**
     * 上下文
     */
    scope: {
      type: Object
    }
  },
  setup(e) {
    return () => e.slots(e.scope);
  }
});
var za = defineComponent({
  functional: true,
  name: "FsRender",
  props: {
    renderFunc: {
      type: Function
    },
    scope: {
      type: Object
    }
  },
  setup() {
  },
  render() {
    return this.renderFunc(this.scope);
  }
});
var Bu = defineComponent({
  name: "FsForm",
  props: {
    /**
     * 初始表单数据
     **/
    initialForm: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * 字段模版
     * {
     *   key:{
     *     title: "字段名称",
     *     component:{
     *       name:"组件名称"
     *       ...组件参数
     *     }
     *   }
     * }
     * */
    columns: {
      type: Object,
      default: void 0
    },
    /**
     * 字段分组
     * {
     *   type:'xxx', //分组展示类型
     *   groups:{ //分组数据
     *     groupKey:{ title:'xxx',columns:['fieldKey','fieldKey']}
     *   }
     * }
     */
    group: {
      type: Object,
      default: void 0
    },
    /**
     * 重置表单后的操作
     */
    doReset: {
      type: Function,
      default: void 0
    },
    /**
     * 点击保存按钮，表单校验前执行操作（async）
     */
    beforeValidate: {
      type: Function,
      default: void 0
    },
    /**
     * 表单校验完完成后，提交前处理（async）
     */
    beforeSubmit: {
      type: Function,
      default: void 0
    },
    /**
     * 点击保存按钮时执行操作（async）
     */
    doSubmit: {
      type: Function,
      default: void 0
    },
    /**
     * 表单提交后处理（async）
     */
    afterSubmit: {
      type: Function,
      default: void 0
    },
    /**
     * 插槽内容
     */
    slots: {
      type: Object,
      default: () => ({})
    },
    /**
     * 布局方式【flex|grid】
     */
    display: {
      type: String,
      default: "flex"
      // flex
    },
    /**
     * 序号，编辑时会传入
     */
    index: {
      type: Number,
      default: void 0
    },
    /**
     * 模式 [add,edit,view,自定义]
     */
    mode: {
      type: String,
      default: void 0
    },
    /**
     * a-row配置
     */
    row: {
      type: Object,
      default: void 0
    },
    /**
     * el-col|a-col配置，可配置跨列
     */
    col: {
      type: Object,
      default: void 0
    },
    /**
     * formItem的公共配置
     */
    formItem: {
      type: Object,
      default: void 0
    },
    /**
     * helper位置：{position:'label'}
     */
    helper: {
      type: Object
    },
    watch: {
      type: Function,
      default: null
    }
  },
  emits: ["reset", "submit", "success", "validationError", "value-change", "init"],
  setup(e, t) {
    var oe, g;
    const { merge: n } = Re(), { ui: o } = R(), { AsyncComputeValue: r, doComputed: a } = It(), i = ref(), s = reactive({}), { proxy: l } = getCurrentInstance();
    lodash_default_default.each(e.columns, (v) => {
      v.value != null && (v.value instanceof r || v.value instanceof Po) && se.warn("form.value配置不支持Compute/AsyncCompute类型的动态计算");
    });
    function u() {
      const v = {};
      return lodash_default_default.each(e.columns, (S, R2) => {
        const I = unref(S.value);
        I !== void 0 && lodash_default_default.set(v, R2, I);
      }), n(v, lodash_default_default.cloneDeep(e.initialForm)), v;
    }
    const c = u();
    _(c);
    const d2 = computed(() => ({
      row: c,
      form: s,
      index: e.index,
      mode: e.mode || "add",
      attrs: t.attrs,
      getComponentRef: D
    }));
    function f() {
      return d2.value;
    }
    const h2 = a(() => e.columns, f);
    function b(v) {
      v != null && lodash_default_default.each(e.columns, (S, R2) => {
        let I = lodash_default_default.get(v, R2);
        S.valueBuilder && S.valueBuilder({
          value: I,
          key: R2,
          row: c,
          form: v,
          index: e.index,
          mode: e.mode
        });
      });
    }
    function m() {
      return s;
    }
    function _(v, S = {}) {
      if (b(v), S.mergeForm === false)
        for (const I in s)
          delete s[I];
      n(s, v);
      const { valueChange: R2 } = S;
      R2 && lodash_default_default.forEach(e.columns, (I, P) => {
        const x = s[P];
        k(P, x);
      });
    }
    function y(...v) {
      return n({}, e.col, ...v);
    }
    function E(v) {
      return { key: v.key, ...d2.value };
    }
    function k(v, S) {
      const R2 = { key: v, value: S, formRef: l, ...d2.value, immediate: false };
      t.emit("value-change", R2);
      let I = e.columns[v].valueChange;
      I && (I instanceof Function ? I(R2) : I.handle && I.handle(R2));
    }
    const O = ref({});
    function T(v) {
      return O.value[v];
    }
    function D(v, S = false) {
      var R2;
      return (R2 = T(v)) == null ? void 0 : R2.getComponentRef(S);
    }
    const $ = ref([]);
    lodash_default_default.forEach((oe = e.group) == null ? void 0 : oe.groups, (v, S) => {
      v.collapsed !== true && $.value.push(S);
    }), ((g = e.group) == null ? void 0 : g.groupType) === "tabs" && ($.value = $.value.length > 0 ? $.value[0] : null);
    const F = a(
      () => e.group,
      f,
      null,
      (v) => {
        if (!v)
          return {};
        const S = {};
        lodash_default_default.forEach(v == null ? void 0 : v.groups, (P, x) => {
          lodash_default_default.forEach(P.columns, (G) => {
            if (h2.value[G] == null) {
              Ao.logger.warn("无效的分组字段：" + G);
              return;
            }
            S[G] = x;
          });
        });
        const R2 = v.groupType;
        let I = {
          parent: o.collapse.name,
          child: o.collapseItem.name
        };
        return R2 === "tabs" && (I.parent = o.tabs.name, I.child = o.tabPane.name), n(
          {
            wrapper: I,
            groupedKeys: S
          },
          v
        );
      }
    ), M = computed(() => {
      const v = [];
      return lodash_default_default.forEach(h2.value, (S, R2) => {
        var P, x;
        const I = lodash_default_default.cloneDeep(e.formItem || {});
        S = n(I, S), S.key = R2, S.order == null && (S.order = Gt.orderDefault), (((P = F.value) == null ? void 0 : P.groupedKeys) == null || ((x = F.value) == null ? void 0 : x.groupedKeys[R2]) == null) && v.push(S), S.col = y(S.col);
      }), v.sort((S, R2) => S.order - R2.order), v;
    });
    function ie() {
      return i.value;
    }
    async function Q() {
      const v = u(), S = lodash_default_default.entries(s);
      for (const R2 of S) {
        const I = lodash_default_default.get(v, R2[0]);
        I == null ? lodash_default_default.unset(s, R2[0]) : lodash_default_default.set(s, R2[0], I);
      }
      e.doReset && await e.doReset(d2.value), t.emit("reset");
    }
    const V = ref(), N = ref({});
    function Y(v) {
      var S, R2;
      if ((S = F.value) != null && S.groupedKeys)
        for (let I in v) {
          const P = (R2 = F.value) == null ? void 0 : R2.groupedKeys[I];
          P != null && (v["group." + P] = true);
        }
    }
    async function me() {
      const v = { ...d2.value, form: s };
      if (e.beforeValidate && await e.beforeValidate(v) === false)
        return false;
      try {
        N.value = {}, await o.form.validateWrap(i.value), V.value = true;
      } catch (I) {
        V.value = false;
        const P = o.form.transformValidateErrors(I);
        throw Y(P), N.value = P, t.emit("validationError", d2.value), I;
      }
      const S = lodash_default_default.cloneDeep(toRaw(s)), R2 = { ...d2.value, form: S };
      if (se.debug("form submit", JSON.stringify(s)), lodash_default_default.each(e.columns, (I, P) => {
        let x = lodash_default_default.get(S, P);
        I.valueResolve && I.valueResolve({
          value: x,
          key: P,
          ...R2
        });
      }), e.beforeSubmit && await e.beforeSubmit(R2) === false)
        return false;
      if (lodash_default_default.each(e.columns, (I, P) => {
        I.submit === false ? lodash_default_default.unset(S, P) : I.submit === true && lodash_default_default.set(S, P, S[P]);
      }), e.doSubmit) {
        const I = await e.doSubmit(R2);
        if (R2.res = I, I === false)
          return false;
      }
      return t.emit("submit", R2), e.afterSubmit && await e.afterSubmit(R2) === false ? false : (t.emit("success", R2), R2);
    }
    onMounted(() => {
      lodash_default_default.forEach(h2.value, (v, S) => {
        if (v.valueChange == null)
          return;
        let R2 = v.valueChange;
        if (R2 && R2.immediate === true && R2.handle) {
          const I = { key: S, value: s[S], formRef: l, ...d2.value, immediate: true };
          R2.handle && R2.handle(I);
        }
      });
    });
    function pe(v) {
      return !!(v && v.show !== false);
    }
    function Se(v) {
      if (!v.columns || v.show === false)
        return false;
      for (let S of v.columns) {
        if (h2.value[S] == null)
          continue;
        if (pe(h2.value[S]))
          return true;
      }
      return false;
    }
    e.watch && watch(
      () => s,
      (v, S) => {
        e.watch && e.watch(d2.value);
      },
      {
        deep: true,
        immediate: true
      }
    );
    function Ce() {
      const v = JSON.stringify(c), S = JSON.stringify(s);
      return v !== S;
    }
    const K = computed(() => lodash_default_default.merge({}, e.slots, t.slots));
    return t.emit("init", d2.value), {
      get: (v, S) => lodash_default_default.get(v, S),
      set: (v, S, R2) => {
        lodash_default_default.set(v, S, R2), k(S, R2);
      },
      ui: o,
      validRef: V,
      errorsRef: N,
      formRef: i,
      computedColumns: h2,
      computedDefaultColumns: M,
      submit: me,
      reset: Q,
      getFormRef: ie,
      scope: d2,
      buildItemScope: E,
      groupActiveKey: $,
      form: s,
      formItemRefs: O,
      getFormData: m,
      setFormData: _,
      getComponentRef: D,
      mergeCol: y,
      computedGroup: F,
      getContextFn: f,
      formItemShow: pe,
      groupItemShow: Se,
      isDirty: Ce,
      mergedSlots: K
    };
  }
});
function ju(e, t, n, o, r, a) {
  const i = resolveComponent("fs-form-item"), s = resolveComponent("fs-render");
  return openBlock(), createBlock(resolveDynamicComponent(e.ui.form.name), {
    ref: "formRef",
    class: normalizeClass(["fs-form", {
      "fs-form-grid": e.display === "grid",
      "fs-form-flex": e.display === "flex",
      "fs-form-invalid": e.validRef === false
    }]),
    onsubmit: "event.preventDefault();",
    model: e.form
  }, {
    default: withCtx(() => [
      (openBlock(), createBlock(resolveDynamicComponent(e.ui.row.name), mergeProps({ class: "fs-row" }, e.row), {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(e.computedDefaultColumns, (l) => (openBlock(), createElementBlock(Fragment, {
            key: l == null ? void 0 : l.key
          }, [
            e.formItemShow(l) ? (openBlock(), createBlock(resolveDynamicComponent(e.ui.col.name), mergeProps({
              key: 0,
              class: "fs-col",
              ref_for: true
            }, l.col), {
              default: withCtx(() => [
                l.blank !== true ? (openBlock(), createBlock(i, {
                  key: 0,
                  ref_for: true,
                  ref: (u) => {
                    u && (e.formItemRefs[l.key] = u);
                  },
                  item: l,
                  helper: e.helper,
                  "model-value": e.get(e.form, l.key),
                  "form-slot": e.mergedSlots["form_" + l.key],
                  "get-context-fn": e.getContextFn,
                  "onUpdate:modelValue": (u) => e.set(e.form, l.key, u)
                }, null, 8, ["item", "helper", "model-value", "form-slot", "get-context-fn", "onUpdate:modelValue"])) : createCommentVNode("", true)
              ]),
              _: 2
            }, 1040)) : createCommentVNode("", true)
          ], 64))), 128))
        ]),
        _: 1
      }, 16)),
      e.computedGroup.wrapper ? (openBlock(), createBlock(resolveDynamicComponent(e.computedGroup.wrapper.parent), mergeProps({
        key: 0,
        [e.ui.collapse.modelValue]: e.groupActiveKey,
        ["onUpdate:" + e.ui.collapse.modelValue]: t[0] || (t[0] = (l) => e.groupActiveKey = l),
        style: { width: "100%" }
      }, e.computedGroup), {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(e.computedGroup.groups, (l, u) => (openBlock(), createElementBlock(Fragment, { key: u }, [
            e.groupItemShow(l) ? (openBlock(), createBlock(resolveDynamicComponent(e.computedGroup.wrapper.child), mergeProps({
              key: 0,
              [e.ui.collapse.keyName || ""]: u,
              ref_for: true
            }, l, {
              class: { "fs-form-group-error": e.errorsRef["group." + u] }
            }), createSlots({
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(e.ui.row.name), mergeProps({
                  class: "fs-row",
                  ref_for: true
                }, e.row), {
                  default: withCtx(() => [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(l.columns, (c) => {
                      var d2;
                      return openBlock(), createElementBlock(Fragment, { key: c }, [
                        e.formItemShow(e.computedColumns[c]) ? (openBlock(), createBlock(resolveDynamicComponent(e.ui.col.name), mergeProps({
                          key: 0,
                          class: "fs-col",
                          ref_for: true
                        }, e.mergeCol(l.col, (d2 = e.computedColumns[c]) == null ? void 0 : d2.col)), {
                          default: withCtx(() => {
                            var f;
                            return [
                              e.computedColumns[c] && ((f = e.computedColumns[c]) == null ? void 0 : f.blank) !== true ? (openBlock(), createBlock(i, {
                                key: 0,
                                ref_for: true,
                                ref: (h2) => {
                                  h2 && (e.formItemRefs[c] = h2);
                                },
                                item: e.computedColumns[c],
                                "model-value": e.get(e.form, c),
                                "form-slot": e.mergedSlots["form_" + c],
                                "get-context-fn": e.getContextFn,
                                "onUpdate:modelValue": (h2) => e.set(e.form, c, h2)
                              }, null, 8, ["item", "model-value", "form-slot", "get-context-fn", "onUpdate:modelValue"])) : createCommentVNode("", true)
                            ];
                          }),
                          _: 2
                        }, 1040)) : createCommentVNode("", true)
                      ], 64);
                    }), 128))
                  ]),
                  _: 2
                }, 1040))
              ]),
              _: 2
            }, [
              renderList(l.slots, (c, d2) => ({
                name: d2,
                fn: withCtx((f) => [
                  createVNode(s, {
                    "render-func": c,
                    scope: { ...f, hasError: e.errorsRef["group." + u] }
                  }, null, 8, ["render-func", "scope"])
                ])
              }))
            ]), 1040, ["class"])) : createCommentVNode("", true)
          ], 64))), 128))
        ]),
        _: 1
      }, 16)) : createCommentVNode("", true)
    ]),
    _: 1
  }, 8, ["class", "model"]);
}
var Nu = Ee(Bu, [["render", ju]]);
var Lu = defineComponent({
  name: "FsFormItem",
  components: { FsRender: za },
  props: {
    /**
     * 表单字段值(v-model)
     */
    modelValue: {},
    /**
     * 字段配置
     */
    item: {
      type: Object,
      default: void 0
    },
    /**
     * 字段组件插槽
     */
    formSlot: {
      type: Function,
      default: void 0
    },
    getContextFn: {
      type: Function,
      default: void 0
    },
    helper: {
      type: [String, Object]
    }
  },
  emits: ["update:modelValue"],
  setup(e, t) {
    const { ui: n } = R(), { merge: o } = Re(), r = ref(), a = () => {
      const b = e.getContextFn ? e.getContextFn() : {};
      return { value: e.modelValue, key: e.item.key, ...b };
    };
    function i(b) {
      t.emit("update:modelValue", b);
    }
    function s(b = false) {
      var m, _;
      return b ? (m = r.value) == null ? void 0 : m.getTargetRefAsync() : (_ = r.value) == null ? void 0 : _.getTargetRef();
    }
    const l = computed(() => {
      var b, m, _;
      return ((m = (b = e.item) == null ? void 0 : b.helper) == null ? void 0 : m.position) || ((_ = e.helper) == null ? void 0 : _.position);
    }), u = computed(() => {
      var b, m;
      return o({}, (b = e.item.helper) == null ? void 0 : b.tooltip, (m = e.helper) == null ? void 0 : m.tooltip);
    }), c = computed(() => {
      if (e.item != null)
        return e.item.key.indexOf(".") >= 0 ? e.item.key.split(".") : e.item.key;
    }), d2 = computed(() => e.item.label || e.item.title), f = computed(() => d2.value instanceof Function);
    return {
      ui: n,
      updateModelValue: i,
      scopeFunc: a,
      getComponentRef: s,
      componentRenderRef: r,
      computedHelperPosition: l,
      computedHelperTooltip: u,
      computedKey: c,
      computedLabelIsRender: f,
      computedLabel: d2,
      computedLabelRender: () => d2.value(a())
    };
  }
});
var qu = {
  key: 0,
  class: "fs-form-item-label-text"
};
var Hu = ["title"];
var zu = { class: "fs-form-helper-tooltip" };
var Wu = { class: "fs-form-item-label-icon" };
var xu = { class: "fs-form-item-content" };
var Uu = { class: "fs-form-item-render" };
var Ku = { class: "fs-form-item-component" };
function Yu(e, t, n, o, r, a) {
  const i = resolveComponent("fs-render"), s = resolveComponent("fs-form-helper"), l = resolveComponent("fs-icon"), u = resolveComponent("fs-slot-render"), c = resolveComponent("fs-component-render");
  return e.item ? (openBlock(), createBlock(resolveDynamicComponent(e.ui.formItem.name), mergeProps({
    key: 0,
    class: "fs-form-item",
    [e.ui.formItem.prop || ""]: e.computedKey
  }, e.item, {
    path: e.item.key,
    "rule-path": e.item.key
  }), {
    label: withCtx(() => [
      e.computedLabelIsRender ? (openBlock(), createElementBlock("span", qu, [
        createVNode(i, { "render-func": e.computedLabelRender }, null, 8, ["render-func"])
      ])) : (openBlock(), createElementBlock("span", {
        key: 1,
        class: "fs-form-item-label-text",
        title: e.computedLabel
      }, toDisplayString(e.computedLabel), 9, Hu)),
      e.item.helper && e.computedHelperPosition === "label" ? (openBlock(), createBlock(resolveDynamicComponent(e.ui.tooltip.name), normalizeProps(mergeProps({ key: 2 }, e.computedHelperTooltip)), {
        [e.ui.tooltip.content]: withCtx(() => [
          createBaseVNode("span", zu, [
            createVNode(s, {
              helper: e.item.helper,
              scope: e.scopeFunc()
            }, null, 8, ["helper", "scope"])
          ])
        ]),
        [e.ui.tooltip.trigger]: withCtx(() => [
          createBaseVNode("span", Wu, [
            createVNode(l, {
              class: "fs-form-item-label-icon-inner",
              icon: e.ui.icons.question
            }, null, 8, ["icon"])
          ])
        ]),
        _: 2
      }, 1040)) : createCommentVNode("", true)
    ]),
    default: withCtx(() => {
      var d2;
      return [
        createBaseVNode("div", xu, [
          e.item.topRender ? (openBlock(), createBlock(i, {
            key: 0,
            "render-func": e.item.topRender,
            scope: e.scopeFunc()
          }, null, 8, ["render-func", "scope"])) : createCommentVNode("", true),
          createBaseVNode("div", Uu, [
            e.item.prefixRender ? (openBlock(), createBlock(i, {
              key: 0,
              "render-func": e.item.prefixRender,
              scope: e.scopeFunc()
            }, null, 8, ["render-func", "scope"])) : createCommentVNode("", true),
            createBaseVNode("div", Ku, [
              e.formSlot ? (openBlock(), createBlock(u, {
                key: 0,
                slots: e.formSlot,
                scope: e.scopeFunc()
              }, null, 8, ["slots", "scope"])) : ((d2 = e.item.component) == null ? void 0 : d2.show) !== false ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                e.item.conditionalRender && e.item.conditionalRender.match && e.item.conditionalRender.match(e.scopeFunc()) ? (openBlock(), createBlock(i, {
                  key: 0,
                  "render-func": e.item.conditionalRender.render,
                  scope: e.scopeFunc()
                }, null, 8, ["render-func", "scope"])) : e.item.render ? (openBlock(), createBlock(i, {
                  key: 1,
                  "render-func": e.item.render,
                  scope: e.scopeFunc()
                }, null, 8, ["render-func", "scope"])) : (openBlock(), createBlock(c, mergeProps({
                  key: 2,
                  ref: "componentRenderRef"
                }, e.item.component, {
                  "model-value": e.modelValue,
                  scope: e.scopeFunc(),
                  "onUpdate:modelValue": e.updateModelValue
                }), null, 16, ["model-value", "scope", "onUpdate:modelValue"]))
              ], 64)) : createCommentVNode("", true)
            ]),
            e.item.suffixRender ? (openBlock(), createBlock(i, {
              key: 1,
              "render-func": e.item.suffixRender,
              scope: e.scopeFunc()
            }, null, 8, ["render-func", "scope"])) : createCommentVNode("", true)
          ]),
          e.item.bottomRender ? (openBlock(), createBlock(i, {
            key: 1,
            "render-func": e.item.bottomRender,
            scope: e.scopeFunc()
          }, null, 8, ["render-func", "scope"])) : createCommentVNode("", true),
          e.item.helper && e.computedHelperPosition !== "label" ? (openBlock(), createBlock(s, {
            key: 2,
            helper: e.item.helper,
            scope: e.scopeFunc()
          }, null, 8, ["helper", "scope"])) : createCommentVNode("", true)
        ])
      ];
    }),
    _: 1
  }, 16, ["path", "rule-path"])) : createCommentVNode("", true);
}
var Gu = Ee(Lu, [["render", Yu]]);
var Xu = defineComponent({
  name: "FsFormHelper",
  props: {
    /**
     * 帮助说明, text: 说明文字, render: function(scope) 自定义渲染
     */
    helper: {
      type: [
        /**
         * text: 说明文字,
         * render: function , 自定义render
         */
        Object,
        /**
         * 说明文本
         */
        String
      ]
    },
    scope: {}
  },
  setup(e) {
  }
});
var Qu = { class: "fs-form-helper" };
var Ju = { key: 0 };
var Zu = { key: 2 };
function ec(e, t, n, o, r, a) {
  const i = resolveComponent("fs-render");
  return openBlock(), createElementBlock("div", Qu, [
    typeof e.helper == "string" ? (openBlock(), createElementBlock("pre", Ju, toDisplayString(e.helper), 1)) : e.helper.render ? (openBlock(), createBlock(i, {
      key: 1,
      "render-func": e.helper.render,
      scope: e.scope
    }, null, 8, ["render-func", "scope"])) : e.helper.text ? (openBlock(), createElementBlock("pre", Zu, toDisplayString(e.helper.text), 1)) : createCommentVNode("", true)
  ]);
}
var tc = Ee(Xu, [["render", ec]]);
function nc(e) {
  return typeof e == "function" || Object.prototype.toString.call(e) === "[object Object]" && !isVNode(e);
}
var Wn = defineComponent({
  name: "FsFormWrapper",
  props: {
    /**
     * 表单配置
     * {
     *     wrapper:{ //表单包装配置
     *         is: 'el-dialog'//el-dialog|a-modal|el-drawer|a-drawer,
     *         draggable: false, //是否支持拖动
     *         inner:false //是否在页面内部打开
     *     }
     *     ...FsForm配置
     * }
     */
    options: {},
    /**
     * 插槽
     */
    slots: {},
    /**
     * 是否在内部打开对话框
     */
    inner: {},
    /**
     * 内部打开对话框的wrapper
     */
    innerWrapper: {},
    id: {},
    zIndex: {}
  },
  emits: ["reset", "submit", "validationError", "value-change", "open", "opened", "mounted", "closed", "inner-change"],
  setup(e, t) {
    const {
      t: n
    } = et(), {
      merge: o
    } = Re(), r = ref(false), a = ref(), i = ref(), s = ref(), l = ref(), u = ref(), c = ref(false), d2 = ref(), f = ref(), h2 = ref(), b = ref(), m = e.id || Math.floor(Math.random() * 1e6) + "", _ = "fs-form-wrapper_" + m, y = ref({});
    function E() {
      var P;
      return {
        wrapper: s.value,
        options: i.value,
        formRef: u.value,
        form: Y(),
        wrapperBindRef: s,
        formOptionsRef: i,
        setFormData: me,
        getFormData: Y,
        reset: N,
        loading: c,
        close: $,
        doClose: F,
        toggleFullscreen: v,
        submit: V,
        mode: (P = i.value) == null ? void 0 : P.mode
      };
    }
    const k = async (P) => {
      var le;
      const {
        wrapper: x
      } = P;
      x.onOpen && x.onOpen(P), b.value = unref(x.title), a.value = P.wrapper.is, l.value = x;
      const G = S.formWrapper.customClass(a.value), U = `fs-form-wrapper ${_} ${x[G] || ""} `;
      return s.value = {
        ...lodash_default_default.omit(x, "title", "onOpen", "onClosed", "onOpened", "is", "inner", "beforeClose"),
        [G]: U
      }, i.value = {
        ...lodash_default_default.omit(P, "wrapper", "slots"),
        slots: {
          ...e.slots,
          ...P.slots,
          ...t.slots
        }
      }, y.value = {
        ...e.slots,
        ...(le = P.wrapper) == null ? void 0 : le.slots,
        ...t.slots
      }, d2.value = () => {
        x.onClosed && x.onClosed(E());
      }, f.value = () => {
        x.onOpened && x.onOpened(E());
      }, h2.value = x.beforeClose, x.fullscreen != null && (oe.value = x.fullscreen), t.emit("inner-change", !!l.value.inner), await nextTick(), r.value = true, await nextTick(), ie(), E();
    };
    async function O() {
      var G;
      const P = l.value.saveRemind;
      if (((G = u.value) == null ? void 0 : G.isDirty()) && P) {
        let U = false;
        if (P instanceof Function)
          U = await P();
        else
          try {
            await S.messageBox.confirm({
              title: n("fs.form.saveRemind.title"),
              message: n("fs.form.saveRemind.content"),
              confirmButtonText: n("fs.form.saveRemind.ok"),
              cancelButtonText: n("fs.form.saveRemind.cancel")
            }), U = true;
          } catch {
            U = false;
          }
        U && await V();
      }
    }
    async function T() {
      return h2.value && h2.value(E()) == false ? false : (await O(), true);
    }
    const D = computed(() => S.type == "element" ? {
      beforeClose: (P) => {
        T().then((x) => {
          x && P();
        });
      }
    } : {}), $ = async () => {
      r.value = false;
    }, F = async () => await T() == false ? false : ($(), true), M = () => {
      d2.value && d2.value(), t.emit("closed"), i.value = null;
    }, ie = () => {
      if (f.value && f.value(), s.value.draggable) {
        const {
          dragModal: P
        } = Hl();
        P({
          getModal: () => document.querySelector(`.${_}`)
        });
      }
    }, Q = (P) => {
      t.emit("value-change", P);
    };
    async function V() {
      c.value = true;
      try {
        if (await u.value.submit() === false)
          return;
        $();
      } finally {
        c.value = false;
      }
    }
    async function N() {
      await u.value.reset();
    }
    function Y() {
      var P;
      return (P = u.value) == null ? void 0 : P.getFormData();
    }
    function me(P, x) {
      var G;
      (G = u.value) == null || G.setFormData(P, x);
    }
    const {
      doComputed: pe
    } = It();
    function Se() {
      var P, x, G;
      return {
        row: (P = i.value) == null ? void 0 : P.initialForm,
        form: Y(),
        index: (x = i.value) == null ? void 0 : x.index,
        mode: (G = i.value) == null ? void 0 : G.mode,
        attrs: i.value,
        getComponentRef(...U) {
          var le;
          (le = u.value) == null || le.getComponentRef(...U);
        }
      };
    }
    const Ce = pe(() => {
      var P;
      return (P = s.value) == null ? void 0 : P.buttons;
    }, Se), K = computed(() => {
      const P = {
        cancel: {},
        reset: {},
        ok: {
          loading: c.value
        }
      }, x = o(P, Ce.value), G = [];
      return lodash_default_default.forEach(x, (U, le) => {
        U.key = le, G.push(U), U.onClick == null && U.click != null && (U.onClick = () => {
          U.click(E());
        });
      }), lodash_default_default.sortBy(G, (U) => U.order ?? Gt.orderDefault);
    });
    onMounted(async () => {
      e.options != null && await k(e.options), t.emit("mounted", getCurrentInstance().exposed);
    });
    const oe = ref(false), g = computed(() => {
      var P;
      return !((P = a.value) != null && P.endsWith("drawer"));
    });
    function v() {
      oe.value = !oe.value;
    }
    const S = d.get(), R2 = computed(() => l.value.inner ? S.formWrapper.buildInnerBind({
      getInnerWrapper() {
        if (l.value.innerContainerSelector) {
          const P = document.querySelector(l.value.innerContainerSelector);
          if (P)
            return P.classList.add("fs-form-inner-wrapper"), P;
          console.error(`找不到选择器为${l.value.innerContainerSelector}的元素`);
        }
        return e.innerWrapper;
      }
    }) : {});
    t.expose({
      formWrapperId: m,
      formWrapperIdClass: _,
      close: $,
      doClose: F,
      onClosed: M,
      onOpened: ie,
      open: k,
      title: b,
      fullscreenEnabled: g,
      fullscreen: oe,
      toggleFullscreen: v,
      formOptions: i,
      formWrapperIs: a,
      formWrapperOpen: r,
      formWrapperBind: s,
      formRef: u,
      submit: V,
      reset: N,
      computedButtons: K,
      loading: c,
      getFormData: Y,
      setFormData: me,
      onValueChange: Q,
      innerBind: R2,
      formWrapperSlots: y
    });
    const I = useSlots();
    return () => {
      if (!s.value)
        return null;
      const P = d.get();
      let x = {};
      const G = {
        ...I,
        ...y.value
      }, U = (Rt, Zt, Xe = G) => Xe[Rt] ? Xe[Rt](Zt) : null, le = a.value || "el-dialog";
      if (i.value) {
        const {
          index: Rt,
          mode: Zt
        } = i.value || {}, Xe = {
          _self: this,
          index: Rt,
          mode: Zt,
          getFormData: Y
        };
        x = {
          [P.formWrapper.titleSlotName]: () => {
            let En = null;
            return g.value && (En = createVNode(resolveComponent("fs-icon"), {
              class: "fs-fullscreen-icon",
              onClick: v,
              icon: oe.value ? P.icons.fullScreen : P.icons.unFullScreen
            }, null)), createVNode("div", {
              class: "fs-form-header"
            }, [createVNode("div", {
              class: "fs-form-header-left"
            }, [U("form-header-left", Xe), b.value, U("form-header-right", Xe)]), createVNode("div", {
              class: "fs-form-header-action"
            }, [U("form-header-action-left", Xe), En, U("form-header-action-right", Xe)])]);
          },
          default: () => {
            const En = [];
            return lodash_default_default.forEach(K.value, (Pr) => {
              Pr.show !== false && En.push(createVNode(resolveComponent("fs-button"), Pr, null));
            }), createVNode("div", {
              class: "fs-form-wrapper-body"
            }, [createVNode("div", {
              class: "fs-form-body"
            }, [U("form-body-top", Xe), createVNode("div", {
              class: "fs-form-content"
            }, [U("form-body-left", Xe), createVNode(resolveComponent("fs-form"), mergeProps({
              ref: u
            }, i.value, {
              onValueChange: Q
            }), null), U("form-body-right", Xe)]), U("form-body-bottom", Xe)]), createVNode("div", {
              class: "fs-form-footer-btns"
            }, [U("form-footer-left", Xe), En, U("form-footer-right", Xe)])]);
          }
        };
      }
      if (P.formWrapper.hasContentWrap) {
        const Rt = P.formWrapper.hasContentWrap(le), Zt = x;
        if (Rt) {
          const Xe = resolveDynamicComponent(Rt);
          x = {
            default: () => createVNode(Xe, null, nc(Zt) ? Zt : {
              default: () => [Zt]
            })
          };
        }
      }
      const Ie = P.formWrapper.visible, ot = {
        [Ie]: r.value,
        ["onUpdate:" + Ie]: async (Rt) => {
          if (Rt === false && r.value)
            return await F();
          r.value = Rt;
        }
      }, Qt = P.formWrapper.buildOnClosedBind(le, M), Jt = P.formWrapper.customClass(le), gi = `${oe.value ? "fs-fullscreen" : ""} ${s.value[Jt] || ""}`, vi = {
        [Jt]: gi
      }, bi = {
        fullscreen: oe.value
      }, yi = {
        zIndex: s.value.zIndex || e.zIndex
      }, wi = resolveDynamicComponent(le);
      return createVNode(wi, mergeProps(s.value, vi, ot, Qt, bi, R2.value, yi, D.value), x);
    };
  }
});
var oc = defineComponent({
  name: "FsFormProvider"
});
var rc = defineComponent({
  ...oc,
  setup(e) {
    const t = ref({});
    return provide("use:form:wrapper", () => ({
      open(n) {
        const o = n.id || Math.floor(Math.random() * 1e6) + "";
        return new Promise((r, a) => {
          t.value[o] = {
            id: o,
            // zIndex: getMaxZIndex() + 1,
            async onMounted(i) {
              await i.open(n), r(i);
            },
            onClosed() {
              n.id || delete t.value[o];
            }
          };
        });
      }
    })), (n, o) => (openBlock(), createElementBlock(Fragment, null, [
      renderSlot(n.$slots, "default"),
      (openBlock(true), createElementBlock(Fragment, null, renderList(t.value, (r) => (openBlock(), createBlock(unref(Wn), mergeProps({
        key: r.id,
        ref_for: true
      }, r), null, 16))), 128))
    ], 64));
  }
});
function ac(e, t) {
  provide("get:columns", () => e.table.columns), provide("update:columns", (n) => {
    t.emit("update:columns", n);
  }), provide("get:crudBinding", () => e);
}
function ic(e, t) {
  const n = ref(), o = () => n.value, r = () => n.value ? n.value.getForm() : (se.warn("请使用expose.getSearchFormData代替"), {}), a = () => n.value ? n.value.getValidatedForm() : (se.warn("请使用expose.getSearchValidatedFormData代替"), {});
  function i({ form: s, mergeForm: l = false }) {
    n.value && n.value.setForm(s, l);
  }
  return {
    searchRef: n,
    getSearchRef: o,
    getSearchFormData: r,
    setSearchFormData: i,
    getSearchValidatedFormData: a
  };
}
function sc(e, t, n) {
  return {
    tabsBinding: computed(() => {
      var r, a, i, s, l, u, c;
      if (t.tabs && t.tabs.show && t.tabs.name) {
        let d2 = null;
        const f = { ...t.tabs };
        return (r = t.search) != null && r.columns && ((s = (i = (a = t.search) == null ? void 0 : a.columns[t.tabs.name]) == null ? void 0 : i.component) != null && s.dict) && (d2 = (c = (u = (l = t.search) == null ? void 0 : l.columns[t.tabs.name]) == null ? void 0 : u.component) == null ? void 0 : c.dict, f.value == null && (f.value = d2.value), f.label == null && (f.label = d2.label), f.options == null && (f.options = d2.data || [])), {
          ...f,
          modelValue: t.search.validatedForm && t.search.validatedForm[t.tabs.name],
          "onUpdate:modelValue": (h2) => {
            n.emit("tab-change", { [t.tabs.name]: h2 });
          }
        };
      }
      return {
        show: false
      };
    })
  };
}
function ro(e, t) {
  if (!e)
    return {};
  const n = {};
  return lodash_default_default.forEach(e, (o, r) => {
    r.startsWith(t) && (n[r] = o);
  }), n;
}
function lc(e, t, { tableRef: n, containerRef: o }) {
  const r = d.get();
  if (r.table.hasMaxHeight(e.table))
    return {};
  if (!r.table.fixedHeaderNeedComputeBodyHeight)
    return {};
  const a = ref(null);
  function i() {
    var f;
    const l = (f = n == null ? void 0 : n.value) == null ? void 0 : f.$el;
    if (l == null || l.querySelector == null)
      return;
    const u = l.querySelector(r.table.headerDomSelector);
    if (u == null)
      return;
    const c = l.getBoundingClientRect().height, d2 = u.getBoundingClientRect().height;
    a.value = c - d2 - 2 + (e.table.maxHeightAdjust || 0), se.debug("table max height recomputed ", a.value);
  }
  function s() {
    const l = n.value.$el;
    if (l == null)
      return;
    const u = l.parentNode;
    new ResizeObserver(function(d2) {
      se.debug("table resized", d2), d2.length > 0 && d2[0].contentRect.height > 0 && (i(), setTimeout(() => {
        i();
      }, 200), setTimeout(() => {
        i();
      }, 500));
    }).observe(u);
  }
  return onMounted(async () => {
    await nextTick(), await nextTick(), s();
  }), { maxHeightRef: a, computeBodyHeight: i };
}
function uc(e, t) {
  const n = d.get(), o = ref(), r = ref(), a = ref(), { maxHeightRef: i, computeBodyHeight: s } = lc(e, t, { tableRef: o, containerRef: a }), { merge: l } = Re(), u = toRef(e, "table"), c = computed(() => {
    let T = {};
    (i == null ? void 0 : i.value) != null && (T = n.table.buildMaxHeight(i.value));
    const D = Ao.dash.omit(u, "loading", "columns", "columnsMap");
    return l(T, { ...t.attrs, ...D });
  }), d2 = toRef(e, "toolbar"), f = computed(() => ro(t.slots, "cell")), h2 = computed(() => ro(t.slots, "form")), b = computed(() => ro(t.slots, "search")), m = computed(() => ro(t.slots, "toolbar")), _ = ref(), y = computed(() => {
    const T = { compact: e.toolbar.compact !== false };
    return e.customClass && (T[e.customClass] = true), T;
  }), E = ref(), k = ref(false);
  return {
    tableRef: o,
    containerRef: a,
    toolbarRef: r,
    computedTable: c,
    computedToolbar: d2,
    computedCellSlots: f,
    formWrapperRef: _,
    isFormInner: k,
    onFormInnerChange: (T) => {
      k.value = T;
    },
    computedFormSlots: h2,
    computedSearchSlots: b,
    computedToolbarSlots: m,
    computeBodyHeight: s,
    computedClass: y,
    innerWrapperRef: E
  };
}
var cc = defineComponent({
  name: "FsCrud",
  inheritAttrs: false,
  props: {
    /**
     * 表格配置，见FsTable
     */
    table: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * 表格数据
     */
    // eslint-disable-next-line vue/require-default-prop
    data: {
      type: Array
    },
    /**
     * 操作列配置，见FsRowHandle
     */
    rowHandle: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * 查询框配置，见FsSearch
     */
    search: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * 工具条配置，见FsToolbar
     */
    toolbar: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * 动作条配置，见FsActionbar
     */
    actionbar: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * tabs filter
     */
    tabs: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * 添加表单对话框配置，见FsFormWrapper
     */
    addForm: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * 编辑表单对话框配置，见FsFormWrapper
     */
    editForm: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * 查看表单对话框配置，见FsFormWrapper
     */
    viewForm: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * 翻页配置,支持el-pagination|a-pagination配置
     */
    pagination: {
      type: Object,
      default() {
        return { show: false };
      }
    },
    /**
     * 容器配置，见FsContainer
     */
    container: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * crud包裹容器的class
     */
    customClass: {},
    /**
     * 不要传到fs-table去
     */
    form: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * 可选择
     */
    selection: {
      type: Object,
      default() {
        return { show: false };
      }
    }
  },
  emits: ["update:search", "update:compact", "update:columns", "form-value-change", "update:modelValue", "tab-change"],
  setup(e, t) {
    const { ui: n } = R();
    ac(e, t);
    const o = ic(), r = sc(o, e, t), a = uc(e, t);
    return {
      ui: n,
      ...o,
      ...a,
      ...r
    };
  }
});
var dc = { class: "fs-crud-search" };
var fc = {
  key: 0,
  class: "fs-crud-actionbar"
};
var hc = {
  key: 0,
  class: "fs-crud-toolbar"
};
var mc = { class: "fs-crud-pagination" };
var pc = { class: "fs-pagination-left" };
var gc = { class: "fs-pagination" };
var vc = { class: "fs-pagination-right" };
function bc(e, t, n, o, r, a) {
  var d2;
  const i = resolveComponent("fs-actionbar"), s = resolveComponent("fs-toolbar"), l = resolveComponent("fs-tabs-filter"), u = resolveComponent("fs-table"), c = resolveComponent("fs-form-wrapper");
  return openBlock(), createBlock(resolveDynamicComponent(((d2 = e.container) == null ? void 0 : d2.is) || "fs-layout-default"), mergeProps({
    ref: "containerRef",
    class: "fs-crud-container"
  }, e.container, { class: e.computedClass }), {
    "header-top": withCtx(() => [
      renderSlot(e.$slots, "header-top")
    ]),
    "header-bottom": withCtx(() => [
      renderSlot(e.$slots, "header-bottom")
    ]),
    "header-middle": withCtx(() => [
      renderSlot(e.$slots, "header-middle")
    ]),
    search: withCtx(() => [
      createBaseVNode("div", dc, [
        (openBlock(), createBlock(resolveDynamicComponent(e.search.is || "fs-search"), mergeProps({ ref: "searchRef" }, e.search, { slots: e.computedSearchSlots }), null, 16, ["slots"]))
      ])
    ]),
    actionbar: withCtx(() => [
      e.actionbar && e.actionbar.show !== false ? (openBlock(), createElementBlock("div", fc, [
        renderSlot(e.$slots, "actionbar-left"),
        createVNode(i, normalizeProps(guardReactiveProps(e.actionbar)), null, 16),
        renderSlot(e.$slots, "actionbar-right")
      ])) : createCommentVNode("", true)
    ]),
    toolbar: withCtx(() => [
      e.toolbar && e.toolbar.show !== false ? (openBlock(), createElementBlock("div", hc, [
        renderSlot(e.$slots, "toolbar-left"),
        createVNode(s, mergeProps({ ref: "toolbarRef" }, e.toolbar, {
          slots: e.computedToolbarSlots,
          columns: e.table.columns
        }), null, 16, ["slots", "columns"]),
        renderSlot(e.$slots, "toolbar-right")
      ])) : createCommentVNode("", true)
    ]),
    tabs: withCtx(() => [
      e.tabsBinding.show ? (openBlock(), createBlock(l, mergeProps({
        key: 0,
        ref: "tabsRef",
        class: "fs-tabs"
      }, e.tabsBinding), null, 16)) : createCommentVNode("", true)
    ]),
    table: withCtx(() => [
      createVNode(u, mergeProps({
        ref: "tableRef",
        class: "fs-crud-table"
      }, e.computedTable, {
        columns: e.table.columns,
        loading: e.table.loading,
        "row-handle": e.rowHandle,
        data: e.data,
        "cell-slots": e.computedCellSlots
      }), null, 16, ["columns", "loading", "row-handle", "data", "cell-slots"])
    ]),
    form: withCtx(() => [
      createBaseVNode("div", {
        ref: "innerWrapperRef",
        class: normalizeClass(["fs-form-wrapper-container", { "fs-form-inner-wrapper": e.isFormInner }])
      }, [
        createVNode(c, {
          ref: "formWrapperRef",
          slots: e.computedFormSlots,
          "inner-wrapper": e.innerWrapperRef,
          onInnerChange: e.onFormInnerChange,
          onValueChange: t[0] || (t[0] = (f) => e.$emit("form-value-change", f))
        }, null, 8, ["slots", "inner-wrapper", "onInnerChange"])
      ], 2)
    ]),
    pagination: withCtx(() => [
      createBaseVNode("div", mc, [
        createBaseVNode("div", pc, [
          renderSlot(e.$slots, "pagination-left")
        ]),
        createBaseVNode("div", gc, [
          e.pagination.show !== false ? (openBlock(), createBlock(resolveDynamicComponent(e.ui.pagination.name), normalizeProps(mergeProps({ key: 0 }, e.pagination)), null, 16)) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", vc, [
          renderSlot(e.$slots, "pagination-right")
        ])
      ])
    ]),
    "footer-top": withCtx(() => [
      renderSlot(e.$slots, "footer-top")
    ]),
    "footer-bottom": withCtx(() => [
      renderSlot(e.$slots, "footer-bottom")
    ]),
    default: withCtx(() => [
      renderSlot(e.$slots, "default")
    ]),
    _: 3
  }, 16, ["class"]);
}
var yc = Ee(cc, [["render", bc]]);
var wc = defineComponent({
  name: "FsRowHandle",
  props: {
    /**
     * 按钮折叠配置
     */
    dropdown: {
      type: Object
    },
    /**
     * 按钮配置
     * {
     *   view:{...FsButton,click:Function,order:1},
     *   edit:{...FsButton,click:Function,order:2},
     *   remove:{...FsButton,click:Function,order:3},
     *   ...自定义
     * }
     */
    buttons: {
      type: Object
    },
    /**
     * 按钮分组,上面的buttons为默认分组
     *  {
     *    groupKey:{buttonKey:{},buttonKey2:{}}
     *  }
     */
    group: {
      type: Object
    },
    /**
     * 当前激活分组
     */
    active: {
      type: String,
      default: "default"
    },
    /**
     * scope
     */
    scope: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ["handle"],
  setup(e, t) {
    const { ui: n } = R(), { merge: o } = Re(), { t: r } = et(), a = (m) => {
      const _ = e.scope[n.tableColumn.index], y = e.scope[n.tableColumn.row], E = { key: m.key, row: y, btn: m, index: _, ...e.scope };
      if (m.click)
        return m.click(E);
      t.emit("handle", E);
    }, { doComputed: i } = It(), s = computed(() => ({
      dropdown: e.dropdown,
      buttons: e.buttons,
      active: e.active,
      group: e.group
    })), l = i(
      () => s.value,
      () => {
        const m = e.scope[n.tableColumn.index], _ = e.scope[n.tableColumn.row];
        return { ...e.scope, index: m, row: _ };
      }
    ), u = computed(() => {
      let m = null;
      if (l.value.active == null || l.value.active === "default") {
        const y = {
          view: {
            key: "view",
            text: r("fs.rowHandle.view.text"),
            title: r("fs.rowHandle.view.text")
          },
          copy: {
            key: "copy",
            text: r("fs.rowHandle.copy.text"),
            title: r("fs.rowHandle.copy.text")
          },
          edit: {
            key: "edit",
            type: "primary",
            text: r("fs.rowHandle.edit.text"),
            title: r("fs.rowHandle.edit.text")
          },
          remove: {
            key: "remove",
            ...n.button.colors("danger"),
            text: r("fs.rowHandle.remove.text"),
            title: r("fs.rowHandle.remove.text")
          }
        };
        m = o(y, l.value.buttons);
      } else
        m = l.value.group[l.value.active];
      const _ = [];
      return lodash_default_default.forEach(m, (y, E) => {
        y.key = E, y.show !== false && _.push(y);
      }), lodash_default_default.sortBy(_, (y) => y.order ?? Gt.orderDefault);
    }), c = computed(() => l.value.dropdown == null || l.value.dropdown.atLeast == null || l.value.dropdown.atLeast <= 0 || u.value.length <= l.value.dropdown.atLeast ? 0 : l.value.dropdown.atLeast || 0);
    function d2(m, _) {
      return m.dropdown === true || c.value > 0 && c.value < _;
    }
    const f = computed(() => {
      let m = 0;
      for (const _ of u.value) {
        if (d2(_, m))
          return true;
        m++;
      }
      return false;
    });
    function h2(m) {
      for (let _ of u.value)
        if (m === _.key) {
          a(_);
          return;
        }
    }
    const b = computed(() => {
      const m = {};
      if (n.dropdown.renderMode !== "slot") {
        const _ = u.value, y = [];
        lodash_default_default.forEach(_, (E, k) => {
          E.show !== false && d2(E, k) && y.push({
            [n.dropdown.value]: E.key,
            [n.dropdown.label]: E.text,
            title: E.title
          });
        }), m.options = y;
      }
      return {
        ...lodash_default_default.omit(e.dropdown, "more", "atLeast"),
        ...n.dropdown.command(h2),
        ...m
      };
    });
    return {
      ui: n,
      hasDropdownBtn: f,
      computedHandleBtns: u,
      doDropdownItemClick: h2,
      computedDropdownAtLeast: c,
      doClick: a,
      isDropdownBtn: d2,
      computedDropdownBinding: b
    };
  }
});
var _c = { class: "fs-row-handle" };
var Cc = {
  key: 0,
  class: "row-handle-btn fs-handle-row-dropdown"
};
function Sc(e, t, n, o, r, a) {
  const i = resolveComponent("fs-button"), s = resolveComponent("fs-icon");
  return openBlock(), createElementBlock("div", _c, [
    renderSlot(e.$slots, "cell-rowHandle-left", normalizeProps(guardReactiveProps(e.scope))),
    (openBlock(true), createElementBlock(Fragment, null, renderList(e.computedHandleBtns, (l, u) => (openBlock(), createElementBlock(Fragment, { key: u }, [
      l.show !== false && !e.isDropdownBtn(l, u) ? (openBlock(), createBlock(i, mergeProps({
        key: 0,
        class: "row-handle-btn",
        ref_for: true
      }, l, {
        onClick: withModifiers((c) => e.doClick(l), ["stop"])
      }), null, 16, ["onClick"])) : createCommentVNode("", true)
    ], 64))), 128)),
    renderSlot(e.$slots, "cell-rowHandle-middle", normalizeProps(guardReactiveProps(e.scope))),
    e.hasDropdownBtn ? (openBlock(), createElementBlock("span", Cc, [
      (openBlock(), createBlock(resolveDynamicComponent(e.ui.dropdown.name), normalizeProps(guardReactiveProps(e.computedDropdownBinding)), {
        [e.ui.dropdown.slotName]: withCtx(() => [
          e.ui.dropdown.renderMode === "slot" ? (openBlock(), createBlock(resolveDynamicComponent(e.ui.dropdownMenu.name), normalizeProps(mergeProps({ key: 0 }, e.ui.dropdownMenu.command(e.doDropdownItemClick))), {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(e.computedHandleBtns, (l, u) => (openBlock(), createElementBlock(Fragment, { key: u }, [
                l.show !== false && e.isDropdownBtn(l, u) ? (openBlock(), createBlock(resolveDynamicComponent(e.ui.dropdownItem.name), mergeProps({
                  key: 0,
                  [e.ui.dropdownItem.command || ""]: l.key,
                  ref_for: true
                }, l.dropdownItem, {
                  disabled: l.disabled
                }), {
                  default: withCtx(() => [
                    createBaseVNode("div", mergeProps({
                      class: "fs-row-handle-dropdown-item",
                      ref_for: true
                    }, l), [
                      l.icon ? (openBlock(), createBlock(s, {
                        key: 0,
                        icon: l.icon
                      }, null, 8, ["icon"])) : createCommentVNode("", true),
                      createTextVNode(" " + toDisplayString(l.text || l.title), 1)
                    ], 16)
                  ]),
                  _: 2
                }, 1040, ["disabled"])) : createCommentVNode("", true)
              ], 64))), 128))
            ]),
            _: 1
          }, 16)) : createCommentVNode("", true)
        ]),
        default: withCtx(() => [
          createVNode(i, normalizeProps(guardReactiveProps(e.dropdown.more)), null, 16)
        ]),
        _: 2
      }, 1040))
    ])) : createCommentVNode("", true),
    renderSlot(e.$slots, "cell-rowHandle-right", normalizeProps(guardReactiveProps(e.scope)))
  ]);
}
var Fc = Ee(wc, [["render", Sc]]);
function rn() {
  return rn = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, rn.apply(this, arguments);
}
function Rc(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, xn(e, t);
}
function cr(e) {
  return cr = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, cr(e);
}
function xn(e, t) {
  return xn = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, r) {
    return o.__proto__ = r, o;
  }, xn(e, t);
}
function Ec() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return false;
  if (typeof Proxy == "function")
    return true;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), true;
  } catch {
    return false;
  }
}
function po(e, t, n) {
  return Ec() ? po = Reflect.construct.bind() : po = function(r, a, i) {
    var s = [null];
    s.push.apply(s, a);
    var l = Function.bind.apply(r, s), u = new l();
    return i && xn(u, i.prototype), u;
  }, po.apply(null, arguments);
}
function Dc(e) {
  return Function.toString.call(e).indexOf("[native code]") !== -1;
}
function dr(e) {
  var t = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return dr = function(o) {
    if (o === null || !Dc(o))
      return o;
    if (typeof o != "function")
      throw new TypeError("Super expression must either be null or a function");
    if (typeof t < "u") {
      if (t.has(o))
        return t.get(o);
      t.set(o, r);
    }
    function r() {
      return po(o, arguments, cr(this).constructor);
    }
    return r.prototype = Object.create(o.prototype, {
      constructor: {
        value: r,
        enumerable: false,
        writable: true,
        configurable: true
      }
    }), xn(r, o);
  }, dr(e);
}
var kc = /%[sdj%]/g;
var Wa = function() {
};
typeof process < "u" && process.env && true && typeof window < "u" && typeof document < "u" && (Wa = function(t, n) {
  typeof console < "u" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING > "u" && n.every(function(o) {
    return typeof o == "string";
  }) && console.warn(t, n);
});
function fr(e) {
  if (!e || !e.length)
    return null;
  var t = {};
  return e.forEach(function(n) {
    var o = n.field;
    t[o] = t[o] || [], t[o].push(n);
  }), t;
}
function dt(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++)
    n[o - 1] = arguments[o];
  var r = 0, a = n.length;
  if (typeof e == "function")
    return e.apply(null, n);
  if (typeof e == "string") {
    var i = e.replace(kc, function(s) {
      if (s === "%%")
        return "%";
      if (r >= a)
        return s;
      switch (s) {
        case "%s":
          return String(n[r++]);
        case "%d":
          return Number(n[r++]);
        case "%j":
          try {
            return JSON.stringify(n[r++]);
          } catch {
            return "[Circular]";
          }
          break;
        default:
          return s;
      }
    });
    return i;
  }
  return e;
}
function Oc(e) {
  return e === "string" || e === "url" || e === "hex" || e === "email" || e === "date" || e === "pattern";
}
function ze(e, t) {
  return !!(e == null || t === "array" && Array.isArray(e) && !e.length || Oc(t) && typeof e == "string" && !e);
}
function $c(e, t, n) {
  var o = [], r = 0, a = e.length;
  function i(s) {
    o.push.apply(o, s || []), r++, r === a && n(o);
  }
  e.forEach(function(s) {
    t(s, i);
  });
}
function Ur(e, t, n) {
  var o = 0, r = e.length;
  function a(i) {
    if (i && i.length) {
      n(i);
      return;
    }
    var s = o;
    o = o + 1, s < r ? t(e[s], a) : n([]);
  }
  a([]);
}
function Tc(e) {
  var t = [];
  return Object.keys(e).forEach(function(n) {
    t.push.apply(t, e[n] || []);
  }), t;
}
var Kr = function(e) {
  Rc(t, e);
  function t(n, o) {
    var r;
    return r = e.call(this, "Async Validation Error") || this, r.errors = n, r.fields = o, r;
  }
  return t;
}(dr(Error));
function Ac(e, t, n, o, r) {
  if (t.first) {
    var a = new Promise(function(f, h2) {
      var b = function(y) {
        return o(y), y.length ? h2(new Kr(y, fr(y))) : f(r);
      }, m = Tc(e);
      Ur(m, n, b);
    });
    return a.catch(function(f) {
      return f;
    }), a;
  }
  var i = t.firstFields === true ? Object.keys(e) : t.firstFields || [], s = Object.keys(e), l = s.length, u = 0, c = [], d2 = new Promise(function(f, h2) {
    var b = function(_) {
      if (c.push.apply(c, _), u++, u === l)
        return o(c), c.length ? h2(new Kr(c, fr(c))) : f(r);
    };
    s.length || (o(c), f(r)), s.forEach(function(m) {
      var _ = e[m];
      i.indexOf(m) !== -1 ? Ur(_, n, b) : $c(_, n, b);
    });
  });
  return d2.catch(function(f) {
    return f;
  }), d2;
}
function Ic(e) {
  return !!(e && e.message !== void 0);
}
function Vc(e, t) {
  for (var n = e, o = 0; o < t.length; o++) {
    if (n == null)
      return n;
    n = n[t[o]];
  }
  return n;
}
function Yr(e, t) {
  return function(n) {
    var o;
    return e.fullFields ? o = Vc(t, e.fullFields) : o = t[n.field || e.fullField], Ic(n) ? (n.field = n.field || e.fullField, n.fieldValue = o, n) : {
      message: typeof n == "function" ? n() : n,
      fieldValue: o,
      field: n.field || e.fullField
    };
  };
}
function Gr(e, t) {
  if (t) {
    for (var n in t)
      if (t.hasOwnProperty(n)) {
        var o = t[n];
        typeof o == "object" && typeof e[n] == "object" ? e[n] = rn({}, e[n], o) : e[n] = o;
      }
  }
  return e;
}
var xa = function(t, n, o, r, a, i) {
  t.required && (!o.hasOwnProperty(t.field) || ze(n, i || t.type)) && r.push(dt(a.messages.required, t.fullField));
};
var Pc = function(t, n, o, r, a) {
  (/^\s+$/.test(n) || n === "") && r.push(dt(a.messages.whitespace, t.fullField));
};
var ao;
var Mc = function() {
  if (ao)
    return ao;
  var e = "[a-fA-F\\d:]", t = function(O) {
    return O && O.includeBoundaries ? "(?:(?<=\\s|^)(?=" + e + ")|(?<=" + e + ")(?=\\s|$))" : "";
  }, n = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", o = "[a-fA-F\\d]{1,4}", r = (`
(?:
(?:` + o + ":){7}(?:" + o + `|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:` + o + ":){6}(?:" + n + "|:" + o + `|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:` + o + ":){5}(?::" + n + "|(?::" + o + `){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:` + o + ":){4}(?:(?::" + o + "){0,1}:" + n + "|(?::" + o + `){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:` + o + ":){3}(?:(?::" + o + "){0,2}:" + n + "|(?::" + o + `){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:` + o + ":){2}(?:(?::" + o + "){0,3}:" + n + "|(?::" + o + `){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:` + o + ":){1}(?:(?::" + o + "){0,4}:" + n + "|(?::" + o + `){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::` + o + "){0,5}:" + n + "|(?::" + o + `){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`).replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), a = new RegExp("(?:^" + n + "$)|(?:^" + r + "$)"), i = new RegExp("^" + n + "$"), s = new RegExp("^" + r + "$"), l = function(O) {
    return O && O.exact ? a : new RegExp("(?:" + t(O) + n + t(O) + ")|(?:" + t(O) + r + t(O) + ")", "g");
  };
  l.v4 = function(k) {
    return k && k.exact ? i : new RegExp("" + t(k) + n + t(k), "g");
  }, l.v6 = function(k) {
    return k && k.exact ? s : new RegExp("" + t(k) + r + t(k), "g");
  };
  var u = "(?:(?:[a-z]+:)?//)", c = "(?:\\S+(?::\\S*)?@)?", d2 = l.v4().source, f = l.v6().source, h2 = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)", b = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*", m = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", _ = "(?::\\d{2,5})?", y = '(?:[/?#][^\\s"]*)?', E = "(?:" + u + "|www\\.)" + c + "(?:localhost|" + d2 + "|" + f + "|" + h2 + b + m + ")" + _ + y;
  return ao = new RegExp("(?:^" + E + "$)", "i"), ao;
};
var Xr = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  // url: new RegExp(
  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
  //   'i',
  // ),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var Tn = {
  integer: function(t) {
    return Tn.number(t) && parseInt(t, 10) === t;
  },
  float: function(t) {
    return Tn.number(t) && !Tn.integer(t);
  },
  array: function(t) {
    return Array.isArray(t);
  },
  regexp: function(t) {
    if (t instanceof RegExp)
      return true;
    try {
      return !!new RegExp(t);
    } catch {
      return false;
    }
  },
  date: function(t) {
    return typeof t.getTime == "function" && typeof t.getMonth == "function" && typeof t.getYear == "function" && !isNaN(t.getTime());
  },
  number: function(t) {
    return isNaN(t) ? false : typeof t == "number";
  },
  object: function(t) {
    return typeof t == "object" && !Tn.array(t);
  },
  method: function(t) {
    return typeof t == "function";
  },
  email: function(t) {
    return typeof t == "string" && t.length <= 320 && !!t.match(Xr.email);
  },
  url: function(t) {
    return typeof t == "string" && t.length <= 2048 && !!t.match(Mc());
  },
  hex: function(t) {
    return typeof t == "string" && !!t.match(Xr.hex);
  }
};
var Bc = function(t, n, o, r, a) {
  if (t.required && n === void 0) {
    xa(t, n, o, r, a);
    return;
  }
  var i = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], s = t.type;
  i.indexOf(s) > -1 ? Tn[s](n) || r.push(dt(a.messages.types[s], t.fullField, t.type)) : s && typeof n !== t.type && r.push(dt(a.messages.types[s], t.fullField, t.type));
};
var jc = function(t, n, o, r, a) {
  var i = typeof t.len == "number", s = typeof t.min == "number", l = typeof t.max == "number", u = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, c = n, d2 = null, f = typeof n == "number", h2 = typeof n == "string", b = Array.isArray(n);
  if (f ? d2 = "number" : h2 ? d2 = "string" : b && (d2 = "array"), !d2)
    return false;
  b && (c = n.length), h2 && (c = n.replace(u, "_").length), i ? c !== t.len && r.push(dt(a.messages[d2].len, t.fullField, t.len)) : s && !l && c < t.min ? r.push(dt(a.messages[d2].min, t.fullField, t.min)) : l && !s && c > t.max ? r.push(dt(a.messages[d2].max, t.fullField, t.max)) : s && l && (c < t.min || c > t.max) && r.push(dt(a.messages[d2].range, t.fullField, t.min, t.max));
};
var fn = "enum";
var Nc = function(t, n, o, r, a) {
  t[fn] = Array.isArray(t[fn]) ? t[fn] : [], t[fn].indexOf(n) === -1 && r.push(dt(a.messages[fn], t.fullField, t[fn].join(", ")));
};
var Lc = function(t, n, o, r, a) {
  if (t.pattern) {
    if (t.pattern instanceof RegExp)
      t.pattern.lastIndex = 0, t.pattern.test(n) || r.push(dt(a.messages.pattern.mismatch, t.fullField, n, t.pattern));
    else if (typeof t.pattern == "string") {
      var i = new RegExp(t.pattern);
      i.test(n) || r.push(dt(a.messages.pattern.mismatch, t.fullField, n, t.pattern));
    }
  }
};
var ye = {
  required: xa,
  whitespace: Pc,
  type: Bc,
  range: jc,
  enum: Nc,
  pattern: Lc
};
var qc = function(t, n, o, r, a) {
  var i = [], s = t.required || !t.required && r.hasOwnProperty(t.field);
  if (s) {
    if (ze(n, "string") && !t.required)
      return o();
    ye.required(t, n, r, i, a, "string"), ze(n, "string") || (ye.type(t, n, r, i, a), ye.range(t, n, r, i, a), ye.pattern(t, n, r, i, a), t.whitespace === true && ye.whitespace(t, n, r, i, a));
  }
  o(i);
};
var Hc = function(t, n, o, r, a) {
  var i = [], s = t.required || !t.required && r.hasOwnProperty(t.field);
  if (s) {
    if (ze(n) && !t.required)
      return o();
    ye.required(t, n, r, i, a), n !== void 0 && ye.type(t, n, r, i, a);
  }
  o(i);
};
var zc = function(t, n, o, r, a) {
  var i = [], s = t.required || !t.required && r.hasOwnProperty(t.field);
  if (s) {
    if (n === "" && (n = void 0), ze(n) && !t.required)
      return o();
    ye.required(t, n, r, i, a), n !== void 0 && (ye.type(t, n, r, i, a), ye.range(t, n, r, i, a));
  }
  o(i);
};
var Wc = function(t, n, o, r, a) {
  var i = [], s = t.required || !t.required && r.hasOwnProperty(t.field);
  if (s) {
    if (ze(n) && !t.required)
      return o();
    ye.required(t, n, r, i, a), n !== void 0 && ye.type(t, n, r, i, a);
  }
  o(i);
};
var xc = function(t, n, o, r, a) {
  var i = [], s = t.required || !t.required && r.hasOwnProperty(t.field);
  if (s) {
    if (ze(n) && !t.required)
      return o();
    ye.required(t, n, r, i, a), ze(n) || ye.type(t, n, r, i, a);
  }
  o(i);
};
var Uc = function(t, n, o, r, a) {
  var i = [], s = t.required || !t.required && r.hasOwnProperty(t.field);
  if (s) {
    if (ze(n) && !t.required)
      return o();
    ye.required(t, n, r, i, a), n !== void 0 && (ye.type(t, n, r, i, a), ye.range(t, n, r, i, a));
  }
  o(i);
};
var Kc = function(t, n, o, r, a) {
  var i = [], s = t.required || !t.required && r.hasOwnProperty(t.field);
  if (s) {
    if (ze(n) && !t.required)
      return o();
    ye.required(t, n, r, i, a), n !== void 0 && (ye.type(t, n, r, i, a), ye.range(t, n, r, i, a));
  }
  o(i);
};
var Yc = function(t, n, o, r, a) {
  var i = [], s = t.required || !t.required && r.hasOwnProperty(t.field);
  if (s) {
    if (n == null && !t.required)
      return o();
    ye.required(t, n, r, i, a, "array"), n != null && (ye.type(t, n, r, i, a), ye.range(t, n, r, i, a));
  }
  o(i);
};
var Gc = function(t, n, o, r, a) {
  var i = [], s = t.required || !t.required && r.hasOwnProperty(t.field);
  if (s) {
    if (ze(n) && !t.required)
      return o();
    ye.required(t, n, r, i, a), n !== void 0 && ye.type(t, n, r, i, a);
  }
  o(i);
};
var Xc = "enum";
var Qc = function(t, n, o, r, a) {
  var i = [], s = t.required || !t.required && r.hasOwnProperty(t.field);
  if (s) {
    if (ze(n) && !t.required)
      return o();
    ye.required(t, n, r, i, a), n !== void 0 && ye[Xc](t, n, r, i, a);
  }
  o(i);
};
var Jc = function(t, n, o, r, a) {
  var i = [], s = t.required || !t.required && r.hasOwnProperty(t.field);
  if (s) {
    if (ze(n, "string") && !t.required)
      return o();
    ye.required(t, n, r, i, a), ze(n, "string") || ye.pattern(t, n, r, i, a);
  }
  o(i);
};
var Zc = function(t, n, o, r, a) {
  var i = [], s = t.required || !t.required && r.hasOwnProperty(t.field);
  if (s) {
    if (ze(n, "date") && !t.required)
      return o();
    if (ye.required(t, n, r, i, a), !ze(n, "date")) {
      var l;
      n instanceof Date ? l = n : l = new Date(n), ye.type(t, l, r, i, a), l && ye.range(t, l.getTime(), r, i, a);
    }
  }
  o(i);
};
var ed = function(t, n, o, r, a) {
  var i = [], s = Array.isArray(n) ? "array" : typeof n;
  ye.required(t, n, r, i, a, s), o(i);
};
var Ho = function(t, n, o, r, a) {
  var i = t.type, s = [], l = t.required || !t.required && r.hasOwnProperty(t.field);
  if (l) {
    if (ze(n, i) && !t.required)
      return o();
    ye.required(t, n, r, s, a, i), ze(n, i) || ye.type(t, n, r, s, a);
  }
  o(s);
};
var td = function(t, n, o, r, a) {
  var i = [], s = t.required || !t.required && r.hasOwnProperty(t.field);
  if (s) {
    if (ze(n) && !t.required)
      return o();
    ye.required(t, n, r, i, a);
  }
  o(i);
};
var Pn = {
  string: qc,
  method: Hc,
  number: zc,
  boolean: Wc,
  regexp: xc,
  integer: Uc,
  float: Kc,
  array: Yc,
  object: Gc,
  enum: Qc,
  pattern: Jc,
  date: Zc,
  url: Ho,
  hex: Ho,
  email: Ho,
  required: ed,
  any: td
};
function hr() {
  return {
    default: "Validation error on field %s",
    required: "%s is required",
    enum: "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      boolean: "%s is not a %s",
      integer: "%s is not an %s",
      float: "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function() {
      var t = JSON.parse(JSON.stringify(this));
      return t.clone = this.clone, t;
    }
  };
}
var mr = hr();
var Zn = function() {
  function e(n) {
    this.rules = null, this._messages = mr, this.define(n);
  }
  var t = e.prototype;
  return t.define = function(o) {
    var r = this;
    if (!o)
      throw new Error("Cannot configure a schema with no rules");
    if (typeof o != "object" || Array.isArray(o))
      throw new Error("Rules must be an object");
    this.rules = {}, Object.keys(o).forEach(function(a) {
      var i = o[a];
      r.rules[a] = Array.isArray(i) ? i : [i];
    });
  }, t.messages = function(o) {
    return o && (this._messages = Gr(hr(), o)), this._messages;
  }, t.validate = function(o, r, a) {
    var i = this;
    r === void 0 && (r = {}), a === void 0 && (a = function() {
    });
    var s = o, l = r, u = a;
    if (typeof l == "function" && (u = l, l = {}), !this.rules || Object.keys(this.rules).length === 0)
      return u && u(null, s), Promise.resolve(s);
    function c(m) {
      var _ = [], y = {};
      function E(O) {
        if (Array.isArray(O)) {
          var T;
          _ = (T = _).concat.apply(T, O);
        } else
          _.push(O);
      }
      for (var k = 0; k < m.length; k++)
        E(m[k]);
      _.length ? (y = fr(_), u(_, y)) : u(null, s);
    }
    if (l.messages) {
      var d2 = this.messages();
      d2 === mr && (d2 = hr()), Gr(d2, l.messages), l.messages = d2;
    } else
      l.messages = this.messages();
    var f = {}, h2 = l.keys || Object.keys(this.rules);
    h2.forEach(function(m) {
      var _ = i.rules[m], y = s[m];
      _.forEach(function(E) {
        var k = E;
        typeof k.transform == "function" && (s === o && (s = rn({}, s)), y = s[m] = k.transform(y)), typeof k == "function" ? k = {
          validator: k
        } : k = rn({}, k), k.validator = i.getValidationMethod(k), k.validator && (k.field = m, k.fullField = k.fullField || m, k.type = i.getType(k), f[m] = f[m] || [], f[m].push({
          rule: k,
          value: y,
          source: s,
          field: m
        }));
      });
    });
    var b = {};
    return Ac(f, l, function(m, _) {
      var y = m.rule, E = (y.type === "object" || y.type === "array") && (typeof y.fields == "object" || typeof y.defaultField == "object");
      E = E && (y.required || !y.required && m.value), y.field = m.field;
      function k(D, $) {
        return rn({}, $, {
          fullField: y.fullField + "." + D,
          fullFields: y.fullFields ? [].concat(y.fullFields, [D]) : [D]
        });
      }
      function O(D) {
        D === void 0 && (D = []);
        var $ = Array.isArray(D) ? D : [D];
        !l.suppressWarning && $.length && e.warning("async-validator:", $), $.length && y.message !== void 0 && ($ = [].concat(y.message));
        var F = $.map(Yr(y, s));
        if (l.first && F.length)
          return b[y.field] = 1, _(F);
        if (!E)
          _(F);
        else {
          if (y.required && !m.value)
            return y.message !== void 0 ? F = [].concat(y.message).map(Yr(y, s)) : l.error && (F = [l.error(y, dt(l.messages.required, y.field))]), _(F);
          var M = {};
          y.defaultField && Object.keys(m.value).map(function(V) {
            M[V] = y.defaultField;
          }), M = rn({}, M, m.rule.fields);
          var ie = {};
          Object.keys(M).forEach(function(V) {
            var N = M[V], Y = Array.isArray(N) ? N : [N];
            ie[V] = Y.map(k.bind(null, V));
          });
          var Q = new e(ie);
          Q.messages(l.messages), m.rule.options && (m.rule.options.messages = l.messages, m.rule.options.error = l.error), Q.validate(m.value, m.rule.options || l, function(V) {
            var N = [];
            F && F.length && N.push.apply(N, F), V && V.length && N.push.apply(N, V), _(N.length ? N : null);
          });
        }
      }
      var T;
      if (y.asyncValidator)
        T = y.asyncValidator(y, m.value, O, m.source, l);
      else if (y.validator) {
        try {
          T = y.validator(y, m.value, O, m.source, l);
        } catch (D) {
          console.error == null || console.error(D), l.suppressValidatorError || setTimeout(function() {
            throw D;
          }, 0), O(D.message);
        }
        T === true ? O() : T === false ? O(typeof y.message == "function" ? y.message(y.fullField || y.field) : y.message || (y.fullField || y.field) + " fails") : T instanceof Array ? O(T) : T instanceof Error && O(T.message);
      }
      T && T.then && T.then(function() {
        return O();
      }, function(D) {
        return O(D);
      });
    }, function(m) {
      c(m);
    }, s);
  }, t.getType = function(o) {
    if (o.type === void 0 && o.pattern instanceof RegExp && (o.type = "pattern"), typeof o.validator != "function" && o.type && !Pn.hasOwnProperty(o.type))
      throw new Error(dt("Unknown rule type %s", o.type));
    return o.type || "string";
  }, t.getValidationMethod = function(o) {
    if (typeof o.validator == "function")
      return o.validator;
    var r = Object.keys(o), a = r.indexOf("message");
    return a !== -1 && r.splice(a, 1), r.length === 1 && r[0] === "required" ? Pn.required : Pn[this.getType(o)] || void 0;
  }, e;
}();
Zn.register = function(t, n) {
  if (typeof n != "function")
    throw new Error("Cannot register a validator by type, validator is not a function");
  Pn[t] = n;
};
Zn.warning = Wa;
Zn.messages = mr;
Zn.validators = Pn;
function nd(e) {
  const t = {};
  for (const n in e) {
    const o = e[n].getForm(), r = o.rules || o.rule, a = n.split(".");
    let i = t;
    if (r)
      for (let s = 0; s < a.length; s++) {
        const l = a[s];
        i[l] || (i[l] = { type: "object", fields: {} }), s == a.length - 1 ? i[l] = r : i = i[l].fields;
      }
  }
  return new Zn(t);
}
function pr(e, t) {
  lodash_default_default.forEach(e, (n) => {
    n.children ? pr(n.children, t) : t(n);
  });
}
function od(e, t) {
  const n = d.get();
  function o() {
    return e.data ? e.data : t.value ? t.value[n.table.data] || [] : [];
  }
  return {
    getData: o,
    insert(r, a) {
      o().splice(r, 0, a);
    },
    unshift(r) {
      o().unshift(r);
    },
    remove(r) {
      o().splice(r, 1);
    },
    get(r) {
      return o()[r];
    }
  };
}
function rd(e, t, n) {
  const o = od(e, n), r = reactive([]);
  function a(g) {
    return typeof e.rowKey == "string" ? g[e.rowKey] : e.rowKey(g);
  }
  function i(g) {
    return g[e.editable.rowKey];
  }
  function s(g) {
    for (const v in r) {
      const S = r[v], R2 = S.cells, I = S.rowData;
      if (g({ rowData: I, row: S, cells: R2 }) === "break")
        return;
    }
  }
  function l(g) {
    s(({ rowData: v, row: S, cells: R2 }) => {
      lodash_default_default.forEach(R2, (I, P) => {
        g({ rowData: v, row: S, cells: R2, cell: I, key: P });
      });
    });
  }
  const { merge: u } = Re(), c = computed(() => u({
    enabled: false,
    //模式，free，row，cell
    mode: "free",
    rowKey: "id",
    addForm: {},
    editForm: {},
    //是否排他式激活，激活一个，其他自动提交或取消
    exclusive: true,
    //排他式激活时，其他的效果，cancel，save
    exclusiveEffect: "cancel",
    //激活触发方式,onClick,onDbClick
    activeTrigger: "onClick",
    //默认激活
    activeDefault: false,
    isEditable(g) {
      return true;
    }
  }, e.editable));
  function d2(g, v, S, R2) {
    function I(le) {
      return lodash_default_default.get(g, le);
    }
    function P(le, Ie) {
      lodash_default_default.set(g, le, Ie);
    }
    const x = computed(() => {
      var le;
      return ((le = R2.editable) == null ? void 0 : le.updateCell) || c.value.updateCell;
    }), G = computed(() => {
      var le;
      return ((le = R2.editable) == null ? void 0 : le.showAction) || c.value.showAction;
    }), U = reactive({
      mode: S < 0 ? "add" : "edit",
      oldValue: void 0,
      newValue: void 0,
      loading: false,
      isEditing: c.value.activeDefault,
      activeTrigger: c.value.activeTrigger,
      column: R2,
      updateCell: x,
      showAction: G,
      isEditable: () => {
        var ot;
        let le = (ot = R2 == null ? void 0 : R2.editable) == null ? void 0 : ot.disabled;
        le instanceof Function && (le = config.disabled({ column: item, editableId: S, row: rowData }));
        let Ie = null;
        return le != null && (Ie = !le), Ie ?? (c.value.isEditable({ editableId: S, key: v, row: g }) || false);
      },
      isChanged: () => U.newValue !== U.oldValue,
      getForm: () => {
        let le = c.value[U.mode + "Form"];
        return le == null && (le = c.value.editForm), le[v];
      },
      active: (le = {}) => {
        (le.exclusive ?? c.value.exclusive) && ((le.exclusiveEffect ?? c.value.exclusiveEffect) === "save" ? O() : T()), U.isEditing = true, U.oldValue = I(v);
        const ot = c.value.editForm[v];
        ot && Q(ot, g);
      },
      inactive: () => {
        U.isEditing = false, U.newValue = I(v);
      },
      resume: () => {
        U.isEditing && (U.isEditing = false, P(v, U.oldValue), delete U.newValue, delete U.oldValue);
      },
      cancel: () => {
        U.resume();
      },
      persist: () => {
        U.isEditing = false, delete U.newValue, delete U.oldValue;
      },
      save: async () => {
        const le = unref(U.updateCell);
        if (!le) {
          se.warn("没有配置table.editable.updateCell方法,无法保存，相关文档：http://fast-crud.docmirror.cn/api/crud-options/table.html#editable");
          return;
        }
        U.loading = true;
        try {
          const Ie = await le({ editableId: S, row: g, key: v, value: I(v) }), ot = g[c.value.rowKey];
          (ot == null || ot <= 0) && ((Ie && Ie[c.value.rowKey]) == null ? se.error(`对于添加的行，updateCell方法需要返回{'id':value}，如果你配置了别的rowKey，需要返回{[rowKey]:id}。
当前返回值:${JSON.stringify(Ie)}`) : g[c.value.rowKey] = Ie[c.value.rowKey]), U.persist();
        } finally {
          U.loading = false;
        }
      }
    });
    return U;
  }
  function f(g, v) {
    const S = {};
    pr(e.columns, (G) => {
      S[G.key] = d2(v, G.key, g, G);
    });
    const R2 = computed(() => nd(S)), I = a(v), P = I == null || I < 0, x = reactive({
      isAdd: P,
      rowData: v,
      editableId: g,
      isEditing: false,
      loading: false,
      cells: S,
      validator: R2,
      inactive: () => {
        x.isEditing = false, lodash_default_default.forEach(x.cells, (G) => {
          G.isEditing && G.inactive();
        });
      },
      active: () => {
        x.isEditing = true, lodash_default_default.forEach(x.cells, (G) => {
          G.active({ exclusive: false });
        });
      },
      persist: () => {
        x.isEditing = false, x.inactive(), delete x.isAdd, lodash_default_default.forEach(x.cells, (G) => {
          G.persist();
        });
      },
      resume: () => {
        x.isEditing = false, lodash_default_default.forEach(x.cells, (G) => {
          G.resume();
        });
      },
      cancel: () => {
        x.resume();
      },
      validate: async (G) => {
        try {
          return lodash_default_default.forEach(x.cells, (U, le) => {
            U.validateErrors = [];
          }), G == null && (G = x.rowData), await x.validator.validate(G), true;
        } catch (U) {
          const { errors: le, fields: Ie } = U;
          return lodash_default_default.forEach(Ie, (ot, Qt) => {
            const Jt = x.cells[Qt];
            Jt && (Jt.validateErrors = ot);
          }), Ie;
        }
      },
      getRowData: () => {
        const G = lodash_default_default.cloneDeep(x.rowData);
        return delete G[e.editable.rowKey], delete G.children, G;
      },
      save: async (G) => {
        const { doSave: U } = G, le = x.rowData, { merge: Ie } = Re();
        if (await x.validate() !== true)
          return;
        function Qt(Rn) {
          Rn && (a(Rn) == null && console.error("保存接口没有返回rowKey,无法更新该行的id,newRow:", Rn), Ie(le, Rn));
        }
        x.loading = true;
        const Jt = x.getRowData();
        try {
          await U({ isAdd: x.isAdd, row: Jt, setData: Qt }), x.persist();
        } finally {
          x.loading = false;
        }
      }
    });
    if (watch(() => v, async (G, U, le) => {
      await x.validate();
    }, {
      deep: true
    }), v.children && v.children.length > 0)
      for (const G of v.children) {
        G[e.editable.rowKey] || (G[e.editable.rowKey] = b());
        const U = G[e.editable.rowKey];
        r[U] = f(U, G);
      }
    return P && x.active(), x;
  }
  let h2 = 0;
  function b() {
    return h2++, h2;
  }
  function m(g) {
    g == null && (g = o.getData());
    const v = Object.assign({}, r);
    lodash_default_default.forOwn(r, (S, R2) => {
      delete r[R2];
    }), lodash_default_default.forEach(g, (S) => {
      S[e.editable.rowKey] || (S[e.editable.rowKey] = b());
      const R2 = S[e.editable.rowKey];
      v[R2] ? r[R2] = v[R2] : r[R2] = f(R2, S);
    }), c.value.onSetup && c.value.onSetup();
  }
  function _(g) {
    const v = e.editable.rowKey, S = [];
    for (const R2 of g) {
      const I = { [v]: R2[v] };
      R2.children && R2.children.length && (I.children = _(R2.children)), S.push(I);
    }
    return S;
  }
  watch(() => {
    const g = e.data;
    let v = [];
    return g != null && g instanceof Array && (v = _(g)), JSON.stringify(v);
  }, (g, v) => {
    c.value.enabled && m(e.data);
  }, {
    immediate: true
  }), watch(() => c.value.enabled, (g) => {
    var v;
    g && (((v = o.getData()) == null ? void 0 : v.length) > 0 && m(), c.value.onEnabled && c.value.onEnabled({ ...c.value }));
  }, {
    immediate: true
  }), watch(() => c.value.mode, () => {
    c.value.onEnabled && c.value.onEnabled({ ...c.value });
  });
  function y(g, v) {
    var S;
    if (v != null)
      return (S = r[g]) == null ? void 0 : S.cells[v];
  }
  function E(g = {}) {
    l(({ cell: v }) => {
      v.active({ ...g, exclusive: false });
    });
  }
  function k() {
    l(({ cell: g }) => {
      g.isEditing && g.inactive();
    });
  }
  async function O() {
    l(({ cell: g }) => {
      g.isEditing && g.save();
    });
  }
  function T() {
    l(({ cell: g }) => {
      g.isEditing && g.cancel();
    });
  }
  function D() {
    k(), s(({ row: g }) => {
      delete g.isAdd;
    }), l(({ cell: g }) => {
      delete g.newValue, delete g.oldValue;
    });
  }
  function $() {
    l(({ cell: g }) => {
      g.resume();
    });
  }
  function F() {
    let g = false;
    return s(({ cells: v }) => {
      lodash_default_default.forEach(v, (S) => {
        if (S.isChanged())
          return g = true, "break";
      });
    }), g;
  }
  let M = 0;
  function ie(g, v) {
    pr(g, (S) => {
      Q(S, v);
    });
  }
  function Q(g, v) {
    const S = lodash_default_default.get(v, g.key), R2 = unref(g.value);
    R2 != null && S == null && lodash_default_default.set(v, g.key, R2);
  }
  async function V(g = { row: void 0, active: true }) {
    let v = g.row || { [c.value.rowKey]: --M, [e.rowKey]: M };
    if (ie(c.value.addForm, v), g.addRowFunc) {
      const S = await g.addRowFunc({ row: g.row });
      S && (v = S);
    } else if (e.editable.addRow) {
      const S = await e.editable.addRow(o.getData(), v);
      S && (v = S);
    } else
      o.unshift(v);
    if (g.active ?? e.editable.activeDefault) {
      await nextTick();
      const S = i(v), R2 = pe(S);
      R2 && R2.active();
    }
  }
  function N(g, v) {
    for (let S = 0; S < v.length; S++) {
      const R2 = v[S];
      if (i(R2) === g)
        return lodash_default_default.remove(v, R2), true;
      if (R2.children && R2.children.length > 0 && N(g, R2.children))
        return;
    }
    return false;
  }
  function Y(g) {
    delete r[g], N(g, o.getData());
  }
  function me(g) {
    const { cols: v } = g;
    s(({ cells: S }) => {
      lodash_default_default.forEach(v, (R2) => {
        S[R2].active({ ...g, exclusive: false });
      });
    });
  }
  function pe(g) {
    return r[g];
  }
  function Se() {
    const g = [];
    return s(({ row: v }) => {
      v.isEditing && g.push(v);
    }), g;
  }
  async function Ce() {
    const g = {};
    let v = false;
    for (const S in r) {
      const R2 = r[S], I = await R2.validate();
      I != true && (g[R2.editableId] = I, v = true);
    }
    return v ? g : true;
  }
  function K(g) {
    for (const v of g)
      delete v[e.editable.rowKey], v.children && v.children.length > 0 && K(v.children);
    return g;
  }
  function oe(g) {
    return g == null && (g = lodash_default_default.cloneDeep(o.getData())), g == null ? [] : K(g);
  }
  return {
    editable: {
      options: c,
      setupEditable: m,
      inactive: k,
      active: E,
      persist: D,
      saveEach: O,
      cancelAll: T,
      resume: $,
      addRow: V,
      removeRow: Y,
      getEditableRow: pe,
      activeCols: me,
      hasDirty: F,
      getEditableCell: y,
      eachRows: s,
      eachCells: l,
      validate: Ce,
      getCleanTableData: oe,
      getActiveRows: Se
    }
  };
}
function ad(e) {
  const t = (o, r) => lodash_default_default.get(e, `value[${o}].${r}`);
  provide("componentRef:get", t);
  const n = (o, r, a) => lodash_default_default.set(e, `value[${o}].${r}`, a);
  return provide("componentRef:set", n), {
    getter: t,
    setter: n
  };
}
function id({
  props: e,
  ui: t,
  sortedColumns: n,
  renderRowHandle: o,
  renderCellComponent: r
}) {
  resolveDynamicComponent(t.table.name);
  const a = resolveDynamicComponent(t.tableColumn.name), i = resolveDynamicComponent(t.tableColumnGroup.name);
  t.tableColumn;
  const s = {};
  return s.default = () => {
    const l = [], u = (c) => {
      const d2 = {}, f = "cell_" + c.key;
      let h2 = a;
      if (c.children)
        d2.default = () => {
          const m = [];
          return lodash_default_default.forEach(c.children, (_) => {
            _.show !== false && m.push(u(_));
          }), m;
        }, h2 = i;
      else if (c.type != null) {
        se.debug("cell render column.type:", c.type);
        const m = e.cellSlots && e.cellSlots[f];
        m && (d2.default = m);
      } else
        d2.default = (m) => r(c, m);
      const b = {
        ...c
      };
      return delete b.children, createVNode(h2, mergeProps({
        ref: "tableColumnRef"
      }, b, {
        label: c.title,
        prop: c.key,
        dataIndex: c.key
      }), d2);
    };
    if (lodash_default_default.forEach(n, (c) => {
      c.show !== false && l.push(u(c));
    }), e.rowHandle && e.rowHandle.show !== false) {
      const c = {
        default: o
      };
      l.push(createVNode(a, mergeProps({
        ref: "tableColumnRef"
      }, e.rowHandle, {
        label: e.rowHandle.title,
        prop: e.rowHandle.key || "rowHandle"
      }), c));
    }
    return l;
  }, e.slots && lodash_default_default.forEach(e.slots, (l, u) => {
    s[u] = l;
  }), s;
}
function Ua(e) {
  var l;
  const {
    props: t,
    renderRowHandle: n,
    renderCellComponent: o,
    sortedColumns: r
  } = e, {
    ui: a
  } = R(), i = r ?? {}, s = [];
  for (const u in i) {
    const c = i[u];
    if (c.show === false)
      continue;
    const d2 = {
      ...c
    };
    if (d2.dataIndex = c.key, s.push(d2), c.children != null) {
      const f = {
        ...e,
        sortedColumns: c.children
      };
      delete f.renderRowHandle, d2.children = Ua(f);
    } else if (c.type == null) {
      const f = d2[a.table.renderMethod], h2 = {
        ...d2
      };
      delete h2[a.table.renderMethod], f ? d2[a.table.renderMethod] = (b, m, _) => {
        const y = a.table.rebuildRenderScope(b, m, _);
        return f(y, () => o(h2, y));
      } : d2[a.table.renderMethod] = (b, m, _) => {
        const y = a.table.rebuildRenderScope(b, m, _);
        return o(h2, y);
      };
    }
  }
  if (n && ((l = t.rowHandle) == null ? void 0 : l.show) !== false) {
    const u = {
      key: "_rowHandle",
      ...t.rowHandle
    };
    u[a.table.renderMethod] = (c, d2, f) => {
      const h2 = a.table.rebuildRenderScope(c, d2, f);
      return n(h2);
    }, s.push(u);
  }
  return se.debug("table columns:", s), s;
}
var sd = defineComponent({
  name: "FsTable",
  inheritAttrs: false,
  props: {
    /**
     * table插槽
     */
    slots: {
      type: Object
    },
    /**
     * 单元格插槽
     */
    cellSlots: {
      type: Object
    },
    /**
     * 列配置，支持el-table-column|a-table-column配置
     */
    columns: {
      type: Object,
      default: void 0
    },
    /**
     * 操作列
     */
    rowHandle: {
      type: Object
    },
    /**
     * 是否显示表格
     */
    show: {
      type: Boolean,
      default: true
    },
    /**
     * 表格数据
     */
    data: {
      type: Array
    },
    conditionalRender: {
      type: Object
    },
    /**
     * 行编辑，批量编辑
     */
    editable: {
      type: Object,
      default() {
        return {};
      }
    },
    loading: {
      type: Boolean,
      default: false
    },
    /**
     * 当前sort状态
     */
    sort: {
      type: Object
    },
    request: {
      type: Object
    },
    rowKey: {
      type: [String, Function],
      default: "id"
    }
  },
  emits: ["row-handle", "value-change", "pagination-change", "filter-change", "sort-change", "data-change"],
  setup(e, t) {
    const n = ref(), o = ref([]);
    ad(o);
    const r = (D, $) => {
      if (!$ || D == null || D > o.value.length)
        return;
      const M = o.value[D][$];
      return M == null ? void 0 : M.getTargetRef();
    }, {
      ui: a
    } = R(), i = getCurrentInstance();
    watch(() => e.data, (D) => {
      t.emit("data-change", {
        data: D
      });
    });
    function s(D = 0) {
      a.table.scrollTo({
        top: D,
        tableRef: n,
        fsTableRef: i
      });
    }
    const l = resolveDynamicComponent(a.table.name), u = a.tableColumn, c = rd(e, t, n), d2 = (D, $) => {
      const F = $[u.row], M = F, ie = $[a.tableColumn.index];
      return $.index = ie, {
        ...$,
        key: D.key,
        value: lodash_default_default.get(F, D.key),
        row: F,
        form: M,
        getComponentRef: (Q) => r(ie, Q)
      };
    };
    function f(D) {
      t.emit("row-handle", D);
    }
    const h2 = a.table.onChange({
      onSortChange: (D) => {
        t.emit("sort-change", D);
      },
      onFilterChange: (D) => {
        t.emit("filter-change", D);
      },
      onPagination: () => {
      },
      bubbleUp: (D) => {
        D(t.attrs);
      }
    }), b = (D) => {
      D.index = D[a.tableColumn.index];
      const $ = "cell-rowHandle", F = {};
      if (e.cellSlots)
        for (const M in e.cellSlots)
          M.startsWith($) && (F[M] = e.cellSlots[M]);
      return createVNode(resolveComponent("fs-row-handle"), mergeProps(e.rowHandle, {
        scope: D,
        onHandle: f
      }), F);
    }, m = (D, $) => {
      var pe, Se, Ce, K, oe, g, v, S, R2, I, P, x;
      const F = "cell_" + D.key, M = $.row = $[u.row], ie = {
        modelValue: lodash_default_default.get($[u.row], D.key),
        "onUpdate:modelValue": (G) => {
          var le;
          lodash_default_default.set($[u.row], D.key, G);
          const U = d2(D, $);
          t.emit("value-change", U), D.valueChange && (D.valueChange instanceof Function ? D.valueChange(U) : (le = D.valueChange) == null || le.handle(U));
        }
      }, Q = (G) => {
        const U = $[a.tableColumn.index], le = D.key;
        let Ie = o.value[U];
        Ie == null && (o.value[U] = Ie = {}), Ie[le] = G;
      }, V = $[a.tableColumn.index], N = M[(pe = e.editable) == null ? void 0 : pe.rowKey], Y = e.cellSlots && e.cellSlots[F], me = d2(D, $);
      if (((K = (Ce = (Se = c.editable) == null ? void 0 : Se.options) == null ? void 0 : Ce.value) == null ? void 0 : K.enabled) === true) {
        const G = c.editable.getEditableCell(N, D.key);
        return createVNode(resolveComponent("fs-editable-cell"), mergeProps({
          ref: Q,
          key: D.key,
          columnKey: D.key,
          index: V,
          editableId: N,
          item: D,
          editableCell: G,
          editableOpts: (g = (oe = c.editable) == null ? void 0 : oe.options) == null ? void 0 : g.value,
          scope: me,
          slots: Y,
          disabled: (R2 = (S = (v = c.editable) == null ? void 0 : v.options) == null ? void 0 : S.value) == null ? void 0 : R2.disabled,
          readonly: (x = (P = (I = c.editable) == null ? void 0 : I.options) == null ? void 0 : P.value) == null ? void 0 : x.readonly
        }, ie), null);
      } else
        return createVNode(resolveComponent("fs-cell"), mergeProps({
          ref: Q,
          key: D.key,
          item: D,
          scope: me,
          slots: Y
        }, ie, {
          conditionalRender: e.conditionalRender
        }), null);
    }, {
      expose: _
    } = t;
    _({
      tableRef: n,
      componentRefs: o,
      getComponentRef: r,
      ...c,
      scrollTo: s
    });
    const y = a.table.renderMode, E = computed(() => ({
      [a.table.data]: e.data
    })), {
      merge: k
    } = Re(), O = computed(() => k({}, t.attrs, h2)), T = computed(() => e.columns);
    if (y === "slot") {
      const D = computed(() => id({
        props: e,
        ui: a,
        sortedColumns: T.value,
        renderRowHandle: b,
        renderCellComponent: m
      }));
      return () => {
        if (e.show === false)
          return;
        const $ = createVNode(l, mergeProps({
          ref: n,
          loading: e.loading,
          rowKey: e.rowKey
        }, O.value, E.value), D.value);
        if (typeof a.table.vLoading == "string") {
          const F = resolveDirective(a.table.vLoading);
          return withDirectives($, [[F, e.loading]]);
        }
        return $;
      };
    } else {
      const D = computed(() => Ua({
        props: e,
        ctx: t,
        ui: a,
        getContextFn: d2,
        sortedColumns: T.value,
        componentRefs: o,
        renderRowHandle: b,
        renderCellComponent: m,
        columns: e.columns
      }));
      return () => {
        if (e.show !== false)
          return createVNode(l, mergeProps({
            ref: n,
            loading: e.loading,
            rowKey: e.rowKey
          }, O.value, {
            columns: D.value
          }, E.value), e.slots);
      };
    }
  }
});
var ld = defineComponent({
  name: "FsCell",
  props: {
    item: {},
    /**
     * scope
     */
    scope: {
      default() {
        return {};
      }
    },
    /**
     * 插槽
     */
    slots: {},
    /**
     * 条件渲染，符合条件的情况下优先渲染
     */
    conditionalRender: {
      type: Object
    }
  },
  setup(e, t) {
    const {
      doComputed: n
    } = It(), a = n(() => e.item.component, () => e.scope), i = ref();
    function s() {
      return i.value.getTargetRef();
    }
    t.expose({
      getTargetRef: s,
      targetRef: i
    });
    const l = computed(() => {
      let c = e.item.showTitle;
      const d2 = e.scope.value;
      return c === true && (c = d2), c;
    }), u = computed(() => (d2) => createVNode("span", {
      class: "fs-cell",
      title: l.value
    }, [d2]));
    return () => {
      var b, m;
      const c = e.scope.value, d2 = u.value, f = {
        ...e.scope,
        props: e.item
      }, h2 = e.item.conditionalRender ?? e.conditionalRender;
      if (h2 && h2.match && h2.match(f))
        return d2(h2.render(f));
      if (e.slots)
        return d2(e.slots(f));
      if (e.item.formatter)
        return d2(e.item.formatter(f));
      if (e.item.cellRender)
        return d2(e.item.cellRender(f));
      if (e.item.render)
        console.warn("column.render 配置已废弃，请使用column.cellRender代替");
      else
        return (b = a.value) != null && b.name ? ((m = a.value) == null ? void 0 : m.show) === false ? void 0 : createVNode(resolveComponent("fs-component-render"), mergeProps({
          title: l.value,
          ref: i
        }, a.value, {
          scope: f
        }), null) : d2(lodash_default_default.toString(c));
    };
  }
});
var ud = defineComponent({
  name: "FsEditableCell",
  inheritAttrs: false,
  props: {
    /**
     * 组件配置
     */
    item: {},
    scope: {},
    index: {},
    editableId: {},
    columnKey: {},
    editableCell: {
      type: Object
    },
    editableOpts: {
      type: Object
    },
    slots: {},
    disabled: {},
    readonly: {}
  },
  setup(e, t) {
    d.get();
    const {
      doComputed: n
    } = It();
    if (e.index === -1)
      return () => {
      };
    const r = n(() => {
      var h2;
      return (h2 = e.editableCell) == null ? void 0 : h2.getForm();
    }, () => e.scope), a = computed(() => {
      var h2;
      return r.value && r.value.show !== false && ((h2 = e.editableCell) == null ? void 0 : h2.isEditable());
    });
    function i(h2) {
      h2 && a.value && e.editableCell.active();
    }
    async function s() {
      var h2;
      if (((h2 = e.editableOpts) == null ? void 0 : h2.mode) === "free") {
        await e.editableCell.persist();
        return;
      }
      await e.editableCell.save();
    }
    function l() {
      e.editableCell.cancel();
    }
    const u = computed(() => {
      var h2, b;
      return (((h2 = e.editableOpts) == null ? void 0 : h2.mode) === "cell" || ((b = e.editableOpts) == null ? void 0 : b.mode) === "free") && e.editableCell.showAction !== false;
    }), c = computed(() => e.editableCell.isChanged && e.editableCell.isChanged()), d2 = () => e.scope, f = {
      default: () => createVNode(resolveComponent("fs-cell"), mergeProps({
        ref: "targetRef",
        item: e.item,
        scope: e.scope,
        slots: e.slots
      }, t.attrs), null),
      edit: () => {
        var b, m;
        let h2 = null;
        return (b = e.editableCell) != null && b.isEditing && (r.value.blank === false || ((m = r.value.component) == null ? void 0 : m.show) === false ? h2 = null : r.value.conditionalRender && r.value.conditionalRender.match && r.value.conditionalRender.match(d2()) ? h2 = createVNode(resolveComponent("fs-render"), mergeProps({
          "render-func": r.value.conditionalRender.render,
          scope: d2()
        }, t.attrs), null) : r.value.render ? h2 = createVNode(resolveComponent("fs-render"), mergeProps({
          "render-func": r.value.render,
          scope: d2()
        }, t.attrs), null) : h2 = createVNode(resolveComponent("fs-component-render"), mergeProps({
          ref: "targetInputRef"
        }, r.value.component, t.attrs, {
          scope: e.scope
        }), null)), h2;
      }
    };
    return () => {
      var m;
      if (!a.value || e.disabled || e.readonly)
        return createVNode(resolveComponent("fs-cell"), mergeProps({
          ref: "targetRef",
          item: e.item,
          scope: e.scope
        }, t.attrs), null);
      const h2 = e.editableCell, b = u.value ? (m = e.editableOpts) == null ? void 0 : m.activeTrigger : false;
      return createVNode(resolveComponent("fs-editable"), {
        ref: "editableRef",
        class: "fs-editable-cell",
        editing: h2 == null ? void 0 : h2.isEditing,
        showAction: u.value,
        dirty: c.value,
        "onUpdate:editing": i,
        onSubmit: s,
        onCancel: l,
        loading: h2 == null ? void 0 : h2.loading,
        trigger: b,
        validateErrors: h2 == null ? void 0 : h2.validateErrors
      }, f);
    };
  },
  methods: {
    getTargetRef() {
      var e;
      return ((e = this.$refs.targetInputRef) == null ? void 0 : e.getTargetRef()) || this.$refs.targetRef;
    }
  }
});
var cd = { class: "fs-editable" };
var dd = { class: "fs-editable-input" };
var fd = {
  key: 0,
  class: "fs-editable-dirty"
};
var hd = {
  key: 0,
  class: "fs-editable-action fs-editable-icon"
};
var md = { class: "fs-editable-input" };
var pd = { class: "fs-editable-action" };
var gd = { class: "error-icon" };
var vd = defineComponent({
  __name: "fs-editable",
  props: {
    disabled: { type: Boolean, default: false },
    editing: { type: Boolean, default: false },
    dirty: { type: Boolean, default: false },
    trigger: { type: [String, Boolean], default: "onClick" },
    loading: { type: Boolean, default: false },
    showAction: { type: Boolean, default: true },
    validateErrors: { default: () => [] }
  },
  emits: ["update:editing", "submit", "cancel"],
  setup(e, { emit: t }) {
    const n = e, { ui: o } = R(), r = t, a = computed(() => n.trigger ? {
      [n.trigger]: () => {
        r("update:editing", true);
      }
    } : {});
    function i() {
      r("submit");
    }
    function s() {
      r("cancel");
    }
    function l() {
      var c;
      return ((c = n.validateErrors) == null ? void 0 : c.length) > 0;
    }
    function u() {
      var c, d2;
      if (((c = n.validateErrors) == null ? void 0 : c.length) !== 0)
        return (d2 = n.validateErrors) == null ? void 0 : d2.map((f) => f.message).join(",");
    }
    return (c, d2) => {
      const f = resolveComponent("fs-icon");
      return openBlock(), createElementBlock("div", cd, [
        !c.editing || c.disabled ? (openBlock(), createElementBlock("div", mergeProps({
          key: 0,
          class: "fs-editable-inner fs-editable-pointer"
        }, a.value), [
          createBaseVNode("div", dd, [
            c.dirty ? (openBlock(), createElementBlock("div", fd)) : createCommentVNode("", true),
            renderSlot(c.$slots, "default")
          ]),
          c.trigger && !c.disabled ? (openBlock(), createElementBlock("div", hd, [
            createVNode(f, {
              icon: unref(o).icons.edit
            }, null, 8, ["icon"])
          ])) : createCommentVNode("", true)
        ], 16)) : (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(["fs-editable-inner", { "fs-validate-error": l() }])
        }, [
          createBaseVNode("div", md, [
            renderSlot(c.$slots, "edit")
          ]),
          createBaseVNode("div", pd, [
            (openBlock(), createBlock(resolveDynamicComponent(unref(o).tooltip.name), null, {
              [unref(o).tooltip.content]: withCtx(() => [
                createBaseVNode("span", gd, toDisplayString(u()), 1)
              ]),
              [unref(o).tooltip.trigger]: withCtx(() => [
                createVNode(f, {
                  class: normalizeClass({ hidden: !l(), "error-icon": true }),
                  size: "mini",
                  icon: unref(o).icons.info
                }, null, 8, ["class", "icon"])
              ]),
              _: 2
            }, 1024)),
            c.showAction ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              c.loading ? (openBlock(), createBlock(f, {
                key: 0,
                size: "mini",
                spin: true,
                icon: unref(o).icons.refresh
              }, null, 8, ["icon"])) : (openBlock(), createBlock(f, {
                key: 1,
                size: "mini",
                icon: unref(o).icons.check,
                onClick: i
              }, null, 8, ["icon"])),
              createVNode(f, {
                class: normalizeClass({ hidden: c.loading }),
                size: "mini",
                icon: unref(o).icons.close,
                onClick: s
              }, null, 8, ["class", "icon"])
            ], 64)) : createCommentVNode("", true)
          ])
        ], 2))
      ]);
    };
  }
});
var bd = defineComponent({
  name: "FsActionbar",
  props: {
    /**
     * 按钮配置
     * {
     *  add:{
     *    ...FsButton,
     *    show:true
     *  },
     *  custom:{...}
     * }
     */
    buttons: {}
  },
  emits: ["action"],
  setup(e, t) {
    function n(r, a, i) {
      const s = { key: r, btn: a, $event: i };
      if (a.click) {
        a.click(s);
        return;
      }
      if (a.onClick) {
        a.onClick(s);
        return;
      }
      t.emit("action", s);
    }
    const o = computed(() => {
      let r = [];
      for (let i in e.buttons)
        r.push({
          // @ts-ignore
          ...e.buttons[i],
          _key: i
        });
      r = lodash_default_default.sortBy(r, (i) => i.order ?? Gt.orderDefault);
      const a = {};
      return r.forEach((i) => {
        let s = i._key;
        delete i._key, a[s] = i;
      }), a;
    });
    return {
      onClick: n,
      computedButtons: o
    };
  }
});
var yd = { class: "fs-actionbar" };
function wd(e, t, n, o, r, a) {
  const i = resolveComponent("fs-button");
  return openBlock(), createElementBlock("div", yd, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(e.computedButtons, (s, l) => (openBlock(), createElementBlock(Fragment, { key: l }, [
      s.show !== false ? (openBlock(), createBlock(i, mergeProps({
        key: 0,
        ref_for: true
      }, s, {
        onClick: (u) => e.onClick(l, s, u)
      }), null, 16, ["onClick"])) : createCommentVNode("", true)
    ], 64))), 128))
  ]);
}
var _d = Ee(bd, [["render", wd]]);
var um = class {
  constructor() {
    te(this, "valueChange");
    te(this, "mergeForm");
  }
};
var $r = "ColumnsFilterContext";
var Cd = defineComponent({
  __name: "index",
  props: {
    container: { default: () => ({ is: "fs-columns-filter-layout-default" }) },
    is: {},
    show: { type: Boolean },
    mode: { default: "default" },
    columns: {},
    originalColumns: {},
    storage: { type: [Boolean, String, Object], default: true },
    text: {},
    onReset: {},
    onSubmit: {}
  },
  emits: ["update:columns", "update:show", "reset", "submit"],
  setup(e, { expose: t, emit: n }) {
    const o = e, r = n, { t: a } = et(), i = d.get(), s = ref(false), l = () => {
      s.value = true;
    }, u = computed(() => y(o.originalColumns)), c = ref([]), d2 = computed(() => {
      const K = {};
      return b(u.value, (oe) => {
        K[oe.__key] = oe;
      }), K;
    }), { merge: f } = Re(), h2 = computed(() => {
      const K = {
        title: a("fs.toolbar.columnFilter.title"),
        fixed: a("fs.toolbar.columnFilter.fixed"),
        order: a("fs.toolbar.columnFilter.order"),
        reset: a("fs.toolbar.columnFilter.reset"),
        confirm: a("fs.toolbar.columnFilter.confirm"),
        unnamed: a("fs.toolbar.columnFilter.unnamed")
      };
      return f(K, o.text), K;
    });
    function b(K, oe) {
      if (K)
        if (Array.isArray(K))
          for (const g of K)
            oe(g), g.children && b(g.children, oe);
        else
          for (const g in K) {
            const v = K[g];
            oe(v), v.children && b(v.children, oe);
          }
    }
    function m(K) {
      return {
        key: K.key,
        title: K.title,
        fixed: K.fixed ?? false,
        show: K.show ?? true,
        __show: K.columnSetShow !== false,
        __disabled: K.columnSetDisabled ?? false
      };
    }
    function _(K) {
      const oe = {};
      return lodash_default_default.forEach(K, (g) => {
        const v = lodash_default_default.omit(g, "children", "__show", "__disabled", "__parent", "__key");
        g.children && g.children.length > 0 && (v.children = _(g.children)), oe[g.key] = v;
      }), oe;
    }
    function y(K, oe) {
      const g = [];
      return lodash_default_default.forEach(K, (v) => {
        const S = m(v);
        S.__parent = oe, S.__key = `${(oe == null ? void 0 : oe.key) || ""}.${v.key}`, g.push(S), v.children && (S.children = y(v.children, S));
      }), g;
    }
    function E(K) {
      c.value = y(K);
    }
    async function k() {
      c.value = y(o.originalColumns), await O(true), await Y(), r("reset");
    }
    async function O(K = false) {
      K || await V(c.value);
      const oe = lodash_default_default.cloneDeep(c.value);
      return b(oe, (g) => {
        g && (delete g.__disabled, delete g.__show, delete g.__parent, delete g.__key);
      }), M(oe), s.value = false, oe;
    }
    async function T(K = false) {
      const oe = await O(K);
      r("submit", { columns: oe });
    }
    const D = computed(() => o.originalColumns);
    provide($r, {
      originalColumns: D,
      originalColumnsMap: d2,
      currentColumns: c,
      text: h2,
      active: s,
      submit: T,
      reset: k
    });
    async function $() {
      await T(false), r("update:show", false);
    }
    async function F() {
      await k(), r("update:show", false);
    }
    function M(K) {
      r("update:columns", _(K));
    }
    const ie = ref();
    function Q() {
      const K = typeof o.storage == "object" ? o.storage : null, oe = typeof o.storage == "string" ? o.storage : "";
      if (ie.value == null) {
        const g = useRoute();
        ie.value = new va({
          $router: g,
          tableName: "columnsFilter",
          keyType: oe,
          remoteStorage: K
        });
      }
      return ie.value;
    }
    async function V(K) {
      if (o.storage === false)
        return;
      const oe = cloneDeep_default(K);
      b(oe, (g) => {
        delete g.__parent;
      }), await Q().updateTableValue(oe);
    }
    async function N() {
      if (o.storage !== false)
        return await Q().getTableValue();
    }
    async function Y() {
      await Q().clearTableValue();
    }
    function me(K) {
      const oe = [];
      b(K, (v) => {
        const S = lodash_default_default.pick(v, "key", "__show", "__disabled");
        oe.push(JSON.stringify(S));
      }), oe.sort();
      let g = "";
      for (const v of oe)
        g += v;
      return g;
    }
    watch(
      () => o.columns,
      (K) => {
        E(K);
      }
    );
    const pe = async () => {
      E(o.columns);
      const K = await N();
      if (K) {
        const oe = me(K);
        if (me(u.value) !== oe)
          return;
        c.value = K, await nextTick(), await T(true);
      }
    };
    async function Se(K) {
      await K(c), await O();
    }
    pe(), t({
      start: l,
      save: O,
      update: Se,
      original: u,
      columns: c
    });
    function Ce(K) {
      return K.label || K.title || K.key || h2.value.unnamed;
    }
    return (K, oe) => {
      var v;
      const g = resolveComponent("fs-button");
      return K.mode === "simple" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        (openBlock(), createBlock(resolveDynamicComponent(unref(i).row.name), { class: "fs-table-columns-filter-simple" }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(c.value, (S, R2) => {
              var I;
              return withDirectives((openBlock(), createBlock(resolveDynamicComponent(unref(i).col.name), {
                key: R2,
                span: 6
              }, {
                default: withCtx(() => {
                  var P;
                  return [
                    (openBlock(), createBlock(resolveDynamicComponent(unref(i).checkbox.name), normalizeProps({
                      [unref(i).checkbox.modelValue]: S.show,
                      ["onUpdate:" + unref(i).checkbox.modelValue]: (x) => S.show = x,
                      disabled: ((P = u.value[S.key]) == null ? void 0 : P.__disabled) === true,
                      class: "item-label",
                      title: Ce(S)
                    }), {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(Ce(S)), 1)
                      ]),
                      _: 2
                    }, 1040, ["disabled", "title"]))
                  ];
                }),
                _: 2
              }, 1024)), [
                [vShow, ((I = u.value[S.key]) == null ? void 0 : I.__show) !== false]
              ]);
            }), 128))
          ]),
          _: 1
        })),
        (openBlock(), createBlock(resolveDynamicComponent(unref(i).divider.name))),
        (openBlock(), createBlock(resolveDynamicComponent(unref(i).row.name), null, {
          default: withCtx(() => [
            createVNode(g, {
              style: { "margin-right": "5px" },
              type: "primary",
              icon: unref(i).icons.check,
              text: h2.value.confirm,
              onClick: oe[0] || (oe[0] = (S) => $())
            }, null, 8, ["icon", "text"]),
            createVNode(g, {
              icon: unref(i).icons.refresh,
              text: h2.value.reset,
              onClick: F
            }, null, 8, ["icon", "text"])
          ]),
          _: 1
        }))
      ], 64)) : (openBlock(), createBlock(resolveDynamicComponent(((v = K.container) == null ? void 0 : v.is) || "fs-columns-filter-layout-default"), normalizeProps(mergeProps({ key: 1 }, K.container)), {
        buttons: withCtx(() => [
          (openBlock(), createBlock(resolveDynamicComponent(unref(i).row.name), {
            class: "fs-drawer-footer",
            gutter: 10
          }, {
            default: withCtx(() => [
              (openBlock(), createBlock(resolveDynamicComponent(unref(i).col.name), { span: 12 }, {
                default: withCtx(() => [
                  createVNode(g, {
                    icon: unref(i).icons.refresh,
                    text: h2.value.reset,
                    block: "",
                    onClick: k
                  }, null, 8, ["icon", "text"])
                ]),
                _: 1
              })),
              (openBlock(), createBlock(resolveDynamicComponent(unref(i).col.name), { span: 12 }, {
                default: withCtx(() => [
                  createVNode(g, {
                    type: "primary",
                    icon: unref(i).icons.check,
                    text: h2.value.confirm,
                    block: "",
                    onClick: oe[1] || (oe[1] = (S) => T(false))
                  }, null, 8, ["icon", "text"])
                ]),
                _: 1
              }))
            ]),
            _: 1
          }))
        ]),
        _: 1
      }, 16));
    };
  }
});
var Sd = defineComponent({
  name: "FsToolbar",
  components: { FsTableColumnsFilter: Cd },
  props: {
    /**
     * 按钮配置
     *{
     *   search:{}, 查询
     *   refresh:{}, 刷新
     *   compact:{}, 紧凑模式
     *   export:{}, 导出
     *   columns:{} 列设置
     *}
     **/
    buttons: {
      type: Object
    },
    /**
     * 当前是否紧凑模式
     */
    compact: {
      type: Boolean,
      default: true
    },
    /**
     * 列配置
     */
    columns: {
      type: Object,
      default: void 0
    },
    /**
     * 是否保存用户列设置
     * 传string则表示传入缓存的主key
     */
    storage: {
      type: [String, Boolean],
      default: true
    },
    /**
     * 插槽
     */
    slots: {},
    /**
     * 列设置配置
     */
    columnsFilter: {
      type: Object
    }
  },
  emits: ["update:columns"],
  setup(e, t) {
    et();
    const n = ref(), { ui: o } = R(), { merge: r } = Re(), a = computed(() => {
      const l = {
        columns: {
          click: () => {
            n.value.start();
          }
        }
      };
      r(l, e.buttons);
      let u = [];
      for (let d2 in l)
        u.push({
          ...l[d2],
          _key: d2
        });
      u = lodash_default_default.sortBy(u, (d2) => d2.order ?? Gt.orderDefault);
      const c = {};
      return u.forEach((d2) => {
        let f = d2._key;
        delete d2._key, c[f] = d2;
      }), c;
    }), i = ref(false);
    return {
      ui: o,
      columnsFilterRef: n,
      computedButtons: a,
      popoverVisible: i,
      handleSimpleClick: () => {
        o.type !== "element" && (i.value = !i.value);
      }
    };
  }
});
var Fd = { class: "fs-toolbar" };
function Rd(e, t, n, o, r, a) {
  var s;
  const i = resolveComponent("fs-button");
  return openBlock(), createElementBlock("div", Fd, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(e.computedButtons, (l, u) => {
      var c;
      return openBlock(), createElementBlock(Fragment, { key: u }, [
        l.show !== false ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          u === "columns" && e.columnsFilter && ((c = e.columnsFilter) == null ? void 0 : c.mode) === "simple" ? (openBlock(), createBlock(resolveDynamicComponent(e.ui.popover.name), normalizeProps({
            key: 0,
            [e.ui.popover.visible]: e.popoverVisible,
            ["onUpdate:" + e.ui.popover.visible]: t[2] || (t[2] = (d2) => e.popoverVisible = d2),
            "display-directive": "show",
            placement: "bottom",
            width: 760,
            trigger: "click"
          }), {
            [e.ui.popover.triggerSlotName]: withCtx(() => [
              createVNode(i, mergeProps({ ref_for: true }, l, { onClick: e.handleSimpleClick }), null, 16, ["onClick"])
            ]),
            [e.ui.popover.contentSlotName]: withCtx(() => [
              e.columns ? (openBlock(), createBlock(resolveDynamicComponent(e.columnsFilter.is || "fs-table-columns-filter"), mergeProps({
                key: 0,
                ref_for: true,
                ref: "columnsFilterRef",
                show: e.popoverVisible,
                "onUpdate:show": t[0] || (t[0] = (d2) => e.popoverVisible = d2),
                mode: "simple"
              }, e.columnsFilter, {
                columns: e.columns,
                storage: e.storage,
                "onUpdate:columns": t[1] || (t[1] = (d2) => e.$emit("update:columns", d2))
              }), null, 16, ["show", "columns", "storage"])) : createCommentVNode("", true)
            ]),
            _: 2
          }, 1040)) : (openBlock(), createBlock(i, mergeProps({
            key: 1,
            ref_for: true
          }, l, {
            onClick: (d2) => l.click()
          }), null, 16, ["onClick"]))
        ], 64)) : createCommentVNode("", true)
      ], 64);
    }), 128)),
    e.columns && ((s = e.columnsFilter) == null ? void 0 : s.mode) !== "simple" ? (openBlock(), createBlock(resolveDynamicComponent(e.columnsFilter.is || "fs-table-columns-filter"), mergeProps({
      key: 0,
      ref: "columnsFilterRef",
      storage: e.storage
    }, e.columnsFilter, {
      columns: e.columns,
      "onUpdate:columns": t[3] || (t[3] = (l) => e.$emit("update:columns", l))
    }), null, 16, ["storage", "columns"])) : createCommentVNode("", true)
  ]);
}
var Ed = Ee(Sd, [["render", Rd]]);
function Qr(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    t && (o = o.filter(function(r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function At(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Qr(Object(n), true).forEach(function(o) {
      Dd(e, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Qr(Object(n)).forEach(function(o) {
      Object.defineProperty(e, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return e;
}
function go(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? go = function(t) {
    return typeof t;
  } : go = function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, go(e);
}
function Dd(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[t] = n, e;
}
function Bt() {
  return Bt = Object.assign || function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, Bt.apply(this, arguments);
}
function kd(e, t) {
  if (e == null)
    return {};
  var n = {}, o = Object.keys(e), r, a;
  for (a = 0; a < o.length; a++)
    r = o[a], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function Od(e, t) {
  if (e == null)
    return {};
  var n = kd(e, t), o, r;
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(e);
    for (r = 0; r < a.length; r++)
      o = a[r], !(t.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(e, o) && (n[o] = e[o]);
  }
  return n;
}
var $d = "1.14.0";
function Mt(e) {
  if (typeof window < "u" && window.navigator)
    return !!navigator.userAgent.match(e);
}
var jt = Mt(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var eo = Mt(/Edge/i);
var Jr = Mt(/firefox/i);
var Mn = Mt(/safari/i) && !Mt(/chrome/i) && !Mt(/android/i);
var Ka = Mt(/iP(ad|od|hone)/i);
var Td = Mt(/chrome/i) && Mt(/android/i);
var Ya = {
  capture: false,
  passive: false
};
function Fe(e, t, n) {
  e.addEventListener(t, n, !jt && Ya);
}
function _e(e, t, n) {
  e.removeEventListener(t, n, !jt && Ya);
}
function So(e, t) {
  if (t) {
    if (t[0] === ">" && (t = t.substring(1)), e)
      try {
        if (e.matches)
          return e.matches(t);
        if (e.msMatchesSelector)
          return e.msMatchesSelector(t);
        if (e.webkitMatchesSelector)
          return e.webkitMatchesSelector(t);
      } catch {
        return false;
      }
    return false;
  }
}
function Ad(e) {
  return e.host && e !== document && e.host.nodeType ? e.host : e.parentNode;
}
function Et(e, t, n, o) {
  if (e) {
    n = n || document;
    do {
      if (t != null && (t[0] === ">" ? e.parentNode === n && So(e, t) : So(e, t)) || o && e === n)
        return e;
      if (e === n)
        break;
    } while (e = Ad(e));
  }
  return null;
}
var Zr = /\s+/g;
function rt(e, t, n) {
  if (e && t)
    if (e.classList)
      e.classList[n ? "add" : "remove"](t);
    else {
      var o = (" " + e.className + " ").replace(Zr, " ").replace(" " + t + " ", " ");
      e.className = (o + (n ? " " + t : "")).replace(Zr, " ");
    }
}
function de(e, t, n) {
  var o = e && e.style;
  if (o) {
    if (n === void 0)
      return document.defaultView && document.defaultView.getComputedStyle ? n = document.defaultView.getComputedStyle(e, "") : e.currentStyle && (n = e.currentStyle), t === void 0 ? n : n[t];
    !(t in o) && t.indexOf("webkit") === -1 && (t = "-webkit-" + t), o[t] = n + (typeof n == "string" ? "" : "px");
  }
}
function bn(e, t) {
  var n = "";
  if (typeof e == "string")
    n = e;
  else
    do {
      var o = de(e, "transform");
      o && o !== "none" && (n = o + " " + n);
    } while (!t && (e = e.parentNode));
  var r = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return r && new r(n);
}
function Ga(e, t, n) {
  if (e) {
    var o = e.getElementsByTagName(t), r = 0, a = o.length;
    if (n)
      for (; r < a; r++)
        n(o[r], r);
    return o;
  }
  return [];
}
function Tt() {
  var e = document.scrollingElement;
  return e || document.documentElement;
}
function Le(e, t, n, o, r) {
  if (!(!e.getBoundingClientRect && e !== window)) {
    var a, i, s, l, u, c, d2;
    if (e !== window && e.parentNode && e !== Tt() ? (a = e.getBoundingClientRect(), i = a.top, s = a.left, l = a.bottom, u = a.right, c = a.height, d2 = a.width) : (i = 0, s = 0, l = window.innerHeight, u = window.innerWidth, c = window.innerHeight, d2 = window.innerWidth), (t || n) && e !== window && (r = r || e.parentNode, !jt))
      do
        if (r && r.getBoundingClientRect && (de(r, "transform") !== "none" || n && de(r, "position") !== "static")) {
          var f = r.getBoundingClientRect();
          i -= f.top + parseInt(de(r, "border-top-width")), s -= f.left + parseInt(de(r, "border-left-width")), l = i + a.height, u = s + a.width;
          break;
        }
      while (r = r.parentNode);
    if (o && e !== window) {
      var h2 = bn(r || e), b = h2 && h2.a, m = h2 && h2.d;
      h2 && (i /= m, s /= b, d2 /= b, c /= m, l = i + c, u = s + d2);
    }
    return {
      top: i,
      left: s,
      bottom: l,
      right: u,
      width: d2,
      height: c
    };
  }
}
function ea(e, t, n) {
  for (var o = Ut(e, true), r = Le(e)[t]; o; ) {
    var a = Le(o)[n], i = void 0;
    if (n === "top" || n === "left" ? i = r >= a : i = r <= a, !i)
      return o;
    if (o === Tt())
      break;
    o = Ut(o, false);
  }
  return false;
}
function Fn(e, t, n, o) {
  for (var r = 0, a = 0, i = e.children; a < i.length; ) {
    if (i[a].style.display !== "none" && i[a] !== fe.ghost && (o || i[a] !== fe.dragged) && Et(i[a], n.draggable, e, false)) {
      if (r === t)
        return i[a];
      r++;
    }
    a++;
  }
  return null;
}
function Tr(e, t) {
  for (var n = e.lastElementChild; n && (n === fe.ghost || de(n, "display") === "none" || t && !So(n, t)); )
    n = n.previousElementSibling;
  return n || null;
}
function ft(e, t) {
  var n = 0;
  if (!e || !e.parentNode)
    return -1;
  for (; e = e.previousElementSibling; )
    e.nodeName.toUpperCase() !== "TEMPLATE" && e !== fe.clone && (!t || So(e, t)) && n++;
  return n;
}
function ta(e) {
  var t = 0, n = 0, o = Tt();
  if (e)
    do {
      var r = bn(e), a = r.a, i = r.d;
      t += e.scrollLeft * a, n += e.scrollTop * i;
    } while (e !== o && (e = e.parentNode));
  return [t, n];
}
function Id(e, t) {
  for (var n in e)
    if (e.hasOwnProperty(n)) {
      for (var o in t)
        if (t.hasOwnProperty(o) && t[o] === e[n][o])
          return Number(n);
    }
  return -1;
}
function Ut(e, t) {
  if (!e || !e.getBoundingClientRect)
    return Tt();
  var n = e, o = false;
  do
    if (n.clientWidth < n.scrollWidth || n.clientHeight < n.scrollHeight) {
      var r = de(n);
      if (n.clientWidth < n.scrollWidth && (r.overflowX == "auto" || r.overflowX == "scroll") || n.clientHeight < n.scrollHeight && (r.overflowY == "auto" || r.overflowY == "scroll")) {
        if (!n.getBoundingClientRect || n === document.body)
          return Tt();
        if (o || t)
          return n;
        o = true;
      }
    }
  while (n = n.parentNode);
  return Tt();
}
function Vd(e, t) {
  if (e && t)
    for (var n in t)
      t.hasOwnProperty(n) && (e[n] = t[n]);
  return e;
}
function zo(e, t) {
  return Math.round(e.top) === Math.round(t.top) && Math.round(e.left) === Math.round(t.left) && Math.round(e.height) === Math.round(t.height) && Math.round(e.width) === Math.round(t.width);
}
var Bn;
function Xa(e, t) {
  return function() {
    if (!Bn) {
      var n = arguments, o = this;
      n.length === 1 ? e.call(o, n[0]) : e.apply(o, n), Bn = setTimeout(function() {
        Bn = void 0;
      }, t);
    }
  };
}
function Pd() {
  clearTimeout(Bn), Bn = void 0;
}
function Qa(e, t, n) {
  e.scrollLeft += t, e.scrollTop += n;
}
function Ja(e) {
  var t = window.Polymer, n = window.jQuery || window.Zepto;
  return t && t.dom ? t.dom(e).cloneNode(true) : n ? n(e).clone(true)[0] : e.cloneNode(true);
}
var ct = "Sortable" + (/* @__PURE__ */ new Date()).getTime();
function Md() {
  var e = [], t;
  return {
    captureAnimationState: function() {
      if (e = [], !!this.options.animation) {
        var o = [].slice.call(this.el.children);
        o.forEach(function(r) {
          if (!(de(r, "display") === "none" || r === fe.ghost)) {
            e.push({
              target: r,
              rect: Le(r)
            });
            var a = At({}, e[e.length - 1].rect);
            if (r.thisAnimationDuration) {
              var i = bn(r, true);
              i && (a.top -= i.f, a.left -= i.e);
            }
            r.fromRect = a;
          }
        });
      }
    },
    addAnimationState: function(o) {
      e.push(o);
    },
    removeAnimationState: function(o) {
      e.splice(Id(e, {
        target: o
      }), 1);
    },
    animateAll: function(o) {
      var r = this;
      if (!this.options.animation) {
        clearTimeout(t), typeof o == "function" && o();
        return;
      }
      var a = false, i = 0;
      e.forEach(function(s) {
        var l = 0, u = s.target, c = u.fromRect, d2 = Le(u), f = u.prevFromRect, h2 = u.prevToRect, b = s.rect, m = bn(u, true);
        m && (d2.top -= m.f, d2.left -= m.e), u.toRect = d2, u.thisAnimationDuration && zo(f, d2) && !zo(c, d2) && // Make sure animatingRect is on line between toRect & fromRect
        (b.top - d2.top) / (b.left - d2.left) === (c.top - d2.top) / (c.left - d2.left) && (l = jd(b, f, h2, r.options)), zo(d2, c) || (u.prevFromRect = c, u.prevToRect = d2, l || (l = r.options.animation), r.animate(u, b, d2, l)), l && (a = true, i = Math.max(i, l), clearTimeout(u.animationResetTimer), u.animationResetTimer = setTimeout(function() {
          u.animationTime = 0, u.prevFromRect = null, u.fromRect = null, u.prevToRect = null, u.thisAnimationDuration = null;
        }, l), u.thisAnimationDuration = l);
      }), clearTimeout(t), a ? t = setTimeout(function() {
        typeof o == "function" && o();
      }, i) : typeof o == "function" && o(), e = [];
    },
    animate: function(o, r, a, i) {
      if (i) {
        de(o, "transition", ""), de(o, "transform", "");
        var s = bn(this.el), l = s && s.a, u = s && s.d, c = (r.left - a.left) / (l || 1), d2 = (r.top - a.top) / (u || 1);
        o.animatingX = !!c, o.animatingY = !!d2, de(o, "transform", "translate3d(" + c + "px," + d2 + "px,0)"), this.forRepaintDummy = Bd(o), de(o, "transition", "transform " + i + "ms" + (this.options.easing ? " " + this.options.easing : "")), de(o, "transform", "translate3d(0,0,0)"), typeof o.animated == "number" && clearTimeout(o.animated), o.animated = setTimeout(function() {
          de(o, "transition", ""), de(o, "transform", ""), o.animated = false, o.animatingX = false, o.animatingY = false;
        }, i);
      }
    }
  };
}
function Bd(e) {
  return e.offsetWidth;
}
function jd(e, t, n, o) {
  return Math.sqrt(Math.pow(t.top - e.top, 2) + Math.pow(t.left - e.left, 2)) / Math.sqrt(Math.pow(t.top - n.top, 2) + Math.pow(t.left - n.left, 2)) * o.animation;
}
var hn = [];
var Wo = {
  initializeByDefault: true
};
var to = {
  mount: function(t) {
    for (var n in Wo)
      Wo.hasOwnProperty(n) && !(n in t) && (t[n] = Wo[n]);
    hn.forEach(function(o) {
      if (o.pluginName === t.pluginName)
        throw "Sortable: Cannot mount plugin ".concat(t.pluginName, " more than once");
    }), hn.push(t);
  },
  pluginEvent: function(t, n, o) {
    var r = this;
    this.eventCanceled = false, o.cancel = function() {
      r.eventCanceled = true;
    };
    var a = t + "Global";
    hn.forEach(function(i) {
      n[i.pluginName] && (n[i.pluginName][a] && n[i.pluginName][a](At({
        sortable: n
      }, o)), n.options[i.pluginName] && n[i.pluginName][t] && n[i.pluginName][t](At({
        sortable: n
      }, o)));
    });
  },
  initializePlugins: function(t, n, o, r) {
    hn.forEach(function(s) {
      var l = s.pluginName;
      if (!(!t.options[l] && !s.initializeByDefault)) {
        var u = new s(t, n, t.options);
        u.sortable = t, u.options = t.options, t[l] = u, Bt(o, u.defaults);
      }
    });
    for (var a in t.options)
      if (t.options.hasOwnProperty(a)) {
        var i = this.modifyOption(t, a, t.options[a]);
        typeof i < "u" && (t.options[a] = i);
      }
  },
  getEventProperties: function(t, n) {
    var o = {};
    return hn.forEach(function(r) {
      typeof r.eventProperties == "function" && Bt(o, r.eventProperties.call(n[r.pluginName], t));
    }), o;
  },
  modifyOption: function(t, n, o) {
    var r;
    return hn.forEach(function(a) {
      t[a.pluginName] && a.optionListeners && typeof a.optionListeners[n] == "function" && (r = a.optionListeners[n].call(t[a.pluginName], o));
    }), r;
  }
};
function Nd(e) {
  var t = e.sortable, n = e.rootEl, o = e.name, r = e.targetEl, a = e.cloneEl, i = e.toEl, s = e.fromEl, l = e.oldIndex, u = e.newIndex, c = e.oldDraggableIndex, d2 = e.newDraggableIndex, f = e.originalEvent, h2 = e.putSortable, b = e.extraEventProperties;
  if (t = t || n && n[ct], !!t) {
    var m, _ = t.options, y = "on" + o.charAt(0).toUpperCase() + o.substr(1);
    window.CustomEvent && !jt && !eo ? m = new CustomEvent(o, {
      bubbles: true,
      cancelable: true
    }) : (m = document.createEvent("Event"), m.initEvent(o, true, true)), m.to = i || n, m.from = s || n, m.item = r || n, m.clone = a, m.oldIndex = l, m.newIndex = u, m.oldDraggableIndex = c, m.newDraggableIndex = d2, m.originalEvent = f, m.pullMode = h2 ? h2.lastPutMode : void 0;
    var E = At(At({}, b), to.getEventProperties(o, t));
    for (var k in E)
      m[k] = E[k];
    n && n.dispatchEvent(m), _[y] && _[y].call(t, m);
  }
}
var Ld = ["evt"];
var tt = function(t, n) {
  var o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = o.evt, a = Od(o, Ld);
  to.pluginEvent.bind(fe)(t, n, At({
    dragEl: q,
    parentEl: Ve,
    ghostEl: ge,
    rootEl: Te,
    nextEl: nn,
    lastDownEl: vo,
    cloneEl: Pe,
    cloneHidden: Wt,
    dragStarted: An,
    putSortable: Ue,
    activeSortable: fe.active,
    originalEvent: r,
    oldIndex: vn,
    oldDraggableIndex: jn,
    newIndex: at,
    newDraggableIndex: zt,
    hideGhostForTarget: ni,
    unhideGhostForTarget: oi,
    cloneNowHidden: function() {
      Wt = true;
    },
    cloneNowShown: function() {
      Wt = false;
    },
    dispatchSortableEvent: function(s) {
      Qe({
        sortable: n,
        name: s,
        originalEvent: r
      });
    }
  }, a));
};
function Qe(e) {
  Nd(At({
    putSortable: Ue,
    cloneEl: Pe,
    targetEl: q,
    rootEl: Te,
    oldIndex: vn,
    oldDraggableIndex: jn,
    newIndex: at,
    newDraggableIndex: zt
  }, e));
}
var q;
var Ve;
var ge;
var Te;
var nn;
var vo;
var Pe;
var Wt;
var vn;
var at;
var jn;
var zt;
var io;
var Ue;
var pn = false;
var Fo = false;
var Ro = [];
var en;
var ht;
var xo;
var Uo;
var na;
var oa;
var An;
var mn;
var Nn;
var Ln = false;
var so = false;
var bo;
var Ke;
var Ko = [];
var gr = false;
var Eo = [];
var Bo = typeof document < "u";
var lo = Ka;
var ra = eo || jt ? "cssFloat" : "float";
var qd = Bo && !Td && !Ka && "draggable" in document.createElement("div");
var Za = function() {
  if (Bo) {
    if (jt)
      return false;
    var e = document.createElement("x");
    return e.style.cssText = "pointer-events:auto", e.style.pointerEvents === "auto";
  }
}();
var ei = function(t, n) {
  var o = de(t), r = parseInt(o.width) - parseInt(o.paddingLeft) - parseInt(o.paddingRight) - parseInt(o.borderLeftWidth) - parseInt(o.borderRightWidth), a = Fn(t, 0, n), i = Fn(t, 1, n), s = a && de(a), l = i && de(i), u = s && parseInt(s.marginLeft) + parseInt(s.marginRight) + Le(a).width, c = l && parseInt(l.marginLeft) + parseInt(l.marginRight) + Le(i).width;
  if (o.display === "flex")
    return o.flexDirection === "column" || o.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  if (o.display === "grid")
    return o.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  if (a && s.float && s.float !== "none") {
    var d2 = s.float === "left" ? "left" : "right";
    return i && (l.clear === "both" || l.clear === d2) ? "vertical" : "horizontal";
  }
  return a && (s.display === "block" || s.display === "flex" || s.display === "table" || s.display === "grid" || u >= r && o[ra] === "none" || i && o[ra] === "none" && u + c > r) ? "vertical" : "horizontal";
};
var Hd = function(t, n, o) {
  var r = o ? t.left : t.top, a = o ? t.right : t.bottom, i = o ? t.width : t.height, s = o ? n.left : n.top, l = o ? n.right : n.bottom, u = o ? n.width : n.height;
  return r === s || a === l || r + i / 2 === s + u / 2;
};
var zd = function(t, n) {
  var o;
  return Ro.some(function(r) {
    var a = r[ct].options.emptyInsertThreshold;
    if (!(!a || Tr(r))) {
      var i = Le(r), s = t >= i.left - a && t <= i.right + a, l = n >= i.top - a && n <= i.bottom + a;
      if (s && l)
        return o = r;
    }
  }), o;
};
var ti = function(t) {
  function n(a, i) {
    return function(s, l, u, c) {
      var d2 = s.options.group.name && l.options.group.name && s.options.group.name === l.options.group.name;
      if (a == null && (i || d2))
        return true;
      if (a == null || a === false)
        return false;
      if (i && a === "clone")
        return a;
      if (typeof a == "function")
        return n(a(s, l, u, c), i)(s, l, u, c);
      var f = (i ? s : l).options.group.name;
      return a === true || typeof a == "string" && a === f || a.join && a.indexOf(f) > -1;
    };
  }
  var o = {}, r = t.group;
  (!r || go(r) != "object") && (r = {
    name: r
  }), o.name = r.name, o.checkPull = n(r.pull, true), o.checkPut = n(r.put), o.revertClone = r.revertClone, t.group = o;
};
var ni = function() {
  !Za && ge && de(ge, "display", "none");
};
var oi = function() {
  !Za && ge && de(ge, "display", "");
};
Bo && document.addEventListener("click", function(e) {
  if (Fo)
    return e.preventDefault(), e.stopPropagation && e.stopPropagation(), e.stopImmediatePropagation && e.stopImmediatePropagation(), Fo = false, false;
}, true);
var tn = function(t) {
  if (q) {
    t = t.touches ? t.touches[0] : t;
    var n = zd(t.clientX, t.clientY);
    if (n) {
      var o = {};
      for (var r in t)
        t.hasOwnProperty(r) && (o[r] = t[r]);
      o.target = o.rootEl = n, o.preventDefault = void 0, o.stopPropagation = void 0, n[ct]._onDragOver(o);
    }
  }
};
var Wd = function(t) {
  q && q.parentNode[ct]._isOutsideThisEl(t.target);
};
function fe(e, t) {
  if (!(e && e.nodeType && e.nodeType === 1))
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(e));
  this.el = e, this.options = t = Bt({}, t), e[ct] = this;
  var n = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(e.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function() {
      return ei(e, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function(i, s) {
      i.setData("Text", s.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: fe.supportPointer !== false && "PointerEvent" in window && !Mn,
    emptyInsertThreshold: 5
  };
  to.initializePlugins(this, e, n);
  for (var o in n)
    !(o in t) && (t[o] = n[o]);
  ti(t);
  for (var r in this)
    r.charAt(0) === "_" && typeof this[r] == "function" && (this[r] = this[r].bind(this));
  this.nativeDraggable = t.forceFallback ? false : qd, this.nativeDraggable && (this.options.touchStartThreshold = 1), t.supportPointer ? Fe(e, "pointerdown", this._onTapStart) : (Fe(e, "mousedown", this._onTapStart), Fe(e, "touchstart", this._onTapStart)), this.nativeDraggable && (Fe(e, "dragover", this), Fe(e, "dragenter", this)), Ro.push(this.el), t.store && t.store.get && this.sort(t.store.get(this) || []), Bt(this, Md());
}
fe.prototype = /** @lends Sortable.prototype */
{
  constructor: fe,
  _isOutsideThisEl: function(t) {
    !this.el.contains(t) && t !== this.el && (mn = null);
  },
  _getDirection: function(t, n) {
    return typeof this.options.direction == "function" ? this.options.direction.call(this, t, n, q) : this.options.direction;
  },
  _onTapStart: function(t) {
    if (t.cancelable) {
      var n = this, o = this.el, r = this.options, a = r.preventOnFilter, i = t.type, s = t.touches && t.touches[0] || t.pointerType && t.pointerType === "touch" && t, l = (s || t).target, u = t.target.shadowRoot && (t.path && t.path[0] || t.composedPath && t.composedPath()[0]) || l, c = r.filter;
      if (Jd(o), !q && !(/mousedown|pointerdown/.test(i) && t.button !== 0 || r.disabled) && !u.isContentEditable && !(!this.nativeDraggable && Mn && l && l.tagName.toUpperCase() === "SELECT") && (l = Et(l, r.draggable, o, false), !(l && l.animated) && vo !== l)) {
        if (vn = ft(l), jn = ft(l, r.draggable), typeof c == "function") {
          if (c.call(this, t, l, this)) {
            Qe({
              sortable: n,
              rootEl: u,
              name: "filter",
              targetEl: l,
              toEl: o,
              fromEl: o
            }), tt("filter", n, {
              evt: t
            }), a && t.cancelable && t.preventDefault();
            return;
          }
        } else if (c && (c = c.split(",").some(function(d2) {
          if (d2 = Et(u, d2.trim(), o, false), d2)
            return Qe({
              sortable: n,
              rootEl: d2,
              name: "filter",
              targetEl: l,
              fromEl: o,
              toEl: o
            }), tt("filter", n, {
              evt: t
            }), true;
        }), c)) {
          a && t.cancelable && t.preventDefault();
          return;
        }
        r.handle && !Et(u, r.handle, o, false) || this._prepareDragStart(t, s, l);
      }
    }
  },
  _prepareDragStart: function(t, n, o) {
    var r = this, a = r.el, i = r.options, s = a.ownerDocument, l;
    if (o && !q && o.parentNode === a) {
      var u = Le(o);
      if (Te = a, q = o, Ve = q.parentNode, nn = q.nextSibling, vo = o, io = i.group, fe.dragged = q, en = {
        target: q,
        clientX: (n || t).clientX,
        clientY: (n || t).clientY
      }, na = en.clientX - u.left, oa = en.clientY - u.top, this._lastX = (n || t).clientX, this._lastY = (n || t).clientY, q.style["will-change"] = "all", l = function() {
        if (tt("delayEnded", r, {
          evt: t
        }), fe.eventCanceled) {
          r._onDrop();
          return;
        }
        r._disableDelayedDragEvents(), !Jr && r.nativeDraggable && (q.draggable = true), r._triggerDragStart(t, n), Qe({
          sortable: r,
          name: "choose",
          originalEvent: t
        }), rt(q, i.chosenClass, true);
      }, i.ignore.split(",").forEach(function(c) {
        Ga(q, c.trim(), Yo);
      }), Fe(s, "dragover", tn), Fe(s, "mousemove", tn), Fe(s, "touchmove", tn), Fe(s, "mouseup", r._onDrop), Fe(s, "touchend", r._onDrop), Fe(s, "touchcancel", r._onDrop), Jr && this.nativeDraggable && (this.options.touchStartThreshold = 4, q.draggable = true), tt("delayStart", this, {
        evt: t
      }), i.delay && (!i.delayOnTouchOnly || n) && (!this.nativeDraggable || !(eo || jt))) {
        if (fe.eventCanceled) {
          this._onDrop();
          return;
        }
        Fe(s, "mouseup", r._disableDelayedDrag), Fe(s, "touchend", r._disableDelayedDrag), Fe(s, "touchcancel", r._disableDelayedDrag), Fe(s, "mousemove", r._delayedDragTouchMoveHandler), Fe(s, "touchmove", r._delayedDragTouchMoveHandler), i.supportPointer && Fe(s, "pointermove", r._delayedDragTouchMoveHandler), r._dragStartTimer = setTimeout(l, i.delay);
      } else
        l();
    }
  },
  _delayedDragTouchMoveHandler: function(t) {
    var n = t.touches ? t.touches[0] : t;
    Math.max(Math.abs(n.clientX - this._lastX), Math.abs(n.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1)) && this._disableDelayedDrag();
  },
  _disableDelayedDrag: function() {
    q && Yo(q), clearTimeout(this._dragStartTimer), this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function() {
    var t = this.el.ownerDocument;
    _e(t, "mouseup", this._disableDelayedDrag), _e(t, "touchend", this._disableDelayedDrag), _e(t, "touchcancel", this._disableDelayedDrag), _e(t, "mousemove", this._delayedDragTouchMoveHandler), _e(t, "touchmove", this._delayedDragTouchMoveHandler), _e(t, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function(t, n) {
    n = n || t.pointerType == "touch" && t, !this.nativeDraggable || n ? this.options.supportPointer ? Fe(document, "pointermove", this._onTouchMove) : n ? Fe(document, "touchmove", this._onTouchMove) : Fe(document, "mousemove", this._onTouchMove) : (Fe(q, "dragend", this), Fe(Te, "dragstart", this._onDragStart));
    try {
      document.selection ? yo(function() {
        document.selection.empty();
      }) : window.getSelection().removeAllRanges();
    } catch {
    }
  },
  _dragStarted: function(t, n) {
    if (pn = false, Te && q) {
      tt("dragStarted", this, {
        evt: n
      }), this.nativeDraggable && Fe(document, "dragover", Wd);
      var o = this.options;
      !t && rt(q, o.dragClass, false), rt(q, o.ghostClass, true), fe.active = this, t && this._appendGhost(), Qe({
        sortable: this,
        name: "start",
        originalEvent: n
      });
    } else
      this._nulling();
  },
  _emulateDragOver: function() {
    if (ht) {
      this._lastX = ht.clientX, this._lastY = ht.clientY, ni();
      for (var t = document.elementFromPoint(ht.clientX, ht.clientY), n = t; t && t.shadowRoot && (t = t.shadowRoot.elementFromPoint(ht.clientX, ht.clientY), t !== n); )
        n = t;
      if (q.parentNode[ct]._isOutsideThisEl(t), n)
        do {
          if (n[ct]) {
            var o = void 0;
            if (o = n[ct]._onDragOver({
              clientX: ht.clientX,
              clientY: ht.clientY,
              target: t,
              rootEl: n
            }), o && !this.options.dragoverBubble)
              break;
          }
          t = n;
        } while (n = n.parentNode);
      oi();
    }
  },
  _onTouchMove: function(t) {
    if (en) {
      var n = this.options, o = n.fallbackTolerance, r = n.fallbackOffset, a = t.touches ? t.touches[0] : t, i = ge && bn(ge, true), s = ge && i && i.a, l = ge && i && i.d, u = lo && Ke && ta(Ke), c = (a.clientX - en.clientX + r.x) / (s || 1) + (u ? u[0] - Ko[0] : 0) / (s || 1), d2 = (a.clientY - en.clientY + r.y) / (l || 1) + (u ? u[1] - Ko[1] : 0) / (l || 1);
      if (!fe.active && !pn) {
        if (o && Math.max(Math.abs(a.clientX - this._lastX), Math.abs(a.clientY - this._lastY)) < o)
          return;
        this._onDragStart(t, true);
      }
      if (ge) {
        i ? (i.e += c - (xo || 0), i.f += d2 - (Uo || 0)) : i = {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          e: c,
          f: d2
        };
        var f = "matrix(".concat(i.a, ",").concat(i.b, ",").concat(i.c, ",").concat(i.d, ",").concat(i.e, ",").concat(i.f, ")");
        de(ge, "webkitTransform", f), de(ge, "mozTransform", f), de(ge, "msTransform", f), de(ge, "transform", f), xo = c, Uo = d2, ht = a;
      }
      t.cancelable && t.preventDefault();
    }
  },
  _appendGhost: function() {
    if (!ge) {
      var t = this.options.fallbackOnBody ? document.body : Te, n = Le(q, true, lo, true, t), o = this.options;
      if (lo) {
        for (Ke = t; de(Ke, "position") === "static" && de(Ke, "transform") === "none" && Ke !== document; )
          Ke = Ke.parentNode;
        Ke !== document.body && Ke !== document.documentElement ? (Ke === document && (Ke = Tt()), n.top += Ke.scrollTop, n.left += Ke.scrollLeft) : Ke = Tt(), Ko = ta(Ke);
      }
      ge = q.cloneNode(true), rt(ge, o.ghostClass, false), rt(ge, o.fallbackClass, true), rt(ge, o.dragClass, true), de(ge, "transition", ""), de(ge, "transform", ""), de(ge, "box-sizing", "border-box"), de(ge, "margin", 0), de(ge, "top", n.top), de(ge, "left", n.left), de(ge, "width", n.width), de(ge, "height", n.height), de(ge, "opacity", "0.8"), de(ge, "position", lo ? "absolute" : "fixed"), de(ge, "zIndex", "100000"), de(ge, "pointerEvents", "none"), fe.ghost = ge, t.appendChild(ge), de(ge, "transform-origin", na / parseInt(ge.style.width) * 100 + "% " + oa / parseInt(ge.style.height) * 100 + "%");
    }
  },
  _onDragStart: function(t, n) {
    var o = this, r = t.dataTransfer, a = o.options;
    if (tt("dragStart", this, {
      evt: t
    }), fe.eventCanceled) {
      this._onDrop();
      return;
    }
    tt("setupClone", this), fe.eventCanceled || (Pe = Ja(q), Pe.draggable = false, Pe.style["will-change"] = "", this._hideClone(), rt(Pe, this.options.chosenClass, false), fe.clone = Pe), o.cloneId = yo(function() {
      tt("clone", o), !fe.eventCanceled && (o.options.removeCloneOnHide || Te.insertBefore(Pe, q), o._hideClone(), Qe({
        sortable: o,
        name: "clone"
      }));
    }), !n && rt(q, a.dragClass, true), n ? (Fo = true, o._loopId = setInterval(o._emulateDragOver, 50)) : (_e(document, "mouseup", o._onDrop), _e(document, "touchend", o._onDrop), _e(document, "touchcancel", o._onDrop), r && (r.effectAllowed = "move", a.setData && a.setData.call(o, r, q)), Fe(document, "drop", o), de(q, "transform", "translateZ(0)")), pn = true, o._dragStartId = yo(o._dragStarted.bind(o, n, t)), Fe(document, "selectstart", o), An = true, Mn && de(document.body, "user-select", "none");
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function(t) {
    var n = this.el, o = t.target, r, a, i, s = this.options, l = s.group, u = fe.active, c = io === l, d2 = s.sort, f = Ue || u, h2, b = this, m = false;
    if (gr)
      return;
    function _(Ce, K) {
      tt(Ce, b, At({
        evt: t,
        isOwner: c,
        axis: h2 ? "vertical" : "horizontal",
        revert: i,
        dragRect: r,
        targetRect: a,
        canSort: d2,
        fromSortable: f,
        target: o,
        completed: E,
        onMove: function(g, v) {
          return uo(Te, n, q, r, g, Le(g), t, v);
        },
        changed: k
      }, K));
    }
    function y() {
      _("dragOverAnimationCapture"), b.captureAnimationState(), b !== f && f.captureAnimationState();
    }
    function E(Ce) {
      return _("dragOverCompleted", {
        insertion: Ce
      }), Ce && (c ? u._hideClone() : u._showClone(b), b !== f && (rt(q, Ue ? Ue.options.ghostClass : u.options.ghostClass, false), rt(q, s.ghostClass, true)), Ue !== b && b !== fe.active ? Ue = b : b === fe.active && Ue && (Ue = null), f === b && (b._ignoreWhileAnimating = o), b.animateAll(function() {
        _("dragOverAnimationComplete"), b._ignoreWhileAnimating = null;
      }), b !== f && (f.animateAll(), f._ignoreWhileAnimating = null)), (o === q && !q.animated || o === n && !o.animated) && (mn = null), !s.dragoverBubble && !t.rootEl && o !== document && (q.parentNode[ct]._isOutsideThisEl(t.target), !Ce && tn(t)), !s.dragoverBubble && t.stopPropagation && t.stopPropagation(), m = true;
    }
    function k() {
      at = ft(q), zt = ft(q, s.draggable), Qe({
        sortable: b,
        name: "change",
        toEl: n,
        newIndex: at,
        newDraggableIndex: zt,
        originalEvent: t
      });
    }
    if (t.preventDefault !== void 0 && t.cancelable && t.preventDefault(), o = Et(o, s.draggable, n, true), _("dragOver"), fe.eventCanceled)
      return m;
    if (q.contains(t.target) || o.animated && o.animatingX && o.animatingY || b._ignoreWhileAnimating === o)
      return E(false);
    if (Fo = false, u && !s.disabled && (c ? d2 || (i = Ve !== Te) : Ue === this || (this.lastPutMode = io.checkPull(this, u, q, t)) && l.checkPut(this, u, q, t))) {
      if (h2 = this._getDirection(t, o) === "vertical", r = Le(q), _("dragOverValid"), fe.eventCanceled)
        return m;
      if (i)
        return Ve = Te, y(), this._hideClone(), _("revert"), fe.eventCanceled || (nn ? Te.insertBefore(q, nn) : Te.appendChild(q)), E(true);
      var O = Tr(n, s.draggable);
      if (!O || Yd(t, h2, this) && !O.animated) {
        if (O === q)
          return E(false);
        if (O && n === t.target && (o = O), o && (a = Le(o)), uo(Te, n, q, r, o, a, t, !!o) !== false)
          return y(), n.appendChild(q), Ve = n, k(), E(true);
      } else if (O && Kd(t, h2, this)) {
        var T = Fn(n, 0, s, true);
        if (T === q)
          return E(false);
        if (o = T, a = Le(o), uo(Te, n, q, r, o, a, t, false) !== false)
          return y(), n.insertBefore(q, T), Ve = n, k(), E(true);
      } else if (o.parentNode === n) {
        a = Le(o);
        var D = 0, $, F = q.parentNode !== n, M = !Hd(q.animated && q.toRect || r, o.animated && o.toRect || a, h2), ie = h2 ? "top" : "left", Q = ea(o, "top", "top") || ea(q, "top", "top"), V = Q ? Q.scrollTop : void 0;
        mn !== o && ($ = a[ie], Ln = false, so = !M && s.invertSwap || F), D = Gd(t, o, a, h2, M ? 1 : s.swapThreshold, s.invertedSwapThreshold == null ? s.swapThreshold : s.invertedSwapThreshold, so, mn === o);
        var N;
        if (D !== 0) {
          var Y = ft(q);
          do
            Y -= D, N = Ve.children[Y];
          while (N && (de(N, "display") === "none" || N === ge));
        }
        if (D === 0 || N === o)
          return E(false);
        mn = o, Nn = D;
        var me = o.nextElementSibling, pe = false;
        pe = D === 1;
        var Se = uo(Te, n, q, r, o, a, t, pe);
        if (Se !== false)
          return (Se === 1 || Se === -1) && (pe = Se === 1), gr = true, setTimeout(Ud, 30), y(), pe && !me ? n.appendChild(q) : o.parentNode.insertBefore(q, pe ? me : o), Q && Qa(Q, 0, V - Q.scrollTop), Ve = q.parentNode, $ !== void 0 && !so && (bo = Math.abs($ - Le(o)[ie])), k(), E(true);
      }
      if (n.contains(q))
        return E(false);
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function() {
    _e(document, "mousemove", this._onTouchMove), _e(document, "touchmove", this._onTouchMove), _e(document, "pointermove", this._onTouchMove), _e(document, "dragover", tn), _e(document, "mousemove", tn), _e(document, "touchmove", tn);
  },
  _offUpEvents: function() {
    var t = this.el.ownerDocument;
    _e(t, "mouseup", this._onDrop), _e(t, "touchend", this._onDrop), _e(t, "pointerup", this._onDrop), _e(t, "touchcancel", this._onDrop), _e(document, "selectstart", this);
  },
  _onDrop: function(t) {
    var n = this.el, o = this.options;
    if (at = ft(q), zt = ft(q, o.draggable), tt("drop", this, {
      evt: t
    }), Ve = q && q.parentNode, at = ft(q), zt = ft(q, o.draggable), fe.eventCanceled) {
      this._nulling();
      return;
    }
    pn = false, so = false, Ln = false, clearInterval(this._loopId), clearTimeout(this._dragStartTimer), vr(this.cloneId), vr(this._dragStartId), this.nativeDraggable && (_e(document, "drop", this), _e(n, "dragstart", this._onDragStart)), this._offMoveEvents(), this._offUpEvents(), Mn && de(document.body, "user-select", ""), de(q, "transform", ""), t && (An && (t.cancelable && t.preventDefault(), !o.dropBubble && t.stopPropagation()), ge && ge.parentNode && ge.parentNode.removeChild(ge), (Te === Ve || Ue && Ue.lastPutMode !== "clone") && Pe && Pe.parentNode && Pe.parentNode.removeChild(Pe), q && (this.nativeDraggable && _e(q, "dragend", this), Yo(q), q.style["will-change"] = "", An && !pn && rt(q, Ue ? Ue.options.ghostClass : this.options.ghostClass, false), rt(q, this.options.chosenClass, false), Qe({
      sortable: this,
      name: "unchoose",
      toEl: Ve,
      newIndex: null,
      newDraggableIndex: null,
      originalEvent: t
    }), Te !== Ve ? (at >= 0 && (Qe({
      rootEl: Ve,
      name: "add",
      toEl: Ve,
      fromEl: Te,
      originalEvent: t
    }), Qe({
      sortable: this,
      name: "remove",
      toEl: Ve,
      originalEvent: t
    }), Qe({
      rootEl: Ve,
      name: "sort",
      toEl: Ve,
      fromEl: Te,
      originalEvent: t
    }), Qe({
      sortable: this,
      name: "sort",
      toEl: Ve,
      originalEvent: t
    })), Ue && Ue.save()) : at !== vn && at >= 0 && (Qe({
      sortable: this,
      name: "update",
      toEl: Ve,
      originalEvent: t
    }), Qe({
      sortable: this,
      name: "sort",
      toEl: Ve,
      originalEvent: t
    })), fe.active && ((at == null || at === -1) && (at = vn, zt = jn), Qe({
      sortable: this,
      name: "end",
      toEl: Ve,
      originalEvent: t
    }), this.save()))), this._nulling();
  },
  _nulling: function() {
    tt("nulling", this), Te = q = Ve = ge = nn = Pe = vo = Wt = en = ht = An = at = zt = vn = jn = mn = Nn = Ue = io = fe.dragged = fe.ghost = fe.clone = fe.active = null, Eo.forEach(function(t) {
      t.checked = true;
    }), Eo.length = xo = Uo = 0;
  },
  handleEvent: function(t) {
    switch (t.type) {
      case "drop":
      case "dragend":
        this._onDrop(t);
        break;
      case "dragenter":
      case "dragover":
        q && (this._onDragOver(t), xd(t));
        break;
      case "selectstart":
        t.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function() {
    for (var t = [], n, o = this.el.children, r = 0, a = o.length, i = this.options; r < a; r++)
      n = o[r], Et(n, i.draggable, this.el, false) && t.push(n.getAttribute(i.dataIdAttr) || Qd(n));
    return t;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function(t, n) {
    var o = {}, r = this.el;
    this.toArray().forEach(function(a, i) {
      var s = r.children[i];
      Et(s, this.options.draggable, r, false) && (o[a] = s);
    }, this), n && this.captureAnimationState(), t.forEach(function(a) {
      o[a] && (r.removeChild(o[a]), r.appendChild(o[a]));
    }), n && this.animateAll();
  },
  /**
   * Save the current sorting
   */
  save: function() {
    var t = this.options.store;
    t && t.set && t.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function(t, n) {
    return Et(t, n || this.options.draggable, this.el, false);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function(t, n) {
    var o = this.options;
    if (n === void 0)
      return o[t];
    var r = to.modifyOption(this, t, n);
    typeof r < "u" ? o[t] = r : o[t] = n, t === "group" && ti(o);
  },
  /**
   * Destroy
   */
  destroy: function() {
    tt("destroy", this);
    var t = this.el;
    t[ct] = null, _e(t, "mousedown", this._onTapStart), _e(t, "touchstart", this._onTapStart), _e(t, "pointerdown", this._onTapStart), this.nativeDraggable && (_e(t, "dragover", this), _e(t, "dragenter", this)), Array.prototype.forEach.call(t.querySelectorAll("[draggable]"), function(n) {
      n.removeAttribute("draggable");
    }), this._onDrop(), this._disableDelayedDragEvents(), Ro.splice(Ro.indexOf(this.el), 1), this.el = t = null;
  },
  _hideClone: function() {
    if (!Wt) {
      if (tt("hideClone", this), fe.eventCanceled)
        return;
      de(Pe, "display", "none"), this.options.removeCloneOnHide && Pe.parentNode && Pe.parentNode.removeChild(Pe), Wt = true;
    }
  },
  _showClone: function(t) {
    if (t.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (Wt) {
      if (tt("showClone", this), fe.eventCanceled)
        return;
      q.parentNode == Te && !this.options.group.revertClone ? Te.insertBefore(Pe, q) : nn ? Te.insertBefore(Pe, nn) : Te.appendChild(Pe), this.options.group.revertClone && this.animate(q, Pe), de(Pe, "display", ""), Wt = false;
    }
  }
};
function xd(e) {
  e.dataTransfer && (e.dataTransfer.dropEffect = "move"), e.cancelable && e.preventDefault();
}
function uo(e, t, n, o, r, a, i, s) {
  var l, u = e[ct], c = u.options.onMove, d2;
  return window.CustomEvent && !jt && !eo ? l = new CustomEvent("move", {
    bubbles: true,
    cancelable: true
  }) : (l = document.createEvent("Event"), l.initEvent("move", true, true)), l.to = t, l.from = e, l.dragged = n, l.draggedRect = o, l.related = r || t, l.relatedRect = a || Le(t), l.willInsertAfter = s, l.originalEvent = i, e.dispatchEvent(l), c && (d2 = c.call(u, l, i)), d2;
}
function Yo(e) {
  e.draggable = false;
}
function Ud() {
  gr = false;
}
function Kd(e, t, n) {
  var o = Le(Fn(n.el, 0, n.options, true)), r = 10;
  return t ? e.clientX < o.left - r || e.clientY < o.top && e.clientX < o.right : e.clientY < o.top - r || e.clientY < o.bottom && e.clientX < o.left;
}
function Yd(e, t, n) {
  var o = Le(Tr(n.el, n.options.draggable)), r = 10;
  return t ? e.clientX > o.right + r || e.clientX <= o.right && e.clientY > o.bottom && e.clientX >= o.left : e.clientX > o.right && e.clientY > o.top || e.clientX <= o.right && e.clientY > o.bottom + r;
}
function Gd(e, t, n, o, r, a, i, s) {
  var l = o ? e.clientY : e.clientX, u = o ? n.height : n.width, c = o ? n.top : n.left, d2 = o ? n.bottom : n.right, f = false;
  if (!i) {
    if (s && bo < u * r) {
      if (!Ln && (Nn === 1 ? l > c + u * a / 2 : l < d2 - u * a / 2) && (Ln = true), Ln)
        f = true;
      else if (Nn === 1 ? l < c + bo : l > d2 - bo)
        return -Nn;
    } else if (l > c + u * (1 - r) / 2 && l < d2 - u * (1 - r) / 2)
      return Xd(t);
  }
  return f = f || i, f && (l < c + u * a / 2 || l > d2 - u * a / 2) ? l > c + u / 2 ? 1 : -1 : 0;
}
function Xd(e) {
  return ft(q) < ft(e) ? 1 : -1;
}
function Qd(e) {
  for (var t = e.tagName + e.className + e.src + e.href + e.textContent, n = t.length, o = 0; n--; )
    o += t.charCodeAt(n);
  return o.toString(36);
}
function Jd(e) {
  Eo.length = 0;
  for (var t = e.getElementsByTagName("input"), n = t.length; n--; ) {
    var o = t[n];
    o.checked && Eo.push(o);
  }
}
function yo(e) {
  return setTimeout(e, 0);
}
function vr(e) {
  return clearTimeout(e);
}
Bo && Fe(document, "touchmove", function(e) {
  (fe.active || pn) && e.cancelable && e.preventDefault();
});
fe.utils = {
  on: Fe,
  off: _e,
  css: de,
  find: Ga,
  is: function(t, n) {
    return !!Et(t, n, t, false);
  },
  extend: Vd,
  throttle: Xa,
  closest: Et,
  toggleClass: rt,
  clone: Ja,
  index: ft,
  nextTick: yo,
  cancelNextTick: vr,
  detectDirection: ei,
  getChild: Fn
};
fe.get = function(e) {
  return e[ct];
};
fe.mount = function() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  t[0].constructor === Array && (t = t[0]), t.forEach(function(o) {
    if (!o.prototype || !o.prototype.constructor)
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(o));
    o.utils && (fe.utils = At(At({}, fe.utils), o.utils)), to.mount(o);
  });
};
fe.create = function(e, t) {
  return new fe(e, t);
};
fe.version = $d;
var Me = [];
var In;
var br;
var yr = false;
var Go;
var Xo;
var Do;
var Vn;
function Zd() {
  function e() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };
    for (var t in this)
      t.charAt(0) === "_" && typeof this[t] == "function" && (this[t] = this[t].bind(this));
  }
  return e.prototype = {
    dragStarted: function(n) {
      var o = n.originalEvent;
      this.sortable.nativeDraggable ? Fe(document, "dragover", this._handleAutoScroll) : this.options.supportPointer ? Fe(document, "pointermove", this._handleFallbackAutoScroll) : o.touches ? Fe(document, "touchmove", this._handleFallbackAutoScroll) : Fe(document, "mousemove", this._handleFallbackAutoScroll);
    },
    dragOverCompleted: function(n) {
      var o = n.originalEvent;
      !this.options.dragOverBubble && !o.rootEl && this._handleAutoScroll(o);
    },
    drop: function() {
      this.sortable.nativeDraggable ? _e(document, "dragover", this._handleAutoScroll) : (_e(document, "pointermove", this._handleFallbackAutoScroll), _e(document, "touchmove", this._handleFallbackAutoScroll), _e(document, "mousemove", this._handleFallbackAutoScroll)), aa(), wo(), Pd();
    },
    nulling: function() {
      Do = br = In = yr = Vn = Go = Xo = null, Me.length = 0;
    },
    _handleFallbackAutoScroll: function(n) {
      this._handleAutoScroll(n, true);
    },
    _handleAutoScroll: function(n, o) {
      var r = this, a = (n.touches ? n.touches[0] : n).clientX, i = (n.touches ? n.touches[0] : n).clientY, s = document.elementFromPoint(a, i);
      if (Do = n, o || this.options.forceAutoScrollFallback || eo || jt || Mn) {
        Qo(n, this.options, s, o);
        var l = Ut(s, true);
        yr && (!Vn || a !== Go || i !== Xo) && (Vn && aa(), Vn = setInterval(function() {
          var u = Ut(document.elementFromPoint(a, i), true);
          u !== l && (l = u, wo()), Qo(n, r.options, u, o);
        }, 10), Go = a, Xo = i);
      } else {
        if (!this.options.bubbleScroll || Ut(s, true) === Tt()) {
          wo();
          return;
        }
        Qo(n, this.options, Ut(s, false), false);
      }
    }
  }, Bt(e, {
    pluginName: "scroll",
    initializeByDefault: true
  });
}
function wo() {
  Me.forEach(function(e) {
    clearInterval(e.pid);
  }), Me = [];
}
function aa() {
  clearInterval(Vn);
}
var Qo = Xa(function(e, t, n, o) {
  if (t.scroll) {
    var r = (e.touches ? e.touches[0] : e).clientX, a = (e.touches ? e.touches[0] : e).clientY, i = t.scrollSensitivity, s = t.scrollSpeed, l = Tt(), u = false, c;
    br !== n && (br = n, wo(), In = t.scroll, c = t.scrollFn, In === true && (In = Ut(n, true)));
    var d2 = 0, f = In;
    do {
      var h2 = f, b = Le(h2), m = b.top, _ = b.bottom, y = b.left, E = b.right, k = b.width, O = b.height, T = void 0, D = void 0, $ = h2.scrollWidth, F = h2.scrollHeight, M = de(h2), ie = h2.scrollLeft, Q = h2.scrollTop;
      h2 === l ? (T = k < $ && (M.overflowX === "auto" || M.overflowX === "scroll" || M.overflowX === "visible"), D = O < F && (M.overflowY === "auto" || M.overflowY === "scroll" || M.overflowY === "visible")) : (T = k < $ && (M.overflowX === "auto" || M.overflowX === "scroll"), D = O < F && (M.overflowY === "auto" || M.overflowY === "scroll"));
      var V = T && (Math.abs(E - r) <= i && ie + k < $) - (Math.abs(y - r) <= i && !!ie), N = D && (Math.abs(_ - a) <= i && Q + O < F) - (Math.abs(m - a) <= i && !!Q);
      if (!Me[d2])
        for (var Y = 0; Y <= d2; Y++)
          Me[Y] || (Me[Y] = {});
      (Me[d2].vx != V || Me[d2].vy != N || Me[d2].el !== h2) && (Me[d2].el = h2, Me[d2].vx = V, Me[d2].vy = N, clearInterval(Me[d2].pid), (V != 0 || N != 0) && (u = true, Me[d2].pid = setInterval((function() {
        o && this.layer === 0 && fe.active._onTouchMove(Do);
        var me = Me[this.layer].vy ? Me[this.layer].vy * s : 0, pe = Me[this.layer].vx ? Me[this.layer].vx * s : 0;
        typeof c == "function" && c.call(fe.dragged.parentNode[ct], pe, me, e, Do, Me[this.layer].el) !== "continue" || Qa(Me[this.layer].el, pe, me);
      }).bind({
        layer: d2
      }), 24))), d2++;
    } while (t.bubbleScroll && f !== l && (f = Ut(f, false)));
    yr = u;
  }
}, 30);
var ri = function(t) {
  var n = t.originalEvent, o = t.putSortable, r = t.dragEl, a = t.activeSortable, i = t.dispatchSortableEvent, s = t.hideGhostForTarget, l = t.unhideGhostForTarget;
  if (n) {
    var u = o || a;
    s();
    var c = n.changedTouches && n.changedTouches.length ? n.changedTouches[0] : n, d2 = document.elementFromPoint(c.clientX, c.clientY);
    l(), u && !u.el.contains(d2) && (i("spill"), this.onSpill({
      dragEl: r,
      putSortable: o
    }));
  }
};
function Ar() {
}
Ar.prototype = {
  startIndex: null,
  dragStart: function(t) {
    var n = t.oldDraggableIndex;
    this.startIndex = n;
  },
  onSpill: function(t) {
    var n = t.dragEl, o = t.putSortable;
    this.sortable.captureAnimationState(), o && o.captureAnimationState();
    var r = Fn(this.sortable.el, this.startIndex, this.options);
    r ? this.sortable.el.insertBefore(n, r) : this.sortable.el.appendChild(n), this.sortable.animateAll(), o && o.animateAll();
  },
  drop: ri
};
Bt(Ar, {
  pluginName: "revertOnSpill"
});
function Ir() {
}
Ir.prototype = {
  onSpill: function(t) {
    var n = t.dragEl, o = t.putSortable, r = o || this.sortable;
    r.captureAnimationState(), n.parentNode && n.parentNode.removeChild(n), r.animateAll();
  },
  drop: ri
};
Bt(Ir, {
  pluginName: "removeOnSpill"
});
fe.mount(new Zd());
fe.mount(Ir, Ar);
var ef = Object.defineProperty;
var tf = Object.defineProperties;
var nf = Object.getOwnPropertyDescriptors;
var ia = Object.getOwnPropertySymbols;
var of = Object.prototype.hasOwnProperty;
var rf = Object.prototype.propertyIsEnumerable;
var sa = (e, t, n) => t in e ? ef(e, t, { enumerable: true, configurable: true, writable: true, value: n }) : e[t] = n;
var Kt = (e, t) => {
  for (var n in t || (t = {}))
    of.call(t, n) && sa(e, n, t[n]);
  if (ia)
    for (var n of ia(t))
      rf.call(t, n) && sa(e, n, t[n]);
  return e;
};
var ko = (e, t) => tf(e, nf(t));
function Jo(e) {
  e.parentElement !== null && e.parentElement.removeChild(e);
}
function la(e, t, n) {
  const o = n === 0 ? e.children[0] : e.children[n - 1].nextSibling;
  e.insertBefore(t, o);
}
function af() {
  return typeof window < "u" ? window.console : global.console;
}
var sf = af();
function lf(e) {
  const t = /* @__PURE__ */ Object.create(null);
  return function(o) {
    return t[o] || (t[o] = e(o));
  };
}
var uf = /-(\w)/g;
var cf = lf((e) => e.replace(uf, (t, n) => n.toUpperCase()));
var ai = ["Start", "Add", "Remove", "Update", "End"];
var ii = ["Choose", "Unchoose", "Sort", "Filter", "Clone"];
var si = ["Move"];
var df = [si, ai, ii].flatMap((e) => e).map((e) => `on${e}`);
var wr = {
  manage: si,
  manageAndEmit: ai,
  emit: ii
};
function ff(e) {
  return df.indexOf(e) !== -1;
}
var hf = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "math",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rb",
  "rp",
  "rt",
  "rtc",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "slot",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "svg",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr"
];
function mf(e) {
  return hf.includes(e);
}
function pf(e) {
  return ["transition-group", "TransitionGroup"].includes(e);
}
function li(e) {
  return ["id", "class", "role", "style"].includes(e) || e.startsWith("data-") || e.startsWith("aria-") || e.startsWith("on");
}
function ui(e) {
  return e.reduce((t, [n, o]) => (t[n] = o, t), {});
}
function gf({ $attrs: e, componentData: t = {} }) {
  const n = ui(Object.entries(e).filter(([o, r]) => li(o)));
  return Kt(Kt({}, n), t);
}
function vf({ $attrs: e, callBackBuilder: t }) {
  const n = ui(ci(e));
  Object.entries(t).forEach(([r, a]) => {
    wr[r].forEach((i) => {
      n[`on${i}`] = a(i);
    });
  });
  const o = `[data-draggable]${n.draggable || ""}`;
  return ko(Kt({}, n), {
    draggable: o
  });
}
function ci(e) {
  return Object.entries(e).filter(([t, n]) => !li(t)).map(([t, n]) => [cf(t), n]).filter(([t, n]) => !ff(t));
}
var ua = (e) => {
  const t = e.el || Array.isArray(e.children) && e.children[0].el.parentNode;
  return t || console.error("使用 transition-group , 需要在slot中template内至少2层html标签"), t || {};
};
var bf = (e, t) => e.__draggable_context = t;
var ca = (e) => e.__draggable_context;
var yf = class {
  constructor({
    nodes: { header: t, default: n, footer: o },
    root: r,
    realList: a
  }) {
    this.defaultNodes = n, this.children = [...t, ...n, ...o], this.externalComponent = r.externalComponent, this.rootTransition = r.transition, this.tag = r.tag, this.realList = a;
  }
  get _isRootComponent() {
    return this.externalComponent || this.rootTransition;
  }
  render(t, n) {
    const { tag: o, children: r, _isRootComponent: a } = this;
    return t(o, n, a ? { default: () => r } : r);
  }
  updated() {
    const { defaultNodes: t, realList: n } = this;
    t.forEach((o, r) => {
      bf(ua(o), {
        element: n[r],
        index: r
      });
    });
  }
  getUnderlyingVm(t) {
    return ca(t);
  }
  getVmIndexFromDomIndex(t, n) {
    const { defaultNodes: o } = this, { length: r } = o, a = n.children, i = a.item(t);
    if (i === null)
      return r;
    const s = ca(i);
    if (s)
      return s.index;
    if (r === 0)
      return 0;
    const l = ua(o[0]), u = [...a].findIndex((c) => c === l);
    return t < u ? 0 : r;
  }
};
function wf(e, t) {
  const n = e[t];
  return n ? n() : [];
}
function _f({ $slots: e, realList: t, getKey: n }) {
  const o = t || [], [r, a] = ["header", "footer"].map((l) => wf(e, l)), { item: i } = e;
  if (!i)
    throw new Error("draggable element must have an item slot");
  const s = o.flatMap((l, u) => i({ element: l, index: u }).map((c) => (c.key = n(l), c.props = ko(Kt({}, c.props || {}), { "data-draggable": true }), c)));
  if (s.length !== o.length)
    throw new Error("Item slot must have only one child");
  return {
    header: r,
    footer: a,
    default: s
  };
}
function Cf(e) {
  const t = pf(e), n = !mf(e) && !t;
  return {
    transition: t,
    externalComponent: n,
    tag: n ? resolveComponent(e) : t ? TransitionGroup : e
  };
}
function Sf({ $slots: e, tag: t, realList: n, getKey: o }) {
  const r = _f({ $slots: e, realList: n, getKey: o }), a = Cf(t);
  return new yf({ nodes: r, root: a, realList: n });
}
function di(e, t) {
  nextTick(() => this.$emit(e.toLowerCase(), t));
}
function fi(e) {
  return (t, n) => {
    if (this.realList !== null)
      return this[`onDrag${e}`](t, n);
  };
}
function Ff(e) {
  const t = fi.call(this, e);
  return (n, o) => {
    t.call(this, n, o), di.call(this, e, n);
  };
}
var Zo = null;
var Rf = {
  list: {
    type: Array,
    required: false,
    default: null
  },
  modelValue: {
    type: Array,
    required: false,
    default: null
  },
  itemKey: {
    type: [String, Function],
    required: true
  },
  clone: {
    type: Function,
    default: (e) => e
  },
  tag: {
    type: String,
    default: "div"
  },
  move: {
    type: Function,
    default: null
  },
  componentData: {
    type: Object,
    required: false,
    default: null
  }
};
var Ef = [
  "update:modelValue",
  "change",
  ...[...wr.manageAndEmit, ...wr.emit].map((e) => e.toLowerCase())
];
var Df = defineComponent({
  name: "draggable",
  inheritAttrs: false,
  props: Rf,
  emits: Ef,
  data() {
    return {
      error: false
    };
  },
  render() {
    try {
      this.error = false;
      const { $slots: e, $attrs: t, tag: n, componentData: o, realList: r, getKey: a } = this, i = Sf({
        $slots: e,
        tag: n,
        realList: r,
        getKey: a
      });
      this.componentStructure = i;
      const s = gf({ $attrs: t, componentData: o });
      return i.render(h, s);
    } catch (e) {
      return this.error = true, h("pre", { style: { color: "red" } }, e.stack);
    }
  },
  created() {
    this.list !== null && this.modelValue !== null && sf.error("modelValue and list props are mutually exclusive! Please set one or another.");
  },
  mounted() {
    if (this.error)
      return;
    const { $attrs: e, $el: t, componentStructure: n } = this;
    n.updated();
    const o = vf({
      $attrs: e,
      callBackBuilder: {
        manageAndEmit: (a) => Ff.call(this, a),
        emit: (a) => di.bind(this, a),
        manage: (a) => fi.call(this, a)
      }
    }), r = t.nodeType === 1 ? t : t.parentElement;
    this._sortable = new fe(r, o), this.targetDomElement = r, r.__draggable_component__ = this;
  },
  updated() {
    this.componentStructure.updated();
  },
  beforeUnmount() {
    this._sortable !== void 0 && this._sortable.destroy();
  },
  computed: {
    realList() {
      const { list: e } = this;
      return e || this.modelValue;
    },
    getKey() {
      const { itemKey: e } = this;
      return typeof e == "function" ? e : (t) => t[e];
    }
  },
  watch: {
    $attrs: {
      handler(e) {
        const { _sortable: t } = this;
        t && ci(e).forEach(([n, o]) => {
          t.option(n, o);
        });
      },
      deep: true
    }
  },
  methods: {
    getUnderlyingVm(e) {
      return this.componentStructure.getUnderlyingVm(e) || null;
    },
    getUnderlyingPotencialDraggableComponent(e) {
      return e.__draggable_component__;
    },
    emitChanges(e) {
      nextTick(() => this.$emit("change", e));
    },
    alterList(e) {
      if (this.list) {
        e(this.list);
        return;
      }
      const t = [...this.modelValue];
      e(t), this.$emit("update:modelValue", t);
    },
    spliceList() {
      const e = (t) => t.splice(...arguments);
      this.alterList(e);
    },
    updatePosition(e, t) {
      const n = (o) => o.splice(t, 0, o.splice(e, 1)[0]);
      this.alterList(n);
    },
    getRelatedContextFromMoveEvent({ to: e, related: t }) {
      const n = this.getUnderlyingPotencialDraggableComponent(e);
      if (!n)
        return { component: n };
      const o = n.realList, r = { list: o, component: n };
      if (e !== t && o) {
        const a = n.getUnderlyingVm(t) || {};
        return Kt(Kt({}, a), r);
      }
      return r;
    },
    getVmIndexFromDomIndex(e) {
      return this.componentStructure.getVmIndexFromDomIndex(e, this.targetDomElement);
    },
    onDragStart(e) {
      this.context = this.getUnderlyingVm(e.item), e.item._underlying_vm_ = this.clone(this.context.element), Zo = e.item;
    },
    onDragAdd(e) {
      const t = e.item._underlying_vm_;
      if (t === void 0)
        return;
      Jo(e.item);
      const n = this.getVmIndexFromDomIndex(e.newIndex);
      this.spliceList(n, 0, t);
      const o = { element: t, newIndex: n };
      this.emitChanges({ added: o });
    },
    onDragRemove(e) {
      if (la(this.$el, e.item, e.oldIndex), e.pullMode === "clone") {
        Jo(e.clone);
        return;
      }
      const { index: t, element: n } = this.context;
      this.spliceList(t, 1);
      const o = { element: n, oldIndex: t };
      this.emitChanges({ removed: o });
    },
    onDragUpdate(e) {
      Jo(e.item), la(e.from, e.item, e.oldIndex);
      const t = this.context.index, n = this.getVmIndexFromDomIndex(e.newIndex);
      this.updatePosition(t, n);
      const o = { element: this.context.element, oldIndex: t, newIndex: n };
      this.emitChanges({ moved: o });
    },
    computeFutureIndex(e, t) {
      if (!e.element)
        return 0;
      const n = [...t.to.children].filter((i) => i.style.display !== "none"), o = n.indexOf(t.related), r = e.component.getVmIndexFromDomIndex(o);
      return n.indexOf(Zo) !== -1 || !t.willInsertAfter ? r : r + 1;
    },
    onDragMove(e, t) {
      const { move: n, realList: o } = this;
      if (!n || !o)
        return true;
      const r = this.getRelatedContextFromMoveEvent(e), a = this.computeFutureIndex(r, e), i = ko(Kt({}, this.context), {
        futureIndex: a
      }), s = ko(Kt({}, e), {
        relatedContext: r,
        draggedContext: i
      });
      return n(s, t);
    },
    onDragEnd() {
      Zo = null;
    }
  }
});
var kf = defineComponent({
  name: "FsTableColumnsFixedController",
  props: {
    modelValue: {
      default: false
    }
  },
  emits: ["update:modelValue", "change"],
  setup(e, t) {
    const { ui: n } = R(), o = computed(() => [
      {
        value: "left",
        icon: n.icons.left
        // 'el-icon-arrow-left'
      },
      {
        value: false,
        icon: n.icons.close
        // 'el-icon-close'
      },
      {
        value: "right",
        icon: n.icons.right
        // 'el-icon-arrow-right'
      }
    ]);
    function r(a) {
      t.emit("update:modelValue", a), t.emit("change", a);
    }
    return {
      ui: n,
      options: o,
      submit: r
    };
  }
});
function Of(e, t, n, o, r, a) {
  const i = resolveComponent("fs-button");
  return openBlock(), createBlock(resolveDynamicComponent(e.ui.buttonGroup.name), { class: "fs-table-columns-fixed-controller" }, {
    default: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList(e.options, (s) => (openBlock(), createBlock(i, {
        key: s.icon,
        type: e.modelValue === s.value ? "primary" : "default",
        icon: s.icon,
        size: "small",
        onClick: (l) => e.submit(s.value)
      }, null, 8, ["type", "icon", "onClick"]))), 128))
    ]),
    _: 1
  });
}
var hi = Ee(kf, [["render", Of]]);
var $f = ["title", "i"];
var Tf = { class: "item-right" };
var Af = {
  "flex-box": "0",
  class: "component--list-item-handle handle"
};
var If = { style: { "margin-left": "20px", "padding-left": "10px", "border-left": "1px solid #eee" } };
var mi = defineComponent({
  __name: "fs-columns-filter-nest-list",
  props: {
    columns: {},
    isRoot: { type: Boolean, default: false }
  },
  emits: ["check-changed", "fixed-changed"],
  setup(e, { emit: t }) {
    const { ui: n } = R(), o = t, { originalColumns: r, currentColumns: a, originalColumnsMap: i, text: s, active: l } = inject($r);
    function u(m) {
      return m.label || m.title || m.key || s.value.unnamed;
    }
    function c(m) {
      const _ = m.draggedContext.element, y = m.relatedContext.element, E = [];
      for (const $ of a.value)
        $.key === _.key ? E.push(y) : $.key === y.key ? E.push(_) : E.push($);
      let k = 0, O = E.length - 1, T = E.length - 1, D = 0;
      for (let $ = 0; $ < E.length; $++) {
        const F = E[$];
        F.fixed === "left" ? k = $ : F.fixed === "right" ? O = O > $ ? $ : O : (T = T > $ ? $ : T, D = D < $ ? $ : D);
      }
      if (T < k || D > O)
        return false;
    }
    function d2(m) {
      return "update:" + m;
    }
    function f(m) {
      m.show = !m.show;
      function _(E) {
        E.children && E.children.forEach((k) => {
          !k.__show || k.__disabled || (k.show = E.show, _(k));
        });
      }
      _(m);
      function y(E) {
        if (E.__parent) {
          const k = E.__parent;
          k && (k.show = k.children.filter((O) => O.__show && O.show === true).length > 0, y(k));
        }
      }
      y(m);
    }
    function h2() {
      o("check-changed");
    }
    function b(m, _) {
      o("fixed-changed", m, _);
    }
    return (m, _) => {
      const y = resolveComponent("fs-icon"), E = resolveComponent("fs-columns-filter-nest-list", true);
      return openBlock(), createBlock(unref(Df), {
        list: m.columns,
        "item-key": "key",
        move: c
      }, {
        item: withCtx(({ element: k, index: O }) => {
          var T, D;
          return [
            createBaseVNode("div", null, [
              withDirectives(createBaseVNode("div", {
                title: u(k),
                class: "component--list-item",
                flex: "main:justify cross:center",
                i: O
              }, [
                (openBlock(), createBlock(resolveDynamicComponent(unref(n).checkbox.name), mergeProps({
                  [unref(n).checkbox.modelValue || ""]: k.show,
                  disabled: ((T = unref(i)[k.__key]) == null ? void 0 : T.__disabled) === true,
                  class: "item-label",
                  title: u(k)
                }, {
                  [toHandlerKey(d2(unref(n).checkbox.modelValue))]: ($) => f(k)
                }, { onChange: h2 }), {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(u(k)), 1)
                  ]),
                  _: 2
                }, 1040, ["disabled", "title"])),
                createBaseVNode("div", Tf, [
                  m.isRoot ? (openBlock(), createBlock(hi, {
                    key: 0,
                    modelValue: k.fixed,
                    "onUpdate:modelValue": ($) => k.fixed = $,
                    "flex-box": "0",
                    class: "d2-mr-10",
                    onChange: ($) => b(O, $)
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "onChange"])) : createCommentVNode("", true),
                  createBaseVNode("div", Af, [
                    createVNode(y, {
                      icon: unref(n).icons.sort
                    }, null, 8, ["icon"])
                  ])
                ])
              ], 8, $f), [
                [vShow, ((D = unref(i)[k.__key]) == null ? void 0 : D.__show) !== false]
              ]),
              createBaseVNode("div", If, [
                k.children ? (openBlock(), createBlock(E, {
                  key: 0,
                  columns: k.children,
                  onCheckChanged: h2
                }, null, 8, ["columns"])) : createCommentVNode("", true)
              ])
            ])
          ];
        }),
        _: 1
      }, 8, ["list"]);
    };
  }
});
var Vf = { class: "component--list" };
var Pf = {
  key: "__first__",
  class: "component--list-item",
  flex: "main:justify cross:center"
};
var Mf = { span: 12 };
var Bf = { class: "title" };
var jf = defineComponent({
  __name: "fs-columns-filter-layout-default",
  props: {
    width: {},
    drawer: {}
  },
  setup(e) {
    const { ui: t } = R(), { originalColumns: n, currentColumns: o, text: r, active: a } = inject($r), i = e, s = computed(() => lodash_default_default.merge(
      {
        [t.drawer.visible]: a.value,
        ["onUpdate:" + t.drawer.visible]: (_) => {
          a.value = _;
        },
        [t.drawer.width]: i.width || "400px"
      },
      i.drawer
    )), l = ref(false);
    function u(_) {
      l.value = _, o.value = o.value.map((y) => (!y.__show || y.__disabled || (y.show = _), y));
    }
    const c = computed(() => ({
      [t.checkbox.modelValue]: l.value,
      ["onUpdate:" + t.checkbox.modelValue]: (_) => {
        u(_);
      }
    })), d2 = computed(() => o.value.filter((_) => _.__show && _.show === true).length), f = computed(() => o.value.filter((_) => _.__show).length), h2 = computed(() => d2.value > 0 && d2.value < f.value);
    watch(
      () => {
        o.value;
      },
      () => {
        m();
      },
      { immediate: true }
    );
    function b(_, y) {
      y && (o.value[_].show = true), y === "left" && o.value.unshift(o.value.splice(_, 1)[0]), y === "right" && o.value.push(o.value.splice(_, 1)[0]), m();
    }
    function m() {
      l.value = d2.value === f.value;
    }
    return (_, y) => (openBlock(), createBlock(resolveDynamicComponent(unref(t).drawer.name), mergeProps({
      class: "fs-columns-filter-layout-default",
      title: unref(r).title
    }, s.value, { "append-to-body": "" }), {
      default: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent(unref(t).drawer.hasContentWrap || "div"), {
          class: "fs-drawer-wrapper fs-table-columns-filter",
          title: unref(r).title
        }, {
          default: withCtx(() => [
            (openBlock(), createBlock(resolveDynamicComponent(unref(t).card.name), { shadow: "never" }, {
              default: withCtx(() => [
                createBaseVNode("div", Vf, [
                  createBaseVNode("div", Pf, [
                    createBaseVNode("span", Mf, [
                      (openBlock(), createBlock(resolveDynamicComponent(unref(t).checkbox.name), mergeProps({ indeterminate: h2.value }, c.value), {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(d2.value) + " / " + toDisplayString(f.value), 1)
                        ]),
                        _: 1
                      }, 16, ["indeterminate"]))
                    ]),
                    createBaseVNode("span", Bf, toDisplayString(unref(r).fixed) + " / " + toDisplayString(unref(r).order), 1)
                  ]),
                  createVNode(mi, {
                    columns: unref(o),
                    "is-root": true,
                    onCheckChanged: m,
                    onFixedChanged: b
                  }, null, 8, ["columns"])
                ])
              ]),
              _: 1
            })),
            renderSlot(_.$slots, "buttons")
          ]),
          _: 3
        }, 8, ["title"]))
      ]),
      _: 3
    }, 16, ["title"]));
  }
});
var Nf = defineComponent({
  name: "FsSearchButtons",
  inheritAttrs: false,
  props: {
    buttons: {
      type: Object
    }
  },
  setup() {
    const { ui: e } = R();
    return { ui: e };
  }
});
var Lf = { class: "fs-search-col fs-search-btns" };
function qf(e, t, n, o, r, a) {
  const i = resolveComponent("fs-button");
  return openBlock(), createElementBlock("div", Lf, [
    (openBlock(), createBlock(resolveDynamicComponent(e.ui.formItem.name), null, {
      default: withCtx(() => [
        (openBlock(true), createElementBlock(Fragment, null, renderList(e.buttons, (s, l) => (openBlock(), createElementBlock(Fragment, { key: l }, [
          s.show ? (openBlock(), createBlock(i, mergeProps({
            key: 0,
            ref_for: true
          }, s, {
            onClick: (u) => s._click()
          }), null, 16, ["onClick"])) : createCommentVNode("", true)
        ], 64))), 128))
      ]),
      _: 1
    }))
  ]);
}
var pi = Ee(Nf, [["render", qf]]);
var Hf = defineComponent({
  name: "FsSearch",
  components: {
    FsSearchButtons: pi
  },
  inheritAttrs: false,
  props: {
    /**
     * 布局容器
     */
    container: {
      type: Object
    },
    /**
     * 初始查询条件
     * 点击重置，会重置成该条件
     */
    initialForm: {
      type: Object
    },
    /**
     * 校验后的查询表单数据
     */
    validatedForm: {
      type: Object
    },
    /**
     * 表单参数
     * 支持el-form | a-form的属性
     */
    options: {
      type: Object
    },
    /**
     * 查询字段配置
     */
    columns: {
      type: Object
    },
    /**
     * 按钮配置,可以根据order排序
     * `{search:{...FsButton},reset:{...FsButton}}`
     */
    buttons: {
      type: Object
    },
    /**
     * 点击重置后是否立即触发查询
     */
    searchAfterReset: {
      type: Boolean,
      default: true
    },
    /**
     * 是否开启自动查询
     */
    autoSearch: {
      type: Boolean,
      default: true
    },
    /**
     * 自动查询，防抖设置
     * 传false则关闭自动查询
     */
    debounce: {
      type: [Boolean, Object],
      default: void 0
    },
    /**
     * 插槽
     */
    slots: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * 是否显示查询框
     */
    show: {
      type: Boolean,
      default: true
    },
    /**
     * 是否启用校验
     */
    validate: {
      default: false
    },
    /**
     * 是否任意值变化就触发校验
     */
    validateOnChange: {
      default: true,
      type: Boolean
    },
    /**
     * 列的宽度设置，span=xx
     */
    col: {},
    /**
     * 统一字段的formItem属性
     */
    formItem: {
      type: Object,
      default: void 0
    }
  },
  emits: [
    /**
     * 查询事件
     **/
    "search",
    /**
     * 查询事件，此事件供系统调用
     */
    "_search",
    /**
     * 重置事件，供用户使用
     **/
    "reset",
    /**
     * 重置事件，此事件供系统调用
     */
    "_reset",
    /**
     * 校验失败事件
     */
    "validate-error",
    /**
     * 校验后的表单数据变化
     */
    "update:validatedForm"
  ],
  setup(e, t) {
    const {
      ui: n
    } = R(), {
      merge: o
    } = Re(), r = o, {
      doComputed: a,
      AsyncComputeValue: i,
      ComputeValue: s
    } = It();
    lodash_default_default.each(e.columns, (g) => {
      g.value != null && (g.value instanceof i || g.value instanceof s) && se.warn("search.value配置不支持ComputeValue/AsyncCompute类型的动态计算");
    });
    function l() {
      const g = {};
      return lodash_default_default.forEach(e.columns, (v, S) => {
        var I;
        if (v.value === void 0)
          return;
        const R2 = unref(v.value);
        R2 !== void 0 && v.show !== false && ((I = v.component) == null ? void 0 : I.show) !== false && (g[S] = R2);
      }), lodash_default_default.cloneDeep(o({}, e.initialForm, g));
    }
    const u = reactive(l());
    let c = null;
    const d2 = a(() => e.columns, T, null, (g) => {
      const v = lodash_default_default.cloneDeep(e.formItem || {});
      lodash_default_default.forEach(g, (I) => {
        o(I, v, I);
      }), e.validate || lodash_default_default.forEach(g, (I) => {
        delete I.rules, delete I.rule;
      }), e.col && lodash_default_default.forEach(g, (I) => {
        I.col = o({}, e.col, I.col);
      }), lodash_default_default.forEach(g, (I) => {
        I._cellRender = () => m(I);
      });
      let S = [];
      lodash_default_default.forEach(g, (I, P) => {
        I._key = P, S.push(I);
      }), S = lodash_default_default.sortBy(S, (I) => I.order ?? Gt.orderDefault);
      const R2 = {};
      return S.forEach((I) => {
        let P = I._key;
        delete I._key, R2[P] = I;
      }), R2;
    });
    function f() {
      const g = lodash_default_default.cloneDeep(u);
      t.emit("update:validatedForm", g);
    }
    watch(() => e.validatedForm, (g) => {
      for (const v in u)
        delete u[v];
      o(u, g || {});
    }, {
      deep: true
    });
    const h2 = (g, v) => lodash_default_default.get(g, v);
    function b(g) {
      if (g != null)
        return g.indexOf(".") >= 0 ? g.split(".") : g;
    }
    function m(g) {
      const v = g.key;
      async function S(G) {
        K(G, g);
      }
      function R2() {
        Se(g);
      }
      function I(G, U) {
        U.code === "Enter" && G.autoSearchTrigger === "enter" && F();
      }
      let P = null;
      e.slots["search_" + v] ? P = createVNode(resolveComponent("fs-slot-render"), {
        slots: e.slots["search_" + v],
        scope: D(v)
      }, null) : g.render ? P = createVNode(resolveComponent("fs-render"), {
        "render-func": g.render,
        scope: D(v)
      }, null) : g.component && g.component.show !== false && (P = createVNode(resolveComponent("fs-component-render"), mergeProps({
        ref: (G) => {
          E.value[v] = G;
        },
        "model-value": h2(u, v),
        onKeyup: (G) => {
          I(g, G);
        }
      }, g.component, {
        scope: D(v),
        "onUpdate:modelValue": S,
        onInput: R2
      }), null));
      const x = b(v);
      return n.formItem.render({
        props: {
          ...g,
          label: g.title,
          [n.formItem.prop]: x,
          path: v,
          rulePath: v
        },
        slots: {
          default() {
            return P;
          }
        }
      });
    }
    const _ = ref(), {
      t: y
    } = et(), E = ref({});
    function k(g) {
      return E.value[g];
    }
    function O(g) {
      var v;
      return (v = k(g)) == null ? void 0 : v.getTargetRef();
    }
    function T() {
      return {
        form: u,
        validatedForm: e.validatedForm,
        getComponentRef: O,
        doSearch: F,
        doReset: M,
        doValidate: $
      };
    }
    function D(g) {
      return {
        ...T(),
        key: g,
        value: lodash_default_default.get(u, g)
      };
    }
    async function $(g = false, v = "search") {
      try {
        return e.validate && await n.form.validateWrap(_.value), true;
      } catch (S) {
        return g || t.emit("validate-error", {
          ...T(),
          error: S,
          trigger: v
        }), false;
      }
    }
    async function F() {
      c && c.cancel(), await $() && (f(), await nextTick(), t.emit("_search", T()), t.emit("search", T()));
    }
    async function M() {
      const g = l(), v = lodash_default_default.entries(u);
      for (const S of v) {
        const R2 = lodash_default_default.get(g, S[0]);
        R2 == null ? lodash_default_default.unset(u, S[0]) : lodash_default_default.set(u, S[0], R2);
      }
      await $() && (f(), await nextTick(), e.reset && e.reset(T()), t.emit("_reset", T()), t.emit("reset", T()), e.searchAfterReset && F());
    }
    const ie = computed(() => {
      const g = [], v = {
        search: {
          show: true,
          type: "primary",
          disabled: false,
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          click: (S) => {
            F();
          },
          order: 1,
          text: y("fs.search.search.text")
          // '查询',
        },
        reset: {
          show: true,
          disabled: false,
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          click: (S) => {
            M();
          },
          text: y("fs.search.reset.text"),
          // '重置',
          order: 2
        }
      };
      o(v, e.buttons);
      for (let S in v) {
        const R2 = v[S];
        R2._click = () => {
          R2.click(T());
        }, g.push(R2);
      }
      return g.sort((S, R2) => S.order - R2.order), g;
    });
    function Q() {
      var g;
      if (e.autoSearch !== false && e.debounce !== false) {
        let v = ((g = e.debounce) == null ? void 0 : g.wait) || 500;
        c = lodash_default_default.debounce(F, v, e.debounce);
      }
    }
    Q();
    function V() {
      return u;
    }
    function N() {
      return e.validatedForm;
    }
    function Y(g, v = true) {
      v || lodash_default_default.each(lodash_default_default.keys(u), (S) => {
        delete u[S];
      }), r(u, g), f();
    }
    const me = ref(false), pe = () => {
      se.debug("do auto search,inputEventDisabled:", me.value), me.value !== true && c && c();
    }, Se = (g) => {
      g.autoSearchTrigger === "input" && pe();
    }, Ce = (g) => {
      me.value = g, pe();
    };
    async function K(g, v) {
      const S = v.key;
      lodash_default_default.set(u, S, g);
      const R2 = e.validateOnChangeSilent;
      if (v.valueChange) {
        const I = v.key, P = u[I], x = O(I), G = v.valueChange instanceof Function ? v.valueChange : v.valueChange.handle, U = T(), le = {
          index: 0,
          row: U.form,
          form: U.form,
          ...U,
          key: I,
          value: P,
          componentRef: x,
          immediate: false,
          getComponentRef: O,
          mode: "search"
        };
        G(le);
      }
      e.validateOnChange && await $(R2, "change") && f(), (v.autoSearchTrigger == null || v.autoSearchTrigger === true || v.autoSearchTrigger === "change") && pe();
    }
    const oe = computed(() => e.validate ? e.options.rules : []);
    return f(), {
      get: h2,
      ui: n,
      onValueChanged: K,
      doValidate: $,
      doSearch: F,
      doReset: M,
      formData: u,
      componentRenderRefs: E,
      getComponentRenderRef: k,
      getComponentRef: O,
      getForm: V,
      getValidatedForm: N,
      setForm: Y,
      searchFormRef: _,
      onInput: Se,
      inputEventDisabled: me,
      changeInputEventDisabled: Ce,
      computedColumns: d2,
      computedButtons: ie,
      computedRules: oe,
      buildFieldContext: D,
      getContextFn: T
    };
  }
});
var zf = { class: "fs-search fs-search-v2" };
var Wf = { class: "fs-search-buttons" };
function xf(e, t, n, o, r, a) {
  const i = resolveComponent("fs-button"), s = resolveComponent("fs-slot-render");
  return openBlock(), createElementBlock("div", zf, [
    (openBlock(), createBlock(resolveDynamicComponent(e.ui.collapseTransition.name), null, {
      default: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent(e.ui.form.name), mergeProps({
          ref: "searchFormRef",
          model: e.formData,
          onsubmit: "event.preventDefault();"
        }, e.options, {
          rules: e.computedRules,
          class: "fs-search-form",
          onCompositionstart: t[0] || (t[0] = (l) => e.changeInputEventDisabled(true)),
          onCompositionend: t[1] || (t[1] = (l) => e.changeInputEventDisabled(false))
        }), {
          default: withCtx(() => {
            var l;
            return [
              e.show !== false ? (openBlock(), createBlock(resolveDynamicComponent(((l = e.container) == null ? void 0 : l.is) || "fs-search-layout-default"), mergeProps({ key: 0 }, e.container, {
                columns: e.computedColumns,
                "get-context-fn": e.getContextFn
              }), createSlots({
                "search-buttons": withCtx(() => [
                  createBaseVNode("div", Wf, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(e.computedButtons, (u, c) => (openBlock(), createElementBlock(Fragment, { key: c }, [
                      u.show !== false ? (openBlock(), createBlock(i, mergeProps({
                        key: 0,
                        ref_for: true
                      }, u, {
                        onClick: (d2) => u._click()
                      }), null, 16, ["onClick"])) : createCommentVNode("", true)
                    ], 64))), 128))
                  ])
                ]),
                _: 2
              }, [
                e.slots["search-left"] ? {
                  name: "search-left",
                  fn: withCtx(() => [
                    createVNode(s, {
                      slots: e.slots["search-left"],
                      scope: e.getContextFn()
                    }, null, 8, ["slots", "scope"])
                  ]),
                  key: "0"
                } : void 0,
                e.slots["search-middle"] ? {
                  name: "search-middle",
                  fn: withCtx(() => [
                    createVNode(s, {
                      slots: e.slots["search-middle"],
                      scope: e.getContextFn()
                    }, null, 8, ["slots", "scope"])
                  ]),
                  key: "1"
                } : void 0,
                e.slots["search-right"] ? {
                  name: "search-right",
                  fn: withCtx(() => [
                    createVNode(s, {
                      slots: e.slots["search-right"],
                      scope: e.getContextFn()
                    }, null, 8, ["slots", "scope"])
                  ]),
                  key: "2"
                } : void 0
              ]), 1040, ["columns", "get-context-fn"])) : createCommentVNode("", true)
            ];
          }),
          _: 1
        }, 16, ["model", "rules"]))
      ]),
      _: 1
    }))
  ]);
}
var Uf = Ee(Hf, [["render", xf]]);
var Kf = defineComponent({
  name: "FsSearchV1",
  components: { FsSearchButtons: pi },
  inheritAttrs: false,
  props: {
    /**
     * 初始查询条件
     * 点击重置，会重置成该条件
     */
    initialForm: {
      type: Object
    },
    /**
     * 表单参数
     * 支持el-form | a-form的属性
     */
    options: {
      type: Object
    },
    /**
     * 查询字段配置
     */
    columns: {
      type: Object
    },
    /**
     * tabs
     * { show , options,key, default}
     */
    tabs: {
      type: Object
    },
    /**
     * 按钮配置,可以根据order排序
     * {search:{...FsButton},reset:{...FsButton}}
     */
    buttons: {
      type: Object
    },
    /**
     * 点击重置后是否立即触发查询
     */
    searchAfterReset: {
      type: Boolean,
      default: true
    },
    /**
     * 是否开启自动查询
     */
    autoSearch: {
      type: Boolean,
      default: true
    },
    /**
     * 自动查询，防抖设置
     * 传false则关闭自动查询
     */
    debounce: {
      type: [Boolean, Object],
      default: void 0
    },
    /**
     * 插槽
     */
    slots: {
      default() {
        return {};
      }
    },
    /**
     * 是否显示查询框
     */
    show: {
      type: Boolean,
      default: true
    },
    /**
     * 是否启用校验
     */
    validate: {
      default: false
    },
    /**
     * 布局, single-line 单行， multi-line 多行（支持展开收起）
     */
    layout: {
      type: String,
      default: "single-line"
    },
    /**
     * 列的宽度设置，span=xx
     */
    col: {},
    /**
     * 是否折叠
     */
    collapse: {
      type: Boolean,
      default: false
    }
  },
  emits: [
    /**
     * 查询事件
     **/
    "search",
    /**
     * 重置事件
     **/
    "reset",
    "collapse",
    "update:collapse"
  ],
  setup(e, t) {
    const { ui: n } = R();
    onMounted(() => {
      if (K.value && Y.value) {
        me.value = Y.value.$el.offsetHeight;
        const g = Y.value.$el.children;
        g && g.length > 1 && (pe.value = g[1].offsetHeight + 2);
      }
    });
    let o = null;
    function r() {
      return lodash_default_default.cloneDeep(e.initialForm || {});
    }
    const a = reactive(r()), { doComputed: i, AsyncComputeValue: s } = It();
    lodash_default_default.each(e.columns, (g) => {
      g.value != null && g.value instanceof s && se.warn("search.value配置不支持AsyncCompute类型的动态计算");
    });
    const { merge: l } = Re(), u = l, c = i(
      () => e.columns,
      _,
      null,
      (g) => {
        e.validate || lodash_default_default.forEach(g, (R2) => {
          delete R2.rules;
        }), e.col && lodash_default_default.forEach(g, (R2) => {
          R2.col = l({}, e.col, R2.col);
        });
        let v = [];
        lodash_default_default.forEach(g, (R2, I) => {
          R2._key = I, v.push(R2);
        }), v = lodash_default_default.sortBy(v, (R2) => R2.order ?? Gt.orderDefault);
        const S = {};
        return v.forEach((R2) => {
          let I = R2._key;
          delete R2._key, S[I] = R2;
        }), S;
      }
    );
    lodash_default_default.forEach(c.value, (g, v) => {
      var R2;
      if (g.value === void 0)
        return;
      const S = unref(g.value);
      S !== void 0 && g.show !== false && ((R2 = g.component) == null ? void 0 : R2.show) !== false && (a[v] = S);
    });
    const d2 = ref(), { t: f } = et(), h2 = ref({});
    function b(g) {
      return h2.value[g];
    }
    function m(g) {
      var v, S;
      return (S = (v = b(g)) == null ? void 0 : v.$refs) == null ? void 0 : S.targetRef;
    }
    function _() {
      return { form: a, validatedForm: a, getComponentRef: m, doValidate: null };
    }
    const y = ref(_());
    async function E() {
      if (o && o.cancel(), await n.form.validateWrap(d2.value))
        t.emit("search", y.value);
      else
        return n.message.error({
          message: f("fs.search.error.message")
        }), false;
    }
    function k() {
      const g = r(), v = lodash_default_default.entries(a);
      for (const S of v) {
        const R2 = lodash_default_default.get(g, S[0]);
        R2 == null ? lodash_default_default.unset(a, S[0]) : lodash_default_default.set(a, S[0], R2);
      }
      e.reset && e.reset(y.value), t.emit("reset", _()), e.searchAfterReset && nextTick(() => {
        E();
      });
    }
    const O = computed(() => {
      const g = [], v = {
        search: {
          show: true,
          type: "primary",
          disabled: false,
          click: (S) => {
            E();
          },
          order: 1,
          text: f("fs.search.search.text")
          // '查询',
        },
        reset: {
          show: true,
          disabled: false,
          click: (S) => {
            k();
          },
          text: f("fs.search.reset.text"),
          // '重置',
          order: 2
        }
      };
      l(v, e.buttons);
      for (let S in v) {
        const R2 = v[S];
        R2._click = () => {
          R2.click(_());
        }, g.push(R2);
      }
      return g.sort((S, R2) => S.order - R2.order), g;
    });
    function T() {
      var g;
      if (e.autoSearch !== false && e.debounce !== false) {
        let v = ((g = e.debounce) == null ? void 0 : g.wait) || 500;
        o = lodash_default_default.debounce(E, v, e.debounce);
      }
    }
    T();
    function D() {
      return a;
    }
    function $(g, v = true) {
      v || lodash_default_default.each(lodash_default_default.keys(a), (S) => {
        delete a[S];
      }), u(a, g);
    }
    const F = ref(false), M = () => {
      se.debug("do auto search,inputEventDisabled:", F.value), F.value !== true && o && o();
    }, ie = (g) => {
      g.autoSearchTrigger === "input" && M();
    }, Q = (g) => {
      F.value = g, M();
    };
    function V(g, v) {
      const S = v.key;
      if (lodash_default_default.set(a, S, g), v.valueChange) {
        const R2 = v.key, I = a[R2], P = m(R2);
        (v.valueChange instanceof Function ? v.valueChange : v.valueChange.handle)({ key: R2, value: I, componentRef: P, ..._(), immidiate: false });
      }
      (v.autoSearchTrigger == null || v.autoSearchTrigger === true || v.autoSearchTrigger === "change") && M();
    }
    const N = computed(() => e.validate ? e.options.rules : []), Y = ref(), me = ref(0), pe = ref(0), Se = () => {
      t.emit("update:collapse", !e.collapse), t.emit("collapse", !e.collapse);
    }, Ce = computed(() => e.layout === "multi-line" ? n.col.name : "div"), K = computed(() => e.layout === "multi-line"), oe = computed(() => K.value ? e.collapse ? pe.value ? pe.value + "px" : "" : me.value ? me.value + "px" : "" : "auto");
    return {
      get: (g, v) => lodash_default_default.get(g, v),
      ui: n,
      onValueChanged: V,
      doSearch: E,
      doReset: k,
      form: a,
      componentRenderRefs: h2,
      getComponentRenderRef: b,
      getComponentRef: m,
      getForm: D,
      setForm: $,
      searchFormRef: d2,
      onInput: ie,
      inputEventDisabled: F,
      changeInputEventDisabled: Q,
      computedColumns: c,
      computedButtons: O,
      computedRules: N,
      columnsRowRef: Y,
      computedColumnBoxHeight: oe,
      computedColName: Ce,
      computedIsMultiLine: K,
      toggleCollapse: Se,
      searchEventContextRef: y
    };
  }
});
var Yf = { class: "fs-search-box" };
var Gf = { class: "fs-search-main" };
var Xf = {
  key: 0,
  class: "fs-search-col"
};
var Qf = {
  key: 1,
  class: "fs-search-col fs-search-middle"
};
var Jf = {
  key: 3,
  class: "fs-search-col fs-search-right"
};
var Zf = {
  key: 0,
  class: "fs-search-action"
};
function eh(e, t, n, o, r, a) {
  const i = resolveComponent("fs-slot-render"), s = resolveComponent("fs-component-render"), l = resolveComponent("fs-search-buttons"), u = resolveComponent("fs-button");
  return openBlock(), createBlock(resolveDynamicComponent(e.ui.collapseTransition.name), null, {
    default: withCtx(() => [
      e.show !== false ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(["fs-search", { "fs-search-multi-line": e.computedIsMultiLine }])
      }, [
        (openBlock(), createBlock(resolveDynamicComponent(e.ui.form.name), mergeProps({
          ref: "searchFormRef",
          model: e.form
        }, e.options, {
          rules: e.computedRules,
          class: "fs-search-form",
          onCompositionstart: t[0] || (t[0] = (c) => e.changeInputEventDisabled(true)),
          onCompositionend: t[1] || (t[1] = (c) => e.changeInputEventDisabled(false))
        }), {
          default: withCtx(() => [
            createBaseVNode("div", Yf, [
              createBaseVNode("div", Gf, [
                createBaseVNode("div", {
                  class: normalizeClass(["fs-search-columns", { "fs-search-collapse": e.collapse }]),
                  style: normalizeStyle({ height: e.computedColumnBoxHeight })
                }, [
                  (openBlock(), createBlock(resolveDynamicComponent(e.ui.row.name), { ref: "columnsRowRef" }, {
                    default: withCtx(() => [
                      e.slots["search-left"] ? (openBlock(), createElementBlock("div", Xf, [
                        (openBlock(), createBlock(resolveDynamicComponent(e.ui.formItem.name), null, {
                          default: withCtx(() => [
                            createVNode(i, {
                              slots: e.slots["search-left"],
                              scope: e.searchEventContextRef
                            }, null, 8, ["slots", "scope"])
                          ]),
                          _: 1
                        }))
                      ])) : createCommentVNode("", true),
                      (openBlock(true), createElementBlock(Fragment, null, renderList(e.computedColumns, (c, d2) => (openBlock(), createElementBlock(Fragment, { key: d2 }, [
                        c.show === true ? (openBlock(), createBlock(resolveDynamicComponent(e.computedColName), mergeProps({
                          key: 0,
                          class: "fs-search-col",
                          ref_for: true
                        }, c.col), {
                          default: withCtx(() => [
                            (openBlock(), createBlock(resolveDynamicComponent(e.ui.formItem.name), mergeProps({ ref_for: true }, c, {
                              [e.ui.formItem.prop || ""]: d2,
                              label: c.title
                            }), {
                              default: withCtx(() => [
                                e.slots["search_" + d2] ? (openBlock(), createBlock(i, {
                                  key: 0,
                                  slots: e.slots["search_" + d2],
                                  scope: { ...e.searchEventContextRef, key: d2 }
                                }, null, 8, ["slots", "scope"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                                  c.component && c.component.show !== false ? (openBlock(), createBlock(s, mergeProps({
                                    key: 0,
                                    ref_for: true,
                                    ref: (f) => {
                                      f && (e.componentRenderRefs[c.key] = f);
                                    },
                                    "model-value": e.get(e.form, d2)
                                  }, c.component, {
                                    scope: e.searchEventContextRef,
                                    "onUpdate:modelValue": (f) => e.onValueChanged(f, c),
                                    onInput: (f) => e.onInput(c)
                                  }), null, 16, ["model-value", "scope", "onUpdate:modelValue", "onInput"])) : createCommentVNode("", true)
                                ], 64))
                              ]),
                              _: 2
                            }, 1040, ["label"]))
                          ]),
                          _: 2
                        }, 1040)) : createCommentVNode("", true)
                      ], 64))), 128)),
                      e.slots["search-middle"] ? (openBlock(), createElementBlock("div", Qf, [
                        (openBlock(), createBlock(resolveDynamicComponent(e.ui.formItem.name), null, {
                          default: withCtx(() => [
                            createVNode(i, {
                              slots: e.slots["search-middle"],
                              scope: e.searchEventContextRef
                            }, null, 8, ["slots", "scope"])
                          ]),
                          _: 1
                        }))
                      ])) : createCommentVNode("", true),
                      e.computedIsMultiLine ? createCommentVNode("", true) : (openBlock(), createBlock(l, {
                        key: 2,
                        buttons: e.computedButtons
                      }, null, 8, ["buttons"])),
                      e.slots["search-right"] ? (openBlock(), createElementBlock("div", Jf, [
                        (openBlock(), createBlock(resolveDynamicComponent(e.ui.formItem.name), null, {
                          default: withCtx(() => [
                            createVNode(i, {
                              slots: e.slots["search-right"],
                              scope: e.searchEventContextRef
                            }, null, 8, ["slots", "scope"])
                          ]),
                          _: 1
                        }))
                      ])) : createCommentVNode("", true)
                    ]),
                    _: 1
                  }, 512))
                ], 6),
                e.computedIsMultiLine ? (openBlock(), createBlock(l, {
                  key: 0,
                  buttons: e.computedButtons
                }, null, 8, ["buttons"])) : createCommentVNode("", true)
              ]),
              e.computedIsMultiLine ? (openBlock(), createElementBlock("div", Zf, [
                (openBlock(), createBlock(resolveDynamicComponent(e.ui.formItem.name), null, {
                  default: withCtx(() => [
                    createVNode(u, {
                      icon: e.collapse ? e.ui.icons.caretUp : e.ui.icons.caretDown,
                      onClick: e.toggleCollapse
                    }, null, 8, ["icon", "onClick"])
                  ]),
                  _: 1
                }))
              ])) : createCommentVNode("", true)
            ])
          ]),
          _: 1
        }, 16, ["model", "rules"]))
      ], 2)) : createCommentVNode("", true)
    ]),
    _: 1
  });
}
var th = Ee(Kf, [["render", eh]]);
var nh = defineComponent({
  name: "FsSearchLayoutDefault",
  props: {
    /**
     * 是否收缩
     */
    collapse: {
      type: Boolean,
      default: true
    },
    /**
     * 展开按钮
     */
    collapseButton: {
      type: Object
    },
    action: {
      type: Object
    },
    /**
     * 布局模式
     */
    layout: {
      type: String,
      default: "single-line"
    },
    /**
     * 查询字段列表，可以精细化自定义查询字段布局
     */
    columns: {
      type: Object
    },
    /**
     * 默认的col配置
     */
    col: {
      type: Object
    },
    /**
     * 获取查询上下文
     */
    getContextFn: {
      type: Function
    }
  },
  emits: ["update:collapse", "collapse"],
  setup(e, t) {
    const { ui: n } = R(), { t: o } = et(), r = ref(), a = computed(() => e.layout === "multi-line");
    onMounted(() => {
      a.value && r.value && (s.value = r.value.$el.offsetHeight);
    });
    const i = computed(() => !a.value || !e.collapse ? "auto" : s.value ? s.value + "px" : ""), s = ref(0), l = () => {
      t.emit("update:collapse", !e.collapse), t.emit("collapse", !e.collapse);
    };
    function u(c) {
      return lodash_default_default.merge({}, e.col, c);
    }
    return {
      ui: n,
      columnsRowRef: r,
      computedColumnBoxHeight: i,
      computedIsMultiLine: a,
      toggleCollapse: l,
      mergeCol: u,
      t: o
    };
  }
});
var oh = { class: "fs-search-box" };
var rh = { class: "fs-search-col fs-search-slot" };
var ah = { class: "fs-search-col fs-search-slot" };
var ih = { class: "fs-search-col fs-search-slot" };
var sh = {
  key: 0,
  class: "fs-search-buttons-group fs-search-multi-line-buttons"
};
function lh(e, t, n, o, r, a) {
  var l;
  const i = resolveComponent("fs-render"), s = resolveComponent("fs-button");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["fs-search-layout-default", { "fs-search-multi-line": e.computedIsMultiLine }])
  }, [
    createBaseVNode("div", oh, [
      createBaseVNode("div", {
        class: normalizeClass(["fs-search-main", { "fs-search-collapse": e.collapse }]),
        style: normalizeStyle({ maxHeight: e.computedColumnBoxHeight })
      }, [
        (openBlock(), createBlock(resolveDynamicComponent(e.ui.row.name), {
          ref: "columnsRowRef",
          class: "fs-search-columns"
        }, {
          default: withCtx(() => {
            var u;
            return [
              createBaseVNode("span", rh, [
                renderSlot(e.$slots, "search-left")
              ]),
              (openBlock(true), createElementBlock(Fragment, null, renderList(e.columns, (c, d2) => (openBlock(), createElementBlock(Fragment, { key: d2 }, [
                c.show ? (openBlock(), createBlock(resolveDynamicComponent(e.ui.col.name), mergeProps({
                  key: 0,
                  class: "fs-search-col",
                  ref_for: true
                }, e.mergeCol(c.col)), {
                  default: withCtx(() => [
                    createVNode(i, {
                      "render-func": c._cellRender,
                      scope: e.getContextFn()
                    }, null, 8, ["render-func", "scope"])
                  ]),
                  _: 2
                }, 1040)) : createCommentVNode("", true)
              ], 64))), 128)),
              createBaseVNode("span", ah, [
                renderSlot(e.$slots, "search-middle")
              ]),
              e.computedIsMultiLine ? createCommentVNode("", true) : (openBlock(), createBlock(resolveDynamicComponent(e.ui.col.name), mergeProps({
                key: 0,
                class: "fs-search-col fs-search-buttons-group"
              }, e.mergeCol((u = e.action) == null ? void 0 : u.col)), {
                default: withCtx(() => {
                  var c;
                  return [
                    (openBlock(), createBlock(resolveDynamicComponent(e.ui.formItem.name), normalizeProps({
                      [e.ui.formItem.label || ""]: (c = e.action) == null ? void 0 : c.label
                    }), {
                      default: withCtx(() => [
                        renderSlot(e.$slots, "search-buttons", normalizeProps(guardReactiveProps(e.getContextFn())))
                      ]),
                      _: 3
                    }, 16))
                  ];
                }),
                _: 3
              }, 16)),
              createBaseVNode("span", ih, [
                renderSlot(e.$slots, "search-right", normalizeProps(guardReactiveProps(e.getContextFn())))
              ])
            ];
          }),
          _: 3
        }, 512))
      ], 6),
      e.computedIsMultiLine ? (openBlock(), createElementBlock("div", sh, [
        renderSlot(e.$slots, "search-buttons"),
        ((l = e.collapseButton) == null ? void 0 : l.show) !== false ? (openBlock(), createBlock(s, mergeProps({
          key: 0,
          icon: e.collapse ? e.ui.icons.caretUp : e.ui.icons.caretDown,
          text: e.collapse ? e.t("fs.search.container.collapseButton.text.expand") : e.t("fs.search.container.collapseButton.text.collapse")
        }, e.collapseButton, { onClick: e.toggleCollapse }), null, 16, ["icon", "text", "onClick"])) : createCommentVNode("", true)
      ])) : createCommentVNode("", true)
    ])
  ], 2);
}
var uh = Ee(nh, [["render", lh]]);
var ch = { class: "fs-tabs-filter" };
var dh = defineComponent({
  name: "FsTabsFilter",
  inheritAttrs: false
});
var fh = defineComponent({
  ...dh,
  props: {
    name: {},
    show: { type: Boolean, default: false },
    defaultOption: { default: void 0 },
    options: { default: () => [] },
    modelValue: {},
    value: { default: "value" },
    label: { default: "label" }
  },
  emits: ["update:modelValue", "change"],
  setup(e, { emit: t }) {
    const n = useAttrs(), { merge: o } = Re(), r = e, a = computed(() => o({
      show: true,
      value: null,
      label: "全部"
    }, r.defaultOption || {})), i = "_default_key_", s = computed(() => {
      const h2 = r.modelValue == null || r.modelValue === a.value.value ? i : r.modelValue;
      return {
        type: "card",
        ...n,
        [f.tabs.modelValue]: h2,
        ["onUpdate:" + f.tabs.modelValue]: u
      };
    }), l = t;
    function u(h2) {
      i === h2 && (h2 = a.value.value);
      const b = r.modelValue;
      l("update:modelValue", h2), b !== h2 && l("change", h2);
    }
    function c(h2) {
      return h2[r.value];
    }
    function d2(h2) {
      return h2[r.label];
    }
    const { ui: f } = R();
    return (h2, b) => (openBlock(), createElementBlock("div", ch, [
      (openBlock(), createBlock(resolveDynamicComponent(unref(f).tabs.name), normalizeProps(guardReactiveProps(s.value)), {
        default: withCtx(() => [
          a.value.show ? (openBlock(), createBlock(resolveDynamicComponent(unref(f).tabPane.name), normalizeProps({
            key: 0,
            [unref(f).tabPane.key || ""]: i,
            [unref(f).tabPane.tab || ""]: a.value.label
          }), null, 16)) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(h2.options, (m, _) => (openBlock(), createBlock(resolveDynamicComponent(unref(f).tabPane.name), normalizeProps({
            key: _,
            [unref(f).tabPane.key || ""]: c(m),
            [unref(f).tabPane.tab || ""]: d2(m)
          }), null, 16))), 128))
        ]),
        _: 1
      }, 16))
    ]));
  }
});
var hh = defineComponent({
  name: "FsDictRadio",
  props: {
    /**
     * 数据字典配置
     */
    dict: {},
    /**
     * 可选项，比dict.data优先级高
     */
    options: { type: Array },
    /**
     * radio组件名称
     * antdv使用button样式的时候有用
     * 即将废弃,请使用optionName
     */
    radioName: {},
    /**
     * 选项的组件名称
     */
    optionName: {
      type: String
    },
    /**
     * 选项的属性
     */
    optionProps: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * 转换DictData
     */
    transformDictData: {
      type: Function,
      default: void 0
    }
  },
  emits: [
    /**
     * 字典数据变化事件
     */
    "dict-change",
    /**
     * 选中值变化事件，可以获取到当前选中的option对象
     */
    "selected-change",
    /**
     * 值变化事件
     */
    "change"
  ],
  setup(e, t) {
    const { ui: n } = R();
    e.radioName && console.warn("参数radioName即将废弃，请改成optionName");
    const o = computed(() => e.optionName ?? e.radioName ?? n.radio.name);
    let r = Xt(e, t, n.radioGroup.modelValue);
    const a = r.createComputedOptions();
    return {
      ui: n,
      computedRadioName: o,
      ...r,
      computedOptions: a,
      onSelectedChange: (s) => {
        t.emit("change", s), s && s.target && (s = s.target.value);
        const l = r.getDict();
        if (l && l.dataMap && l.dataMap[s]) {
          const u = l.dataMap[s];
          t.emit("selected-change", u);
        } else
          t.emit("selected-change", null);
      }
    };
  }
});
function mh(e, t, n, o, r, a) {
  return openBlock(), createBlock(resolveDynamicComponent(e.ui.radioGroup.name), { onChange: e.onSelectedChange }, {
    default: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList(e.computedOptions, (i) => (openBlock(), createBlock(resolveDynamicComponent(e.computedRadioName), mergeProps({
        ref_for: true,
        ref: "radioRef",
        key: e.getValue(i),
        [e.ui.radio.value || ""]: e.getValue(i)
      }, e.optionProps), {
        default: withCtx(() => [
          createTextVNode(toDisplayString(e.getLabel(i)), 1)
        ]),
        _: 2
      }, 1040))), 128))
    ]),
    _: 1
  }, 40, ["onChange"]);
}
var ph = Ee(hh, [["render", mh]]);
var gh = defineComponent({
  name: "FsDictSelect",
  props: {
    /**
     * 字典
     */
    dict: {},
    /**
     * 可选项，比dict.data优先级高
     */
    options: {
      type: Array
    },
    /**
     * placeholder
     */
    placeholder: {
      type: String
    },
    /**
     * select组件的插槽
     */
    slots: {},
    /**
     * 自定义label的render方法
     */
    renderLabel: {
      type: Function
    },
    /**
     * 转换DictData
     */
    transformDictData: {
      type: Function,
      default: void 0
    }
  },
  emits: [
    /**
     * 字典项变化
     */
    "dict-change",
    /**
     * 选中值变化事件，可以获取到当前选中的option对象
     */
    "selected-change",
    /**
     * 值变化事件
     */
    "change"
  ],
  setup(e, t) {
    const {
      t: n
    } = et(), o = computed(() => e.placeholder || n("fs.component.select.placeholder")), {
      ui: r
    } = R(), a = Xt(e, t, r.select.modelValue), i = a.createComputedOptions();
    return {
      computedPlaceholder: o,
      ...a,
      computedOptions: i,
      onSelectedChange: (l) => {
        t.emit("change", l);
        const u = a.getDict();
        if (l && Array.isArray(l) && l.length > 0) {
          const c = [];
          for (const d2 of l)
            u && u.dataMap && u.dataMap[d2] && c.push(u.dataMap[d2]);
          t.emit("selected-change", c);
          return;
        }
        if (u && u.dataMap && u.dataMap[l]) {
          const c = u.dataMap[l];
          t.emit("selected-change", c);
        } else
          t.emit("selected-change", null);
      }
    };
  },
  render() {
    const {
      ui: e
    } = R(), t = resolveDynamicComponent(e.select.name), n = e.select.modelValue;
    if (e.option.name == null) {
      const i = this.computedOptions || [], s = {
        [`onUpdate:${n}`]: (l) => {
          this.$emit(`onUpdate:${n}`, l), this.onSelectedChange(l);
        }
      };
      return createVNode(t, mergeProps({
        ref: "selectRef",
        placeholder: this.computedPlaceholder,
        options: i,
        renderLabel: this.renderLabel
      }, s), null);
    }
    const o = [], r = resolveDynamicComponent(e.option.name), a = this.computedOptions || [];
    for (const i of a) {
      const s = createVNode(r, mergeProps(i, {
        value: this.getValue(i),
        label: this.getLabel(i)
      }), {
        default: () => [this.renderLabel ? this.renderLabel(i) : this.getLabel(i)]
      });
      o.push(s);
    }
    return createVNode(t, {
      ref: "selectRef",
      placeholder: this.computedPlaceholder,
      onChange: this.onSelectedChange
    }, {
      default: () => [o],
      ...this.slots
    });
  }
});
function vh(e) {
  if (e == null)
    return 0;
  typeof e != "string" && (e = JSON.stringify(e));
  let t = 0, n, o, r;
  if (e.length === 0)
    return t;
  for (n = 0, r = e.length; n < r; n++)
    o = e.charCodeAt(n), t = (t << 5) - t + o, t |= 0;
  return t;
}
function bh(e) {
  let t = [];
  return typeof e.modelValue == "string" && e.multiple && e.separator != null && e.separator !== "" ? t = e.modelValue.split(e.separator) : e.modelValue instanceof Array ? t = e.modelValue : t = [e.modelValue], t;
}
var yh = defineComponent({
  name: "FsValuesFormat",
  props: {
    /**
     * 值
     */
    modelValue: {},
    /**
     * 字典配置
     */
    dict: {},
    /**
     * 是否多选
     */
    multiple: { default: true },
    /**
     * 分隔符<br/>
     * 多选时，如果value为string，则以该分隔符分割成多个展示<br/>
     * 传入空字符串，表示不分割<br/>
     */
    separator: { default: "," },
    /**
     * 颜色
     * element=【auto, primary, success, warning, danger ,info】
     * antdv=【auto, primary, success, blue,red,...】
     * 配置auto，则自动根据value值hashcode分配颜色值
     */
    color: {},
    /**
     * 效果（仅element）
     **/
    effect: {},
    /**
     * 自动染色颜色值列表
     */
    autoColors: {
      type: Array
    },
    /**
     * 自动主题列表（仅element）
     * 【 light, plain 】
     */
    autoEffects: {
      type: Array
    },
    /**
     * 显示类型：【text, tag】
     */
    type: {
      default: "tag"
    },
    /**
     * 值的类型，【 value | object】
     */
    valueType: {
      type: String
    },
    /**
     * 当value值不在字典中时默认显示的文本
     */
    defaultLabel: {},
    /**
     * label自定义render
     */
    labelFormatter: {
      type: Function
    },
    /**
     * 自定义选项render
     */
    itemRender: {
      type: Function
    },
    closable: {
      type: Boolean,
      default: false
    }
  },
  emits: ["click", "dict-change", "close", "update:modelValue"],
  setup(e, t) {
    const { ui: n } = R(), o = n.tag.colors, r = ["plain", "light"], a = Xt(e, t), { getColor: i, getValue: s, removePropValue: l } = a;
    a.watchValue();
    function u(h2, b) {
      !b.effect && h2.effect && (b.effect = h2.effect);
      const m = n.tag.type, _ = i(b);
      if (_ != null) {
        if (typeof _ != "string")
          return;
        l(b, "color"), b[m] = _;
        return;
      }
      if (h2.color === "auto") {
        const y = vh(s(b)), E = h2.autoColors ? h2.autoColors : o;
        b[m] = E[y % E.length];
        const k = h2.autoEffects ? h2.autoEffects : r;
        b.effect = k[Math.floor(y / E.length) % k.length];
      } else
        b[m] = h2.color;
    }
    const c = computed(() => {
      var k, O;
      if (e.valueType === "object")
        return e.modelValue && !Array.isArray(e.modelValue) ? [e.modelValue] : e.modelValue;
      const h2 = a.getDict();
      if (e.modelValue == null || e.modelValue === "")
        return [];
      const b = bh(e);
      let m = [];
      const _ = ((k = e.dict) == null ? void 0 : k.value) || "value", y = ((O = e.dict) == null ? void 0 : O.label) || "label";
      h2 ? (m = h2.getNodesFromDataMap(b), lodash_default_default.forEach(m, (T) => {
        T[y] == null && (T[y] = e.defaultLabel || T[_]);
      })) : (m = [], lodash_default_default.forEach(b, (T) => {
        T instanceof Object ? m.push(T) : m.push({
          [_]: T,
          [y]: T
        });
      }));
      const E = [];
      return lodash_default_default.forEach(m, (T) => {
        E.push(lodash_default_default.omit(T, "children"));
      }), lodash_default_default.forEach(E, (T) => {
        u(e, T);
      }), E;
    });
    function d2(h2) {
      t.emit("click", { item: h2 });
    }
    function f(h2, b) {
      t.emit("close", { item: b, index: h2 });
      const m = [];
      for (let _ = 0; _ < c.value.length; _++)
        _ !== h2 && m.push(s(c.value[_]));
      t.emit("update:modelValue", m);
    }
    return {
      ui: n,
      ...a,
      doClick: d2,
      computedValueItems: c,
      doClose: f
    };
  }
});
var wh = { class: "fs-values-format" };
var _h = ["onClick"];
function Ch(e, t, n, o, r, a) {
  const i = resolveComponent("fs-render"), s = resolveComponent("fs-icon");
  return openBlock(), createElementBlock("span", wh, [
    e.itemRender ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(e.computedValueItems, (l) => (openBlock(), createBlock(i, {
      key: e.getValue(l),
      "render-func": e.itemRender,
      scope: l
    }, null, 8, ["render-func", "scope"]))), 128)) : e.type === "text" ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(e.computedValueItems, (l) => (openBlock(), createElementBlock("span", {
      key: e.getValue(l),
      onClick: (u) => e.doClick(l)
    }, toDisplayString(e.getLabel(l)), 9, _h))), 128)) : (openBlock(true), createElementBlock(Fragment, { key: 2 }, renderList(e.computedValueItems, (l, u) => (openBlock(), createBlock(resolveDynamicComponent(e.ui.tag.name), mergeProps({
      key: e.getValue(l),
      class: "fs-tag",
      size: "small",
      closable: e.closable,
      ref_for: true
    }, l, {
      icon: null,
      name: null,
      onClose: (c) => e.doClose(u, l),
      onClick: (c) => e.doClick(l)
    }), {
      default: withCtx(() => [
        l.icon ? (openBlock(), createBlock(s, {
          key: 0,
          icon: l.icon,
          spin: l.iconSpin,
          class: "fs-tag-icon"
        }, null, 8, ["icon", "spin"])) : createCommentVNode("", true),
        createTextVNode(" " + toDisplayString(e.getLabel(l)), 1)
      ]),
      _: 2
    }, 1040, ["closable", "onClose", "onClick"]))), 128))
  ]);
}
var Sh = Ee(yh, [["render", Ch]]);
var Fh = defineComponent({
  name: "FsDictCascaderFormat",
  props: {
    /**
     *   值<br/>
     *   单选时 '1,2,3' 或 [1,2,3]<br/>
     *   多选[[1,2,3],[4,5,6]]<br/>
     */
    // @ts-ignore
    modelValue: {
      type: [String, Array],
      default: void 0,
      require: true
    },
    /**
     *  value的分隔符<br/>
     *  多选时，如果value为string，则以该分隔符分割成多个展示<br/>
     *  传入空字符串，表示不分割<br/>
     */
    // @ts-ignore
    separator: { type: String, default: ",", require: false },
    /**
     * 是否多选
     */
    // @ts-ignore
    multiple: { type: Boolean, default: false },
    /**
     * 数据字典
     */
    dict: {
      type: Object,
      default: void 0,
      require: false
    }
  },
  emits: ["dict-change"],
  setup(e, t) {
    var r;
    const n = Xt(e, t);
    (r = e.dict) != null && r.getNodesByValues && n.watchValue();
    const o = computed(() => e.multiple);
    return {
      ...n,
      computedMultiple: o
    };
  },
  data() {
    return {};
  },
  computed: {
    labels() {
      return this.modelValue == null ? [] : this.buildValueItem(this.modelValue);
    },
    multipleLabels() {
      if (this.modelValue == null)
        return [];
      const e = [];
      for (const t of this.modelValue)
        e.push(this.buildValueItem(t));
      return e;
    }
  },
  methods: {
    getValueArr(e) {
      if (e == null)
        if (this.multiple) {
          e = [];
          for (const n of this.modelValue)
            for (const o of n)
              e.push(o);
        } else
          e = this.modelValue;
      if (e == null)
        return [];
      let t = null;
      return typeof e == "string" && !this.multiple && this.separator != null && this.separator !== "" ? t = e.split(this.separator) : e instanceof Array ? t = e : t = [e], t;
    },
    buildValueItem(e) {
      const t = this.getValueArr(e), n = this.getDict();
      if (n)
        return n.getNodesFromDataMap(t);
    }
  }
});
var Rh = { key: 0 };
var Eh = { key: 0 };
function Dh(e, t, n, o, r, a) {
  return openBlock(), createElementBlock("span", null, [
    e.computedMultiple ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(e.multipleLabels, (i, s) => (openBlock(), createElementBlock("div", { key: s }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(i, (l, u) => (openBlock(), createElementBlock("span", { key: u }, [
        u !== 0 ? (openBlock(), createElementBlock("span", Rh, " / ")) : createCommentVNode("", true),
        createBaseVNode("span", null, toDisplayString(e.getLabel(l)), 1)
      ]))), 128))
    ]))), 128)) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(e.labels, (i, s) => (openBlock(), createElementBlock("span", { key: s }, [
      s !== 0 ? (openBlock(), createElementBlock("span", Eh, " / ")) : createCommentVNode("", true),
      createBaseVNode("span", null, toDisplayString(e.getLabel(i)), 1)
    ]))), 128))
  ]);
}
var kh = Ee(Fh, [["render", Dh]]);
var Oh = defineComponent({
  name: "FsDictCascader",
  props: {
    /**
     * 字典配置
     */
    dict: {},
    /**
     * 选项，比dict.data优先级高
     */
    options: { type: Array },
    /**
     * 转换DictData
     */
    transformDictData: {
      type: Function,
      default: void 0
    }
  },
  emits: [
    /**
     * 字典数据变化事件
     */
    "dict-change",
    /**
     * 选中值变化事件，可以获取到当前选中的option对象
     */
    "selected-change",
    /**
     * 值变化事件
     */
    "change"
  ],
  setup(e, t) {
    const n = Xt(e, t), { ui: o } = R(), r = ref();
    e.dict && (r.value = o.cascader.fieldNames({
      // @ts-ignore
      value: e.dict.value,
      // @ts-ignore
      label: e.dict.label,
      // @ts-ignore
      children: e.dict.children
    }));
    const a = n.createComputedOptions();
    function i(s) {
      if (t.emit("change", s), s) {
        let l = [];
        const u = n.getDict();
        if (u && u.dataMap) {
          for (let c of s) {
            const d2 = u.dataMap[c];
            d2 && l.push(d2);
          }
          t.emit("selected-change", l);
        }
      } else
        t.emit("selected-change", null);
    }
    return {
      ui: o,
      ...n,
      fieldNamesBinder: r,
      computedOptions: a,
      onSelectChange: i
    };
  }
});
function $h(e, t, n, o, r, a) {
  return openBlock(), createBlock(resolveDynamicComponent(e.ui.cascader.name), mergeProps({
    ref: "cascaderRef",
    options: e.computedOptions
  }, e.fieldNamesBinder, { onChange: e.onSelectChange }), null, 16, ["options", "onChange"]);
}
var Th = Ee(Oh, [["render", $h]]);
var Ah = defineComponent({
  name: "FsDictCheckbox",
  props: {
    /**
     * 字典
     */
    dict: {},
    /**
     * 选项，比dict.data优先级高
     */
    options: { type: Array, default: void 0, require: false },
    /**
     * 选项的组件名称
     */
    optionName: {
      type: String
    },
    /**
     * 选项的属性
     */
    optionProps: {
      type: Object,
      default() {
        return {};
      }
    },
    /**
     * 转换DictData
     */
    transformDictData: {
      type: Function,
      default: void 0
    }
  },
  emits: [
    /**
     * 字典数据变化事件
     */
    "dict-change",
    /**
     * 选中值变化事件，可以获取到当前选中的option对象
     */
    "selected-change",
    /**
     * 值变化事件
     */
    "change"
  ],
  setup(e, t) {
    const { ui: n } = R();
    let o = Xt(e, t, n.checkboxGroup.modelValue);
    const r = o.createComputedOptions();
    return {
      ui: n,
      ...o,
      computedOptions: r,
      onSelectedChange: (i) => {
        if (t.emit("change", i), i) {
          let s = [];
          const l = o.getDict();
          if (l && l.dataMap) {
            for (let u of i) {
              const c = l.dataMap[u];
              c && s.push(c);
            }
            t.emit("selected-change", s);
          }
        } else
          t.emit("selected-change", null);
      }
    };
  }
});
function Ih(e, t, n, o, r, a) {
  return openBlock(), createBlock(resolveDynamicComponent(e.ui.checkboxGroup.name), { onChange: e.onSelectedChange }, {
    default: withCtx(() => [
      (openBlock(true), createElementBlock(Fragment, null, renderList(e.computedOptions, (i) => (openBlock(), createBlock(resolveDynamicComponent(e.optionName || e.ui.checkbox.name), mergeProps({
        ref_for: true,
        ref: "checkboxRef",
        key: e.getValue(i),
        [e.ui.checkbox.value || ""]: e.getValue(i)
      }, e.optionProps), {
        default: withCtx(() => [
          createTextVNode(toDisplayString(e.getLabel(i)), 1)
        ]),
        _: 2
      }, 1040))), 128))
    ]),
    _: 1
  }, 40, ["onChange"]);
}
var Vh = Ee(Ah, [["render", Ih]]);
var Ph = defineComponent({
  name: "FsDictSwitch",
  props: {
    /**
     * 字典第一个为开启
     * 第二个为关闭
     */
    dict: {
      type: Object
    },
    options: {},
    /**
     * 转换DictData
     */
    transformDictData: {
      type: Function,
      default: void 0
    }
  },
  emits: ["dict-change"],
  setup(e, t) {
    const { ui: n } = R();
    let o = Xt(e, t, n.switch.modelValue);
    const r = o.createComputedOptions();
    return {
      ui: n,
      ...o,
      computedOptions: r
    };
  },
  computed: {
    _active() {
      return this.computedOptions.length > 0 ? this.computedOptions[0] : {};
    },
    _inActive() {
      return this.computedOptions.length > 1 ? this.computedOptions[1] : {};
    },
    binding() {
      var t, n, o, r, a, i;
      const e = d.get();
      return {
        // @ts-ignore
        [e.switch.activeText]: this._active[((t = this.dict) == null ? void 0 : t.label) || "label"],
        // @ts-ignore
        [e.switch.inactiveText]: this._inActive[((n = this.dict) == null ? void 0 : n.label) || "label"],
        // @ts-ignore
        [e.switch.activeColor]: this._active[((o = this.dict) == null ? void 0 : o.color) || "color"],
        // @ts-ignore
        [e.switch.inactiveColor]: this._inActive[((r = this.dict) == null ? void 0 : r.color) || "color"],
        // @ts-ignore
        [e.switch.activeValue]: this._active[((a = this.dict) == null ? void 0 : a.value) || "value"],
        // @ts-ignore
        [e.switch.inactiveValue]: this._inActive[((i = this.dict) == null ? void 0 : i.value) || "value"]
      };
    }
  }
});
function Mh(e, t, n, o, r, a) {
  return openBlock(), createBlock(resolveDynamicComponent(e.ui.switch.name), mergeProps({ ref: "switchRef" }, e.binding), null, 16);
}
var Bh = Ee(Ph, [["render", Mh]]);
var jh = defineComponent({
  name: "FsDateFormat",
  props: {
    /**
     * 日期时间值，支持long,string,date等，由dayjs转化
     */
    modelValue: { required: false },
    /**
     *  输入格式化，不传则由dayjs自动转化
     */
    valueFormat: { type: String, default: void 0, required: false },
    /**
     *  输出格式化
     */
    format: { type: String, default: "YYYY-MM-DD HH:mm:ss", required: false }
  },
  data() {
    return {
      item: {}
    };
  },
  computed: {
    doFormat() {
      if (this.modelValue == null || this.modelValue === "")
        return "";
      let e = null;
      return this.valueFormat != null ? e = (0, import_dayjs.default)(this.modelValue, this.valueFormat) : e = (0, import_dayjs.default)(this.modelValue), e.format(this.format);
    }
  },
  created() {
  },
  methods: {}
});
function Nh(e, t, n, o, r, a) {
  return openBlock(), createElementBlock("span", null, toDisplayString(e.doFormat), 1);
}
var Lh = Ee(jh, [["render", Nh]]);
var qh = defineComponent({
  name: "FsDictTree",
  components: {},
  props: {
    /**
     * 数据字典
     */
    dict: {},
    /**
     * 可选项，比dict.data优先级高
     */
    options: { type: Array },
    /**
     * placeholder
     */
    placeholder: { type: String },
    /**
     * 转换DictData
     */
    transformDictData: {
      type: Function,
      default: void 0
    }
  },
  emits: [
    /**
     * 字典数据变化事件
     */
    "dict-change",
    /**
     * 选中值变化事件，可以获取到当前选中的option对象
     */
    "selected-change",
    /**
     * 值变化事件
     */
    "change"
  ],
  // render () {
  //   return this.renderFunc({ data: this.data, dataMap: this.dataMap, scope: this.scope, attrs: this.$attrs })
  // },
  setup(e, t) {
    const { t: n } = et(), { ui: o } = R(), r = computed(() => e.placeholder || n("fs.component.select.placeholder"));
    let a = Xt(e, t);
    const i = t.slots, s = a.createComputedOptions(), l = computed(() => {
      const d2 = a.getDict();
      return o.treeSelect.buildOptionKeysNameBinding({
        label: d2.label,
        value: d2.value,
        children: d2.children
      });
    }), u = (d2) => {
      if (t.emit("change", d2), d2) {
        const f = a.getDict();
        if (f && f.dataMap)
          if (d2 instanceof Array) {
            let h2 = [];
            for (let b of d2) {
              const m = f.dataMap[b];
              m && h2.push(m);
            }
            t.emit("selected-change", h2);
          } else
            t.emit("selected-change", f.dataMap[d2]);
      } else
        t.emit("selected-change", null);
    }, c = ref();
    return {
      ui: o,
      computedBinding: l,
      computedPlaceholder: r,
      ...a,
      computedOptions: s,
      onSelectedChange: u,
      slots: i,
      treeRef: c
    };
  }
});
function Hh(e, t, n, o, r, a) {
  const i = resolveComponent("fs-slot-render");
  return openBlock(), createBlock(resolveDynamicComponent(e.ui.treeSelect.name), mergeProps({
    ref: "treeRef",
    [e.ui.treeSelect.options || ""]: e.computedOptions,
    placeholder: e.computedPlaceholder
  }, e.computedBinding, { onChange: e.onSelectedChange }), createSlots({ _: 2 }, [
    renderList(e.slots, (s, l) => ({
      name: l,
      fn: withCtx((u) => [
        createVNode(i, {
          slots: s,
          scope: u
        }, null, 8, ["slots", "scope"])
      ])
    }))
  ]), 1040, ["placeholder", "onChange"]);
}
var zh = Ee(qh, [["render", Hh]]);
var Wh = {
  class: "fs-table-select"
};
var xh = {
  key: 0,
  class: "fs-table-select-current"
};
var Uh = defineComponent({
  __name: "fs-table-select",
  props: {
    modelValue: {},
    createCrudOptions: {},
    crudOptionsOverride: {
      default: void 0
    },
    beforeOpen: {},
    dict: {},
    select: {
      default: void 0
    },
    showSelect: {
      type: Boolean,
      default: true
    },
    dialog: {
      default: void 0
    },
    showCurrent: {
      type: Boolean,
      default: true
    },
    valuesFormat: {
      default: void 0
    },
    height: {
      default: void 0
    },
    multiple: {
      type: Boolean
    },
    crossPage: {
      type: Boolean,
      default: true
    },
    rowKey: {
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    valueType: {
      default: "value"
    },
    viewMode: {
      type: Boolean,
      default: false
    },
    destroyOnClose: {
      type: Boolean,
      default: true
    }
  },
  emits: [
    "change",
    "update:modelValue",
    /* 选中行变化事件 */
    "selected-change",
    /*对话框即将关闭*/
    "dialog-close",
    /*对话框已关闭*/
    "dialog-closed"
  ],
  setup(e, {
    expose: t,
    emit: n
  }) {
    const o = e, r = useSlots(), a = n, {
      ui: i
    } = R(), {
      t: s
    } = et(), l = ref(), u = ref(), c = ref(false), {
      crudRef: d2,
      crudBinding: f,
      context: h2
    } = Il();
    function b(V) {
      V == null || Array.isArray(V) && V.length == 0 ? O.value = [] : (o.multiple ? O.value = V || [] : O.value = [V], o.valueType === "object" && (O.value = O.value.map((N) => o.dict.getValue(N))));
    }
    const {
      crudExpose: m
    } = Or({
      crudRef: d2,
      crudBinding: f
    }), _ = async (V) => {
      var Y, me;
      if (o.disabled || o.readonly || (Y = o.select) != null && Y.disabled || (me = o.select) != null && me.readonly)
        return;
      if (o.dict == null)
        throw new Error("必须配置dict，且必须配置dict.getNodesByValues");
      const N = await Al({
        crudBinding: f,
        crudRef: d2,
        createCrudOptions: o.createCrudOptions,
        crudOptionsOverride: $(),
        context: h2,
        crudExpose: m
      });
      return c.value = true, b(o.modelValue), o.beforeOpen && await o.beforeOpen({
        crudOptions: V.crudOptions,
        ...ie()
      }), V && N.appendCrudOptions(V.crudOptions), await nextTick(), await m.doRefresh(), N;
    }, y = computed(() => ({
      ...o.valuesFormat
    })), E = computed(() => {
      const V = `onUpdate:${i.select.modelValue}`;
      let N = o.modelValue;
      return o.valueType === "object" && o.modelValue && (o.multiple ? N = o.modelValue.map((Y) => o.dict.getValue(Y)) : N = o.dict.getValue(o.modelValue)), {
        [i.select.modelValue]: N,
        [V]: (Y) => {
          a("update:modelValue", Y);
        },
        [i.select.clearable]: true,
        ...i.select.buildMultiBinding(o.multiple),
        show: false,
        ...o.select
      };
    }), k = computed(() => {
      const V = i.dialog.buildProps({
        title: o.viewMode ? s("fs.extends.tableSelect.view") : s("fs.extends.tableSelect.select"),
        width: "80%"
      });
      return F(V, o.dialog);
    });
    watch(() => o.modelValue, async (V) => {
      V !== O.value && (b(V), await nextTick(), await o.dict.appendByValues(O.value));
    });
    const O = ref([]);
    function T() {
      return o.rowKey || f.value.table.rowKey || "id";
    }
    const D = ref(false);
    function $() {
      let V = i.table.buildSelectionCrudOptions({
        crossPage: o.crossPage,
        selectOnClickRow: true,
        getRowKey: T,
        getPageData() {
          return f.value.data;
        },
        useCompute: It,
        multiple: o.multiple,
        selectedRowKeys: O,
        onSelectedKeysChanged: async (Y) => {
          O.value = [...Y], await nextTick(), await o.dict.appendByValues(O.value);
        }
      });
      return F({
        table: {
          async onRefreshed() {
            if (i.table.setSelectedRows) {
              D.value = true, await nextTick(), await nextTick();
              const Y = m.getBaseTableRef();
              i.table.setSelectedRows({
                getRowKey: T,
                multiple: o.multiple,
                tableRef: Y,
                selectedRowKeys: O
              }), D.value = false;
            }
          }
        }
      }, V, o.crudOptionsOverride);
    }
    const {
      merge: F
    } = Re();
    async function M() {
      var me;
      if (o.dict.loading)
        return;
      let V = null, N = null;
      ((me = O.value) == null ? void 0 : me.length) > 0 && (V = [...O.value], N = V.map((pe) => o.dict.getDictMap()[pe]), o.valueType === "object" && (V = N), o.multiple !== true && V.length > 0 && (V = V[0])), o.viewMode || (a("update:modelValue", V), a("change", V), a("selected-change", N)), c.value = false;
      let Y = {
        value: V,
        rows: N,
        selectedRowKeys: O.value
      };
      a("dialog-close", Y), await nextTick(), a("dialog-closed", Y);
    }
    const ie = () => ({
      opened: c,
      open: _,
      selectedRowKeys: O,
      dictSelectRef: l,
      valuesFormatRef: u,
      crudRef: d2,
      crudBinding: f,
      crudExpose: m
    }), Q = ref(ie());
    return t(Q.value), (V, N) => {
      var Se;
      const Y = resolveComponent("fs-dict-select"), me = resolveComponent("fs-values-format"), pe = resolveComponent("fs-crud");
      return openBlock(), createElementBlock("div", Wh, [!((Se = unref(r)) != null && Se.default) && !V.viewMode ? (openBlock(), createBlock(Y, mergeProps({
        key: 0
      }, E.value, {
        ref_key: "dictSelectRef",
        ref: l,
        disabled: V.disabled,
        readonly: V.readonly,
        open: false,
        dict: V.dict,
        onClick: _
      }), null, 16, ["disabled", "readonly", "dict"])) : createCommentVNode("", true), renderSlot(V.$slots, "default", normalizeProps(guardReactiveProps(Q.value))), (openBlock(), createBlock(resolveDynamicComponent(unref(i).formItem.skipValidationWrapper), null, {
        default: withCtx(() => [(openBlock(), createBlock(resolveDynamicComponent(unref(i).dialog.name), mergeProps({
          [unref(i).dialog.visible]: c.value,
          ["onUpdate:" + unref(i).dialog.visible]: N[2] || (N[2] = (Ce) => c.value = Ce)
        }, k.value), {
          [unref(i).dialog.footerSlotName]: withCtx(() => [V.viewMode ? createCommentVNode("", true) : (openBlock(), createBlock(resolveDynamicComponent(unref(i).button.name), {
            key: 0,
            onClick: N[1] || (N[1] = (Ce) => c.value = false)
          }, {
            default: withCtx(() => [createTextVNode("取消")]),
            _: 1
          })), (openBlock(), createBlock(resolveDynamicComponent(unref(i).button.name), {
            type: "primary",
            onClick: M
          }, {
            default: withCtx(() => [createTextVNode("确认")]),
            _: 1
          }))]),
          default: withCtx(() => [c.value ? (openBlock(), createElementBlock("div", {
            key: 0,
            style: normalizeStyle({
              width: "100%",
              height: V.height || "60vh"
            })
          }, [createVNode(pe, mergeProps({
            ref_key: "crudRef",
            ref: d2
          }, unref(f)), {
            "header-top": withCtx(() => [V.showCurrent !== false && !V.viewMode ? (openBlock(), createElementBlock("div", xh, [createTextVNode(" 当前选中： "), createVNode(me, mergeProps({
              ref_key: "valuesFormatRef",
              ref: u,
              modelValue: O.value,
              "onUpdate:modelValue": N[0] || (N[0] = (Ce) => O.value = Ce),
              dict: V.dict,
              closable: true
            }, y.value), null, 16, ["modelValue", "dict"])])) : createCommentVNode("", true)]),
            _: 1
          }, 16)], 4)) : createCommentVNode("", true)]),
          _: 2
        }, 1040))]),
        _: 1
      }))]);
    };
  }
});
var da = Object.freeze(Object.defineProperty({
  __proto__: null,
  FsActionbar: _d,
  FsBox: Au,
  FsButton: mu,
  FsCell: ld,
  FsColumnsFilterLayoutDefault: jf,
  FsComponentRender: Pu,
  FsContainer: Xl,
  FsCrud: yc,
  FsDateFormat: Lh,
  FsDictCascader: Th,
  FsDictCascaderFormat: kh,
  FsDictCheckbox: Vh,
  FsDictRadio: ph,
  FsDictSelect: gh,
  FsDictSwitch: Bh,
  FsDictTree: zh,
  FsEditable: vd,
  FsEditableCell: ud,
  FsForm: Nu,
  FsFormHelper: tc,
  FsFormItem: Gu,
  FsFormProvider: rc,
  FsFormWrapper: Wn,
  FsIcon: pu,
  FsIconSvg: Su,
  FsIconify: bu,
  FsLabel: Du,
  FsLayoutCard: fu,
  FsLayoutDefault: ru,
  FsLoading: ku,
  FsPage: Zs,
  FsRender: za,
  FsRowHandle: Fc,
  FsSearch: Uf,
  FsSearchLayoutDefault: uh,
  FsSearchV1: th,
  FsSlotRender: Mu,
  FsTable: sd,
  FsTableColumnsFixedController: hi,
  FsTableSelect: Uh,
  FsTabsFilter: fh,
  FsToolbar: Ed,
  FsValuesFormat: Sh,
  fsColumnsFilterNestList: mi
}, Symbol.toStringTag, { value: "Module" }));
var { setDictRequest: Kh } = jl();
var cm = {
  install(e, t = {}) {
    t.ui && d.set(t.ui);
    const { merge: n } = Re();
    t.commonOptions && (Hn.commonOptions = t.commonOptions), t.dictRequest && Kh(t.dictRequest), t.i18n && co.setVueI18n(t.i18n);
    const o = t.customComponents || {};
    for (const r in da) {
      const a = o[r] || da[r];
      e.component(r, a);
    }
    Wn._context = e._context, gn.install(), e.config.globalProperties.$fsui = d.get(), n(zl.logger, t.logger), Yh(t.logger);
  }
};
function Yh(e) {
  var t;
  ((t = e == null ? void 0 : e.off) == null ? void 0 : t.tableColumns) !== false && console.warn(`[fast-crud] crudBinding.value.table.columns / toolbar.columnsFilter.originalColumns 由array改成map. 请改成通过key读取，你可以全局代码搜索【value.table.columns / columnsFilter.originalColumns】来检查是否有使用它们。
      [通过 app.use(FastCrud,{logger:{off:{tableColumns:false}}}) 可关闭此警告] `);
}

export {
  Hi,
  Ao,
  et,
  Io,
  Vo,
  Zs,
  Re,
  Po,
  ll,
  Rr,
  ul,
  It,
  Mo,
  kr,
  or,
  _o,
  Ia,
  Cl,
  Or,
  Rl,
  El,
  kl,
  rm,
  Pa,
  Ol,
  $l,
  Tl,
  am,
  Al,
  Il,
  Xt,
  Ha,
  Bl,
  jl,
  lm,
  Hl,
  zl,
  Xl,
  ru,
  fu,
  mu,
  pu,
  bu,
  Su,
  Du,
  ku,
  Au,
  Pu,
  Mu,
  za,
  Nu,
  Gu,
  tc,
  Wn,
  rc,
  yc,
  Fc,
  sd,
  ld,
  ud,
  vd,
  _d,
  um,
  $r,
  Ed,
  hi,
  mi,
  jf,
  Uf,
  th,
  uh,
  fh,
  ph,
  gh,
  Sh,
  kh,
  Th,
  Vh,
  Bh,
  Lh,
  zh,
  Uh,
  cm
};
/*! Bundled license information:

@fast-crud/fast-crud/dist/index-0bad1a5e.mjs:
  (**!
   * Sortable 1.14.0
   * @author	RubaXa   <trash@rubaxa.org>
   * @author	owenm    <owen23355@gmail.com>
   * @license MIT
   *)
*/
//# sourceMappingURL=chunk-M5TF25TK.js.map
