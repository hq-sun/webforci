import {
  c
} from "./chunk-DNE5XC46.js";
import {
  axios_default
} from "./chunk-A3Y574CH.js";
import {
  _9,
  w9
} from "./chunk-JV7AUQY5.js";
import "./chunk-555XXRDK.js";
import "./chunk-M5TF25TK.js";
import "./chunk-4QBCRV47.js";
import "./chunk-YFT6OQ5R.js";
import "./chunk-5SHNTQUO.js";
import "./chunk-F73GDDKZ.js";
import {
  lodash_default_default
} from "./chunk-LK7GAOJV.js";
import "./chunk-M4AHV5EN.js";
import "./chunk-7PYUCYS5.js";
import "./chunk-PLDDJCW6.js";

// node_modules/@fast-crud/fast-extends/dist/uploader-s3-f214a8a0.mjs
var qc = (e) => {
  let t = e.httpHandler;
  return {
    setHttpHandler(r) {
      t = r;
    },
    httpHandler() {
      return t;
    },
    updateHttpClientConfig(r, n) {
      t.updateHttpClientConfig(r, n);
    },
    httpHandlerConfigs() {
      return t.httpHandlerConfigs();
    }
  };
};
var Wc = (e) => ({
  httpHandler: e.httpHandler()
});
var us;
(function(e) {
  e.HEADER = "header", e.QUERY = "query";
})(us || (us = {}));
var ds;
(function(e) {
  e.HEADER = "header", e.QUERY = "query";
})(ds || (ds = {}));
var Ft;
(function(e) {
  e.HTTP = "http", e.HTTPS = "https";
})(Ft || (Ft = {}));
var Yt;
(function(e) {
  e.MD5 = "md5", e.CRC32 = "crc32", e.CRC32C = "crc32c", e.SHA1 = "sha1", e.SHA256 = "sha256";
})(Yt || (Yt = {}));
var ls;
(function(e) {
  e[e.HEADER = 0] = "HEADER", e[e.TRAILER = 1] = "TRAILER";
})(ls || (ls = {}));
var un = "__smithy_context";
var fs;
(function(e) {
  e.PROFILE = "profile", e.SSO_SESSION = "sso-session", e.SERVICES = "services";
})(fs || (fs = {}));
var hs;
(function(e) {
  e.HTTP_0_9 = "http/0.9", e.HTTP_1_0 = "http/1.0", e.TDS_8_0 = "tds/8.0";
})(hs || (hs = {}));
var ge = class _ge {
  constructor(t) {
    this.method = t.method || "GET", this.hostname = t.hostname || "localhost", this.port = t.port, this.query = t.query || {}, this.headers = t.headers || {}, this.body = t.body, this.protocol = t.protocol ? t.protocol.slice(-1) !== ":" ? `${t.protocol}:` : t.protocol : "https:", this.path = t.path ? t.path.charAt(0) !== "/" ? `/${t.path}` : t.path : "/", this.username = t.username, this.password = t.password, this.fragment = t.fragment;
  }
  static isInstance(t) {
    if (!t)
      return false;
    const r = t;
    return "method" in r && "protocol" in r && "hostname" in r && "path" in r && typeof r.query == "object" && typeof r.headers == "object";
  }
  clone() {
    const t = new _ge({
      ...this,
      headers: { ...this.headers }
    });
    return t.query && (t.query = Gc(t.query)), t;
  }
};
function Gc(e) {
  return Object.keys(e).reduce((t, r) => {
    const n = e[r];
    return {
      ...t,
      [r]: Array.isArray(n) ? [...n] : n
    };
  }, {});
}
var Qt = class {
  constructor(t) {
    this.statusCode = t.statusCode, this.reason = t.reason, this.headers = t.headers || {}, this.body = t.body;
  }
  static isInstance(t) {
    if (!t)
      return false;
    const r = t;
    return typeof r.statusCode == "number" && typeof r.headers == "object";
  }
};
function Vc(e) {
  return (t) => async (r) => {
    var s, i;
    const { request: n } = r;
    return ge.isInstance(n) && n.body && e.runtime === "node" && ((i = (s = e.requestHandler) == null ? void 0 : s.constructor) == null ? void 0 : i.name) !== "FetchHttpHandler" && (n.headers = {
      ...n.headers,
      Expect: "100-continue"
    }), t({
      ...r,
      request: n
    });
  };
}
var Kc = {
  step: "build",
  tags: ["SET_EXPECT_HEADER", "EXPECT_HEADER"],
  name: "addExpectContinueMiddleware",
  override: true
};
var Xc = (e) => ({
  applyToStack: (t) => {
    t.add(Vc(e), Kc);
  }
});
var Zc = (e) => (t) => async (r) => {
  if (!ge.isInstance(r.request))
    return t(r);
  const { request: n } = r, { handlerProtocol: s = "" } = e.requestHandler.metadata || {};
  if (s.indexOf("h2") >= 0 && !n.headers[":authority"])
    delete n.headers.host, n.headers[":authority"] = n.hostname + (n.port ? ":" + n.port : "");
  else if (!n.headers.host) {
    let i = n.hostname;
    n.port != null && (i += `:${n.port}`), n.headers.host = i;
  }
  return t(r);
};
var Yc = {
  name: "hostHeaderMiddleware",
  step: "build",
  priority: "low",
  tags: ["HOST"],
  override: true
};
var Qc = (e) => ({
  applyToStack: (t) => {
    t.add(Zc(e), Yc);
  }
});
var Jc = () => (e, t) => async (r) => {
  var n, s;
  try {
    const i = await e(r), { clientName: o, commandName: a, logger: c2, dynamoDbDocumentClientOptions: u = {} } = t, { overrideInputFilterSensitiveLog: l, overrideOutputFilterSensitiveLog: h } = u, p = l ?? t.inputFilterSensitiveLog, g = h ?? t.outputFilterSensitiveLog, { $metadata: b, ...A } = i.output;
    return (n = c2 == null ? void 0 : c2.info) == null || n.call(c2, {
      clientName: o,
      commandName: a,
      input: p(r.input),
      output: g(A),
      metadata: b
    }), i;
  } catch (i) {
    const { clientName: o, commandName: a, logger: c2, dynamoDbDocumentClientOptions: u = {} } = t, { overrideInputFilterSensitiveLog: l } = u, h = l ?? t.inputFilterSensitiveLog;
    throw (s = c2 == null ? void 0 : c2.error) == null || s.call(c2, {
      clientName: o,
      commandName: a,
      input: h(r.input),
      error: i,
      metadata: i.$metadata
    }), i;
  }
};
var eu = {
  name: "loggerMiddleware",
  tags: ["LOGGER"],
  step: "initialize",
  override: true
};
var tu = (e) => ({
  applyToStack: (t) => {
    t.add(Jc(), eu);
  }
});
var ps = "X-Amzn-Trace-Id";
var ru = "AWS_LAMBDA_FUNCTION_NAME";
var nu = "_X_AMZN_TRACE_ID";
var su = (e) => (t) => async (r) => {
  const { request: n } = r;
  if (!ge.isInstance(n) || e.runtime !== "node" || n.headers.hasOwnProperty(ps))
    return t(r);
  const s = process.env[ru], i = process.env[nu], o = (a) => typeof a == "string" && a.length > 0;
  return o(s) && o(i) && (n.headers[ps] = i), t({
    ...r,
    request: n
  });
};
var iu = {
  step: "build",
  tags: ["RECURSION_DETECTION"],
  name: "recursionDetectionMiddleware",
  override: true,
  priority: "low"
};
var ou = (e) => ({
  applyToStack: (t) => {
    t.add(su(e), iu);
  }
});
var Tn = class {
  trace() {
  }
  debug() {
  }
  info() {
  }
  warn() {
  }
  error() {
  }
};
var Ge = (e, t) => {
  const r = [];
  if (e && r.push(e), t)
    for (const n of t)
      r.push(n);
  return r;
};
var Ie = (e, t) => `${e || "anonymous"}${t && t.length > 0 ? ` (a.k.a. ${t.join(",")})` : ""}`;
var Jt = () => {
  let e = [], t = [], r = false;
  const n = /* @__PURE__ */ new Set(), s = (h) => h.sort((p, g) => gs[g.step] - gs[p.step] || ms[g.priority || "normal"] - ms[p.priority || "normal"]), i = (h) => {
    let p = false;
    const g = (b) => {
      const A = Ge(b.name, b.aliases);
      if (A.includes(h)) {
        p = true;
        for (const R of A)
          n.delete(R);
        return false;
      }
      return true;
    };
    return e = e.filter(g), t = t.filter(g), p;
  }, o = (h) => {
    let p = false;
    const g = (b) => {
      if (b.middleware === h) {
        p = true;
        for (const A of Ge(b.name, b.aliases))
          n.delete(A);
        return false;
      }
      return true;
    };
    return e = e.filter(g), t = t.filter(g), p;
  }, a = (h) => {
    var p;
    return e.forEach((g) => {
      h.add(g.middleware, { ...g });
    }), t.forEach((g) => {
      h.addRelativeTo(g.middleware, { ...g });
    }), (p = h.identifyOnResolve) == null || p.call(h, l.identifyOnResolve()), h;
  }, c2 = (h) => {
    const p = [];
    return h.before.forEach((g) => {
      g.before.length === 0 && g.after.length === 0 ? p.push(g) : p.push(...c2(g));
    }), p.push(h), h.after.reverse().forEach((g) => {
      g.before.length === 0 && g.after.length === 0 ? p.push(g) : p.push(...c2(g));
    }), p;
  }, u = (h = false) => {
    const p = [], g = [], b = {};
    return e.forEach((R) => {
      const T = {
        ...R,
        before: [],
        after: []
      };
      for (const I of Ge(T.name, T.aliases))
        b[I] = T;
      p.push(T);
    }), t.forEach((R) => {
      const T = {
        ...R,
        before: [],
        after: []
      };
      for (const I of Ge(T.name, T.aliases))
        b[I] = T;
      g.push(T);
    }), g.forEach((R) => {
      if (R.toMiddleware) {
        const T = b[R.toMiddleware];
        if (T === void 0) {
          if (h)
            return;
          throw new Error(`${R.toMiddleware} is not found when adding ${Ie(R.name, R.aliases)} middleware ${R.relation} ${R.toMiddleware}`);
        }
        R.relation === "after" && T.after.push(R), R.relation === "before" && T.before.push(R);
      }
    }), s(p).map(c2).reduce((R, T) => (R.push(...T), R), []);
  }, l = {
    add: (h, p = {}) => {
      const { name: g, override: b, aliases: A } = p, R = {
        step: "initialize",
        priority: "normal",
        middleware: h,
        ...p
      }, T = Ge(g, A);
      if (T.length > 0) {
        if (T.some((I) => n.has(I))) {
          if (!b)
            throw new Error(`Duplicate middleware name '${Ie(g, A)}'`);
          for (const I of T) {
            const $ = e.findIndex((Z) => {
              var Oe;
              return Z.name === I || ((Oe = Z.aliases) == null ? void 0 : Oe.some((et) => et === I));
            });
            if ($ === -1)
              continue;
            const X = e[$];
            if (X.step !== R.step || R.priority !== X.priority)
              throw new Error(`"${Ie(X.name, X.aliases)}" middleware with ${X.priority} priority in ${X.step} step cannot be overridden by "${Ie(g, A)}" middleware with ${R.priority} priority in ${R.step} step.`);
            e.splice($, 1);
          }
        }
        for (const I of T)
          n.add(I);
      }
      e.push(R);
    },
    addRelativeTo: (h, p) => {
      const { name: g, override: b, aliases: A } = p, R = {
        middleware: h,
        ...p
      }, T = Ge(g, A);
      if (T.length > 0) {
        if (T.some((I) => n.has(I))) {
          if (!b)
            throw new Error(`Duplicate middleware name '${Ie(g, A)}'`);
          for (const I of T) {
            const $ = t.findIndex((Z) => {
              var Oe;
              return Z.name === I || ((Oe = Z.aliases) == null ? void 0 : Oe.some((et) => et === I));
            });
            if ($ === -1)
              continue;
            const X = t[$];
            if (X.toMiddleware !== R.toMiddleware || X.relation !== R.relation)
              throw new Error(`"${Ie(X.name, X.aliases)}" middleware ${X.relation} "${X.toMiddleware}" middleware cannot be overridden by "${Ie(g, A)}" middleware ${R.relation} "${R.toMiddleware}" middleware.`);
            t.splice($, 1);
          }
        }
        for (const I of T)
          n.add(I);
      }
      t.push(R);
    },
    clone: () => a(Jt()),
    use: (h) => {
      h.applyToStack(l);
    },
    remove: (h) => typeof h == "string" ? i(h) : o(h),
    removeByTag: (h) => {
      let p = false;
      const g = (b) => {
        const { tags: A, name: R, aliases: T } = b;
        if (A && A.includes(h)) {
          const I = Ge(R, T);
          for (const $ of I)
            n.delete($);
          return p = true, false;
        }
        return true;
      };
      return e = e.filter(g), t = t.filter(g), p;
    },
    concat: (h) => {
      var g;
      const p = a(Jt());
      return p.use(h), p.identifyOnResolve(r || p.identifyOnResolve() || (((g = h.identifyOnResolve) == null ? void 0 : g.call(h)) ?? false)), p;
    },
    applyToStack: a,
    identify: () => u(true).map((h) => {
      const p = h.step ?? h.relation + " " + h.toMiddleware;
      return Ie(h.name, h.aliases) + " - " + p;
    }),
    identifyOnResolve(h) {
      return typeof h == "boolean" && (r = h), r;
    },
    resolve: (h, p) => {
      for (const g of u().map((b) => b.middleware).reverse())
        h = g(h, p);
      return h;
    }
  };
  return l;
};
var gs = {
  initialize: 5,
  serialize: 4,
  build: 3,
  finalizeRequest: 2,
  deserialize: 1
};
var ms = {
  high: 3,
  normal: 2,
  low: 1
};
var au = class {
  constructor(t) {
    this.middlewareStack = Jt(), this.config = t;
  }
  send(t, r, n) {
    const s = typeof r != "function" ? r : void 0, i = typeof r == "function" ? r : n, o = t.resolveMiddleware(this.middlewareStack, this.config, s);
    if (i)
      o(t).then((a) => i(null, a.output), (a) => i(a)).catch(() => {
      });
    else
      return o(t).then((a) => a.output);
  }
  destroy() {
    this.config.requestHandler.destroy && this.config.requestHandler.destroy();
  }
};
var je = {};
var ut = new Array(64);
for (let e = 0, t = "A".charCodeAt(0), r = "Z".charCodeAt(0); e + t <= r; e++) {
  const n = String.fromCharCode(e + t);
  je[n] = e, ut[e] = n;
}
for (let e = 0, t = "a".charCodeAt(0), r = "z".charCodeAt(0); e + t <= r; e++) {
  const n = String.fromCharCode(e + t), s = e + 26;
  je[n] = s, ut[s] = n;
}
for (let e = 0; e < 10; e++) {
  je[e.toString(10)] = e + 52;
  const t = e.toString(10), r = e + 52;
  je[t] = r, ut[r] = t;
}
je["+"] = 62;
ut[62] = "+";
je["/"] = 63;
ut[63] = "/";
var it = 6;
var Pt = 8;
var cu = 63;
var Bn = (e) => {
  let t = e.length / 4 * 3;
  e.slice(-2) === "==" ? t -= 2 : e.slice(-1) === "=" && t--;
  const r = new ArrayBuffer(t), n = new DataView(r);
  for (let s = 0; s < e.length; s += 4) {
    let i = 0, o = 0;
    for (let u = s, l = s + 3; u <= l; u++)
      if (e[u] !== "=") {
        if (!(e[u] in je))
          throw new TypeError(`Invalid character ${e[u]} in base64 string.`);
        i |= je[e[u]] << (l - u) * it, o += it;
      } else
        i >>= it;
    const a = s / 4 * 3;
    i >>= o % Pt;
    const c2 = Math.floor(o / Pt);
    for (let u = 0; u < c2; u++) {
      const l = (c2 - u - 1) * Pt;
      n.setUint8(a + u, (i & 255 << l) >> l);
    }
  }
  return new Uint8Array(r);
};
var Qe = (e) => new TextEncoder().encode(e);
var ot = (e) => typeof e == "string" ? Qe(e) : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(e);
var kn = (e) => {
  if (typeof e == "string")
    return e;
  if (typeof e != "object" || typeof e.byteOffset != "number" || typeof e.byteLength != "number")
    throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
  return new TextDecoder("utf-8").decode(e);
};
function Nn(e) {
  let t;
  typeof e == "string" ? t = Qe(e) : t = e;
  const r = typeof t == "object" && typeof t.length == "number", n = typeof t == "object" && typeof t.byteOffset == "number" && typeof t.byteLength == "number";
  if (!r && !n)
    throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
  let s = "";
  for (let i = 0; i < t.length; i += 3) {
    let o = 0, a = 0;
    for (let u = i, l = Math.min(i + 3, t.length); u < l; u++)
      o |= t[u] << (l - u - 1) * Pt, a += Pt;
    const c2 = Math.ceil(a / it);
    o <<= c2 * it - a;
    for (let u = 1; u <= c2; u++) {
      const l = (c2 - u) * it;
      s += ut[(o & cu << l) >> l];
    }
    s += "==".slice(0, 4 - c2);
  }
  return s;
}
function uu(e, t = "utf-8") {
  return t === "base64" ? Nn(e) : kn(e);
}
function du(e, t) {
  return t === "base64" ? Ze.mutate(Bn(e)) : Ze.mutate(Qe(e));
}
var Ze = class _Ze extends Uint8Array {
  static fromString(t, r = "utf-8") {
    switch (typeof t) {
      case "string":
        return du(t, r);
      default:
        throw new Error(`Unsupported conversion from ${typeof t} to Uint8ArrayBlobAdapter.`);
    }
  }
  static mutate(t) {
    return Object.setPrototypeOf(t, _Ze.prototype), t;
  }
  transformToString(t = "utf-8") {
    return uu(this, t);
  }
};
var lu = (e, t) => {
  const { base64Encoder: r, bodyLengthChecker: n, checksumAlgorithmFn: s, checksumLocationName: i, streamHasher: o } = t, a = r !== void 0 && n !== void 0 && s !== void 0 && i !== void 0 && o !== void 0, c2 = a ? o(s, e) : void 0, u = e.getReader();
  return new ReadableStream({
    async pull(l) {
      const { value: h, done: p } = await u.read();
      if (p) {
        if (l.enqueue(`0\r
`), a) {
          const g = r(await c2);
          l.enqueue(`${i}:${g}\r
`), l.enqueue(`\r
`);
        }
        l.close();
      } else
        l.enqueue(`${(n(h) || 0).toString(16)}\r
${h}\r
`);
    }
  });
};
var He = (e) => encodeURIComponent(e).replace(/[!'()*]/g, fu);
var fu = (e) => `%${e.charCodeAt(0).toString(16).toUpperCase()}`;
function hu(e) {
  const t = [];
  for (let r of Object.keys(e).sort()) {
    const n = e[r];
    if (r = He(r), Array.isArray(n))
      for (let s = 0, i = n.length; s < i; s++)
        t.push(`${r}=${He(n[s])}`);
    else {
      let s = r;
      (n || typeof n == "string") && (s += `=${He(n)}`), t.push(s);
    }
  }
  return t.join("&");
}
function pu(e = 0) {
  return new Promise((t, r) => {
    e && setTimeout(() => {
      const n = new Error(`Request did not complete within ${e} ms`);
      n.name = "TimeoutError", r(n);
    }, e);
  });
}
var gu = {
  supported: typeof Request < "u" && "keepalive" in new Request("https://[::1]")
};
var Pn = class _Pn {
  static create(t) {
    return typeof (t == null ? void 0 : t.handle) == "function" ? t : new _Pn(t);
  }
  constructor(t) {
    typeof t == "function" ? this.configProvider = t().then((r) => r || {}) : (this.config = t ?? {}, this.configProvider = Promise.resolve(this.config));
  }
  destroy() {
  }
  async handle(t, { abortSignal: r } = {}) {
    this.config || (this.config = await this.configProvider);
    const n = this.config.requestTimeout, s = this.config.keepAlive === true;
    if (r != null && r.aborted) {
      const A = new Error("Request aborted");
      return A.name = "AbortError", Promise.reject(A);
    }
    let i = t.path;
    const o = hu(t.query || {});
    o && (i += `?${o}`), t.fragment && (i += `#${t.fragment}`);
    let a = "";
    if (t.username != null || t.password != null) {
      const A = t.username ?? "", R = t.password ?? "";
      a = `${A}:${R}@`;
    }
    const { port: c2, method: u } = t, l = `${t.protocol}//${a}${t.hostname}${c2 ? `:${c2}` : ""}${i}`, h = u === "GET" || u === "HEAD" ? void 0 : t.body, p = {
      body: h,
      headers: new Headers(t.headers),
      method: u
    };
    h && (p.duplex = "half"), typeof AbortController < "u" && (p.signal = r), gu.supported && (p.keepalive = s);
    const g = new Request(l, p), b = [
      fetch(g).then((A) => {
        const R = A.headers, T = {};
        for (const $ of R.entries())
          T[$[0]] = $[1];
        return A.body != null ? {
          response: new Qt({
            headers: T,
            reason: A.statusText,
            statusCode: A.status,
            body: A.body
          })
        } : A.blob().then(($) => ({
          response: new Qt({
            headers: T,
            reason: A.statusText,
            statusCode: A.status,
            body: $
          })
        }));
      }),
      pu(n)
    ];
    return r && b.push(new Promise((A, R) => {
      r.onabort = () => {
        const T = new Error("Request aborted");
        T.name = "AbortError", R(T);
      };
    })), Promise.race(b);
  }
  updateHttpClientConfig(t, r) {
    this.config = void 0, this.configProvider = this.configProvider.then((n) => (n[t] = r, n));
  }
  httpHandlerConfigs() {
    return this.config ?? {};
  }
};
var Ho = (e) => typeof Blob == "function" && e instanceof Blob ? mu(e) : yu(e);
async function mu(e) {
  const t = await bu(e), r = Bn(t);
  return new Uint8Array(r);
}
async function yu(e) {
  const t = [], r = e.getReader();
  let n = false, s = 0;
  for (; !n; ) {
    const { done: a, value: c2 } = await r.read();
    c2 && (t.push(c2), s += c2.length), n = a;
  }
  const i = new Uint8Array(s);
  let o = 0;
  for (const a of t)
    i.set(a, o), o += a.length;
  return i;
}
function bu(e) {
  return new Promise((t, r) => {
    const n = new FileReader();
    n.onloadend = () => {
      if (n.readyState !== 2)
        return r(new Error("Reader aborted too early"));
      const s = n.result ?? "", i = s.indexOf(","), o = i > -1 ? i + 1 : s.length;
      t(s.substring(o));
    }, n.onabort = () => r(new Error("Read aborted")), n.onerror = () => r(n.error), n.readAsDataURL(e);
  });
}
var jo = {};
var dn = {};
for (let e = 0; e < 256; e++) {
  let t = e.toString(16).toLowerCase();
  t.length === 1 && (t = `0${t}`), jo[e] = t, dn[t] = e;
}
function zo(e) {
  if (e.length % 2 !== 0)
    throw new Error("Hex encoded strings must have an even number length");
  const t = new Uint8Array(e.length / 2);
  for (let r = 0; r < e.length; r += 2) {
    const n = e.slice(r, r + 2).toLowerCase();
    if (n in dn)
      t[r / 2] = dn[n];
    else
      throw new Error(`Cannot decode unrecognized sequence ${n} as hexadecimal`);
  }
  return t;
}
function he(e) {
  let t = "";
  for (let r = 0; r < e.byteLength; r++)
    t += jo[e[r]];
  return t;
}
var ys = "The stream has already been transformed.";
var wu = (e) => {
  var s, i;
  if (!bs(e) && !ws(e)) {
    const o = ((i = (s = e == null ? void 0 : e.__proto__) == null ? void 0 : s.constructor) == null ? void 0 : i.name) || e;
    throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${o}`);
  }
  let t = false;
  const r = async () => {
    if (t)
      throw new Error(ys);
    return t = true, await Ho(e);
  }, n = (o) => {
    if (typeof o.stream != "function")
      throw new Error(`Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.
If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body`);
    return o.stream();
  };
  return Object.assign(e, {
    transformToByteArray: r,
    transformToString: async (o) => {
      const a = await r();
      if (o === "base64")
        return Nn(a);
      if (o === "hex")
        return he(a);
      if (o === void 0 || o === "utf8" || o === "utf-8")
        return kn(a);
      if (typeof TextDecoder == "function")
        return new TextDecoder(o).decode(a);
      throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
    },
    transformToWebStream: () => {
      if (t)
        throw new Error(ys);
      if (t = true, bs(e))
        return n(e);
      if (ws(e))
        return e;
      throw new Error(`Cannot transform payload to web stream, got ${e}`);
    }
  });
};
var bs = (e) => typeof Blob == "function" && e instanceof Blob;
var ws = (e) => typeof ReadableStream == "function" && e instanceof ReadableStream;
var qo = async (e = new Uint8Array(), t) => {
  if (e instanceof Uint8Array)
    return Ze.mutate(e);
  if (!e)
    return Ze.mutate(new Uint8Array());
  const r = t.streamCollector(e);
  return Ze.mutate(await r);
};
var On = class {
  constructor() {
    this.middlewareStack = Jt();
  }
  static classBuilder() {
    return new xu();
  }
  resolveMiddlewareWithContext(t, r, n, { middlewareFn: s, clientName: i, commandName: o, inputFilterSensitiveLog: a, outputFilterSensitiveLog: c2, smithyContext: u, additionalContext: l, CommandCtor: h }) {
    for (const R of s.bind(this)(h, t, r, n))
      this.middlewareStack.use(R);
    const p = t.concat(this.middlewareStack), { logger: g } = r, b = {
      logger: g,
      clientName: i,
      commandName: o,
      inputFilterSensitiveLog: a,
      outputFilterSensitiveLog: c2,
      [un]: {
        ...u
      },
      ...l
    }, { requestHandler: A } = r;
    return p.resolve((R) => A.handle(R.request, n || {}), b);
  }
};
var xu = class {
  constructor() {
    this._init = () => {
    }, this._ep = {}, this._middlewareFn = () => [], this._commandName = "", this._clientName = "", this._additionalContext = {}, this._smithyContext = {}, this._inputFilterSensitiveLog = (t) => t, this._outputFilterSensitiveLog = (t) => t, this._serializer = null, this._deserializer = null;
  }
  init(t) {
    this._init = t;
  }
  ep(t) {
    return this._ep = t, this;
  }
  m(t) {
    return this._middlewareFn = t, this;
  }
  s(t, r, n = {}) {
    return this._smithyContext = {
      service: t,
      operation: r,
      ...n
    }, this;
  }
  c(t = {}) {
    return this._additionalContext = t, this;
  }
  n(t, r) {
    return this._clientName = t, this._commandName = r, this;
  }
  f(t = (n) => n, r = (n) => n) {
    return this._inputFilterSensitiveLog = t, this._outputFilterSensitiveLog = r, this;
  }
  ser(t) {
    return this._serializer = t, this;
  }
  de(t) {
    return this._deserializer = t, this;
  }
  build() {
    const t = this;
    let r;
    return r = class extends On {
      static getEndpointParameterInstructions() {
        return t._ep;
      }
      constructor(...[n]) {
        super(), this.serialize = t._serializer, this.deserialize = t._deserializer, this.input = n ?? {}, t._init(this);
      }
      resolveMiddleware(n, s, i) {
        return this.resolveMiddlewareWithContext(n, s, i, {
          CommandCtor: r,
          middlewareFn: t._middlewareFn,
          clientName: t._clientName,
          commandName: t._commandName,
          inputFilterSensitiveLog: t._inputFilterSensitiveLog,
          outputFilterSensitiveLog: t._outputFilterSensitiveLog,
          smithyContext: t._smithyContext,
          additionalContext: t._additionalContext
        });
      }
    };
  }
};
var Ye = "***SensitiveInformation***";
var Eu = (e) => {
  switch (e) {
    case "true":
      return true;
    case "false":
      return false;
    default:
      throw new Error(`Unable to parse boolean value "${e}"`);
  }
};
var Au = (e) => {
  if (e != null) {
    if (typeof e == "string") {
      const t = parseFloat(e);
      if (!Number.isNaN(t))
        return String(t) !== String(e) && Ko.warn(Vo(`Expected number but observed string: ${e}`)), t;
    }
    if (typeof e == "number")
      return e;
    throw new TypeError(`Expected number, got ${typeof e}: ${e}`);
  }
};
var Su = Math.ceil(2 ** 127 * (2 - 2 ** -23));
var xs = (e) => {
  const t = Au(e);
  if (t !== void 0 && !Number.isNaN(t) && t !== 1 / 0 && t !== -1 / 0 && Math.abs(t) > Su)
    throw new TypeError(`Expected 32-bit float, got ${e}`);
  return t;
};
var Cu = (e) => {
  if (e != null) {
    if (Number.isInteger(e) && !Number.isNaN(e))
      return e;
    throw new TypeError(`Expected integer, got ${typeof e}: ${e}`);
  }
};
var Es = (e) => Wo(e, 16);
var As = (e) => Wo(e, 8);
var Wo = (e, t) => {
  const r = Cu(e);
  if (r !== void 0 && vu(r, t) !== r)
    throw new TypeError(`Expected ${t}-bit integer, got ${e}`);
  return r;
};
var vu = (e, t) => {
  switch (t) {
    case 32:
      return Int32Array.of(e)[0];
    case 16:
      return Int16Array.of(e)[0];
    case 8:
      return Int8Array.of(e)[0];
  }
};
var Go = (e, t) => {
  if (e == null)
    throw t ? new TypeError(`Expected a non-null value for ${t}`) : new TypeError("Expected a non-null value");
  return e;
};
var Ru = (e) => {
  if (e == null)
    return;
  if (typeof e == "object" && !Array.isArray(e))
    return e;
  const t = Array.isArray(e) ? "array" : typeof e;
  throw new TypeError(`Expected object, got ${t}: ${e}`);
};
var Ot = (e) => {
  if (e != null) {
    if (typeof e == "string")
      return e;
    if (["boolean", "number", "bigint"].includes(typeof e))
      return Ko.warn(Vo(`Expected string, got ${typeof e}: ${e}`)), String(e);
    throw new TypeError(`Expected string, got ${typeof e}: ${e}`);
  }
};
var _u = (e) => xs(typeof e == "string" ? Mn(e) : e);
var Tu = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
var Mn = (e) => {
  const t = e.match(Tu);
  if (t === null || t[0].length !== e.length)
    throw new TypeError("Expected real number, got implicit NaN");
  return parseFloat(e);
};
var Bu = (e) => Es(typeof e == "string" ? Mn(e) : e);
var ku = (e) => As(typeof e == "string" ? Mn(e) : e);
var Vo = (e) => String(new TypeError(e).stack || e).split(`
`).slice(0, 5).filter((t) => !t.includes("stackTraceWarning")).join(`
`);
var Ko = {
  warn: console.warn
};
var Nu = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
var Xo = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function Pu(e) {
  const t = e.getUTCFullYear(), r = e.getUTCMonth(), n = e.getUTCDay(), s = e.getUTCDate(), i = e.getUTCHours(), o = e.getUTCMinutes(), a = e.getUTCSeconds(), c2 = s < 10 ? `0${s}` : `${s}`, u = i < 10 ? `0${i}` : `${i}`, l = o < 10 ? `0${o}` : `${o}`, h = a < 10 ? `0${a}` : `${a}`;
  return `${Nu[n]}, ${c2} ${Xo[r]} ${t} ${u}:${l}:${h} GMT`;
}
var Ou = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
var Mu = (e) => {
  if (e == null)
    return;
  if (typeof e != "string")
    throw new TypeError("RFC-3339 date-times must be expressed as strings");
  const t = Ou.exec(e);
  if (!t)
    throw new TypeError("Invalid RFC-3339 date-time value");
  const [r, n, s, i, o, a, c2, u, l] = t, h = Bu(Zo(n)), p = Mt(s, "month", 1, 12), g = Mt(i, "day", 1, 31), b = Iu(h, p, g, { hours: o, minutes: a, seconds: c2, fractionalMilliseconds: u });
  return l.toUpperCase() != "Z" && b.setTime(b.getTime() - Lu(l)), b;
};
var Iu = (e, t, r, n) => {
  const s = t - 1;
  return Du(e, s, r), new Date(Date.UTC(e, s, r, Mt(n.hours, "hour", 0, 23), Mt(n.minutes, "minute", 0, 59), Mt(n.seconds, "seconds", 0, 60), $u(n.fractionalMilliseconds)));
};
var Fu = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var Du = (e, t, r) => {
  let n = Fu[t];
  if (t === 1 && Uu(e) && (n = 29), r > n)
    throw new TypeError(`Invalid day for ${Xo[t]} in ${e}: ${r}`);
};
var Uu = (e) => e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0);
var Mt = (e, t, r, n) => {
  const s = ku(Zo(e));
  if (s < r || s > n)
    throw new TypeError(`${t} must be between ${r} and ${n}, inclusive`);
  return s;
};
var $u = (e) => e == null ? 0 : _u("0." + e) * 1e3;
var Lu = (e) => {
  const t = e[0];
  let r = 1;
  if (t == "+")
    r = 1;
  else if (t == "-")
    r = -1;
  else
    throw new TypeError(`Offset direction, ${t}, must be "+" or "-"`);
  const n = Number(e.substring(1, 3)), s = Number(e.substring(4, 6));
  return r * (n * 60 + s) * 60 * 1e3;
};
var Zo = (e) => {
  let t = 0;
  for (; t < e.length - 1 && e.charAt(t) === "0"; )
    t++;
  return t === 0 ? e : e.slice(t);
};
var In = class _In extends Error {
  constructor(t) {
    super(t.message), Object.setPrototypeOf(this, _In.prototype), this.name = t.name, this.$fault = t.$fault, this.$metadata = t.$metadata;
  }
};
var Ne = (e, t = {}) => {
  Object.entries(t).filter(([, n]) => n !== void 0).forEach(([n, s]) => {
    (e[n] == null || e[n] === "") && (e[n] = s);
  });
  const r = e.message || e.Message || "UnknownError";
  return e.message = r, delete e.Message, e;
};
var Hu = ({ output: e, parsedBody: t, exceptionCtor: r, errorCode: n }) => {
  const s = zu(e), i = s.httpStatusCode ? s.httpStatusCode + "" : void 0, o = new r({
    name: (t == null ? void 0 : t.code) || (t == null ? void 0 : t.Code) || n || i || "UnknownError",
    $fault: "client",
    $metadata: s
  });
  throw Ne(o, t);
};
var ju = (e) => ({ output: t, parsedBody: r, errorCode: n }) => {
  Hu({ output: t, parsedBody: r, exceptionCtor: e, errorCode: n });
};
var zu = (e) => ({
  httpStatusCode: e.statusCode,
  requestId: e.headers["x-amzn-requestid"] ?? e.headers["x-amzn-request-id"] ?? e.headers["x-amz-request-id"],
  extendedRequestId: e.headers["x-amz-id-2"],
  cfId: e.headers["x-amz-cf-id"]
});
var qu = (e) => {
  switch (e) {
    case "standard":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "in-region":
      return {
        retryMode: "standard",
        connectionTimeout: 1100
      };
    case "cross-region":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "mobile":
      return {
        retryMode: "standard",
        connectionTimeout: 3e4
      };
    default:
      return {};
  }
};
var Wu = (e) => {
  const t = [];
  for (const r in Yt) {
    const n = Yt[r];
    e[n] !== void 0 && t.push({
      algorithmId: () => n,
      checksumConstructor: () => e[n]
    });
  }
  return {
    _checksumAlgorithms: t,
    addChecksumAlgorithm(r) {
      this._checksumAlgorithms.push(r);
    },
    checksumAlgorithms() {
      return this._checksumAlgorithms;
    }
  };
};
var Gu = (e) => {
  const t = {};
  return e.checksumAlgorithms().forEach((r) => {
    t[r.algorithmId()] = r.checksumConstructor();
  }), t;
};
var Vu = (e) => {
  let t = e.retryStrategy;
  return {
    setRetryStrategy(r) {
      t = r;
    },
    retryStrategy() {
      return t;
    }
  };
};
var Ku = (e) => {
  const t = {};
  return t.retryStrategy = e.retryStrategy(), t;
};
var Xu = (e) => ({
  ...Wu(e),
  ...Vu(e)
});
var Zu = (e) => ({
  ...Gu(e),
  ...Ku(e)
});
function Ss(e) {
  return encodeURIComponent(e).replace(/[!'()*]/g, function(t) {
    return "%" + t.charCodeAt(0).toString(16).toUpperCase();
  });
}
var Yo = (e) => {
  const t = "#text";
  for (const r in e)
    e.hasOwnProperty(r) && e[r][t] !== void 0 ? e[r] = e[r][t] : typeof e[r] == "object" && e[r] !== null && (e[r] = Yo(e[r]));
  return e;
};
var ln = function() {
  const e = Object.getPrototypeOf(this).constructor, t = Function.bind.apply(String, [null, ...arguments]), r = new t();
  return Object.setPrototypeOf(r, e.prototype), r;
};
ln.prototype = Object.create(String.prototype, {
  constructor: {
    value: ln,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
Object.setPrototypeOf(ln, String);
function ae(e, t, r) {
  let n, s, i;
  if (typeof t > "u" && typeof r > "u")
    n = {}, i = e;
  else {
    if (n = e, typeof t == "function")
      return s = t, i = r, Yu(n, s, i);
    i = t;
  }
  for (const o of Object.keys(i)) {
    if (!Array.isArray(i[o])) {
      n[o] = i[o];
      continue;
    }
    Qu(n, null, i, o);
  }
  return n;
}
var Yu = (e, t, r) => ae(e, Object.entries(r).reduce((n, [s, i]) => (Array.isArray(i) ? n[s] = i : typeof i == "function" ? n[s] = [t, i()] : n[s] = [t, i], n), {}));
var Qu = (e, t, r, n) => {
  if (t !== null) {
    let o = r[n];
    typeof o == "function" && (o = [, o]);
    const [a = Ju, c2 = ed, u = n] = o;
    (typeof a == "function" && a(t[u]) || typeof a != "function" && a) && (e[n] = c2(t[u]));
    return;
  }
  let [s, i] = r[n];
  if (typeof i == "function") {
    let o;
    const a = s === void 0 && (o = i()) != null, c2 = typeof s == "function" && !!s(void 0) || typeof s != "function" && !!s;
    a ? e[n] = o : c2 && (e[n] = i());
  } else {
    const o = s === void 0 && i != null, a = typeof s == "function" && !!s(i) || typeof s != "function" && !!s;
    (o || a) && (e[n] = i);
  }
};
var Ju = (e) => e != null;
var ed = (e) => e;
var td = (e, t, r, n, s, i) => {
  if (t != null && t[r] !== void 0) {
    const o = n();
    if (o.length <= 0)
      throw new Error("Empty value provided for input HTTP label: " + r + ".");
    e = e.replace(s, i ? o.split("/").map((a) => Ss(a)).join("/") : Ss(o));
  } else
    throw new Error("No value provided for input HTTP label: " + r + ".");
  return e;
};
var rd = (e) => e.toISOString().replace(".000Z", "Z");
var nd = "content-length";
function sd() {
  return (e, t) => async (r) => {
    var s;
    const { request: n } = r;
    if (ge.isInstance(n) && !(nd in n.headers)) {
      const i = "Are you using a Stream of unknown length as the Body of a PutObject request? Consider using Upload instead from @aws-sdk/lib-storage.";
      typeof ((s = t == null ? void 0 : t.logger) == null ? void 0 : s.warn) == "function" && !(t.logger instanceof Tn) && t.logger.warn(i);
    }
    return e({ ...r });
  };
}
var id = {
  step: "finalizeRequest",
  tags: ["CHECK_CONTENT_LENGTH_HEADER"],
  name: "getCheckContentLengthHeaderPlugin",
  override: true
};
var od = (e) => ({
  applyToStack: (t) => {
    t.add(sd(), id);
  }
});
var ad = (e) => (t, r) => async (n) => {
  const s = await e.region(), i = e.region;
  r.__s3RegionRedirect && (e.region = async () => (e.region = i, r.__s3RegionRedirect));
  const o = await t(n);
  if (r.__s3RegionRedirect) {
    const a = await e.region();
    if (s !== a)
      throw new Error("Region was not restored following S3 region redirect.");
  }
  return o;
};
var cd = {
  tags: ["REGION_REDIRECT", "S3"],
  name: "regionRedirectEndpointMiddleware",
  override: true,
  relation: "before",
  toMiddleware: "endpointV2Middleware"
};
function ud(e) {
  return (t, r) => async (n) => {
    var s, i;
    try {
      return await t(n);
    } catch (o) {
      if (e.followRegionRedirects && ((s = o == null ? void 0 : o.$metadata) == null ? void 0 : s.httpStatusCode) === 301) {
        try {
          const a = o.$response.headers["x-amz-bucket-region"];
          (i = r.logger) == null || i.debug(`Redirecting from ${await e.region()} to ${a}`), r.__s3RegionRedirect = a;
        } catch (a) {
          throw new Error("Region redirect failed: " + a);
        }
        return t(n);
      } else
        throw o;
    }
  };
}
var dd = {
  step: "initialize",
  tags: ["REGION_REDIRECT", "S3"],
  name: "regionRedirectMiddleware",
  override: true
};
var ld = (e) => ({
  applyToStack: (t) => {
    t.add(ud(e), dd), t.addRelativeTo(ad(e), cd);
  }
});
var or = class _or {
  constructor(t = {}) {
    this.data = t, this.lastPurgeTime = Date.now();
  }
  get(t) {
    const r = this.data[t];
    if (r)
      return r;
  }
  set(t, r) {
    return this.data[t] = r, r;
  }
  delete(t) {
    delete this.data[t];
  }
  async purgeExpired() {
    const t = Date.now();
    if (!(this.lastPurgeTime + _or.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS > t))
      for (const r in this.data) {
        const n = this.data[r];
        if (!n.isRefreshing) {
          const s = await n.identity;
          s.expiration && s.expiration.getTime() < t && delete this.data[r];
        }
      }
  }
};
or.EXPIRED_CREDENTIAL_PURGE_INTERVAL_MS = 3e4;
var fr = class {
  constructor(t, r = false, n = Date.now()) {
    this._identity = t, this.isRefreshing = r, this.accessed = n;
  }
  get identity() {
    return this.accessed = Date.now(), this._identity;
  }
};
var ar = class _ar {
  constructor(t, r = new or()) {
    this.createSessionFn = t, this.cache = r;
  }
  async getS3ExpressIdentity(t, r) {
    const n = r.Bucket, { cache: s } = this, i = s.get(n);
    return i ? i.identity.then((o) => {
      var u, l;
      return (((u = o.expiration) == null ? void 0 : u.getTime()) ?? 0) < Date.now() ? s.set(n, new fr(this.getIdentity(n))).identity : ((((l = o.expiration) == null ? void 0 : l.getTime()) ?? 0) < Date.now() + _ar.REFRESH_WINDOW_MS && !i.isRefreshing && (i.isRefreshing = true, this.getIdentity(n).then((h) => {
        s.set(n, new fr(Promise.resolve(h)));
      })), o);
    }) : s.set(n, new fr(this.getIdentity(n))).identity;
  }
  async getIdentity(t) {
    var s, i;
    await this.cache.purgeExpired().catch((o) => {
    });
    const r = await this.createSessionFn(t);
    if (!((s = r.Credentials) != null && s.AccessKeyId) || !((i = r.Credentials) != null && i.SecretAccessKey))
      throw new Error("s3#createSession response credential missing AccessKeyId or SecretAccessKey.");
    return {
      accessKeyId: r.Credentials.AccessKeyId,
      secretAccessKey: r.Credentials.SecretAccessKey,
      sessionToken: r.Credentials.SessionToken,
      expiration: r.Credentials.Expiration ? new Date(r.Credentials.Expiration) : void 0
    };
  }
};
ar.REFRESH_WINDOW_MS = 6e4;
var fd = (e) => e[un] || (e[un] = {});
var ve = (e) => {
  if (typeof e == "function")
    return e;
  const t = Promise.resolve(e);
  return () => t;
};
var hd = "X-Amz-Algorithm";
var pd = "X-Amz-Credential";
var Qo = "X-Amz-Date";
var gd = "X-Amz-SignedHeaders";
var md = "X-Amz-Expires";
var Jo = "X-Amz-Signature";
var ea = "X-Amz-Security-Token";
var ta = "authorization";
var ra = Qo.toLowerCase();
var yd = "date";
var bd = [ta, ra, yd];
var wd = Jo.toLowerCase();
var fn = "x-amz-content-sha256";
var xd = ea.toLowerCase();
var Ed = {
  authorization: true,
  "cache-control": true,
  connection: true,
  expect: true,
  from: true,
  "keep-alive": true,
  "max-forwards": true,
  pragma: true,
  referer: true,
  te: true,
  trailer: true,
  "transfer-encoding": true,
  upgrade: true,
  "user-agent": true,
  "x-amzn-trace-id": true
};
var Ad = /^proxy-/;
var Sd = /^sec-/;
var hr = "AWS4-HMAC-SHA256";
var Cd = "AWS4-HMAC-SHA256-PAYLOAD";
var vd = "UNSIGNED-PAYLOAD";
var Rd = 50;
var na = "aws4_request";
var _d = 60 * 60 * 24 * 7;
var Lt = {};
var pr = [];
var gr = (e, t, r) => `${e}/${t}/${r}/${na}`;
var Td = async (e, t, r, n, s) => {
  const i = await Cs(e, t.secretAccessKey, t.accessKeyId), o = `${r}:${n}:${s}:${he(i)}:${t.sessionToken}`;
  if (o in Lt)
    return Lt[o];
  for (pr.push(o); pr.length > Rd; )
    delete Lt[pr.shift()];
  let a = `AWS4${t.secretAccessKey}`;
  for (const c2 of [r, n, s, na])
    a = await Cs(e, a, c2);
  return Lt[o] = a;
};
var Cs = (e, t, r) => {
  const n = new e(t);
  return n.update(ot(r)), n.digest();
};
var vs = ({ headers: e }, t, r) => {
  const n = {};
  for (const s of Object.keys(e).sort()) {
    if (e[s] == null)
      continue;
    const i = s.toLowerCase();
    (i in Ed || t != null && t.has(i) || Ad.test(i) || Sd.test(i)) && (!r || r && !r.has(i)) || (n[i] = e[s].trim().replace(/\s+/g, " "));
  }
  return n;
};
var Bd = ({ query: e = {} }) => {
  const t = [], r = {};
  for (const n of Object.keys(e).sort()) {
    if (n.toLowerCase() === wd)
      continue;
    t.push(n);
    const s = e[n];
    typeof s == "string" ? r[n] = `${He(n)}=${He(s)}` : Array.isArray(s) && (r[n] = s.slice(0).reduce((i, o) => i.concat([`${He(n)}=${He(o)}`]), []).sort().join("&"));
  }
  return t.map((n) => r[n]).filter((n) => n).join("&");
};
var sa = (e) => typeof ArrayBuffer == "function" && e instanceof ArrayBuffer || Object.prototype.toString.call(e) === "[object ArrayBuffer]";
var mr = async ({ headers: e, body: t }, r) => {
  for (const n of Object.keys(e))
    if (n.toLowerCase() === fn)
      return e[n];
  if (t == null)
    return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
  if (typeof t == "string" || ArrayBuffer.isView(t) || sa(t)) {
    const n = new r();
    return n.update(ot(t)), he(await n.digest());
  }
  return vd;
};
var kd = class {
  format(t) {
    const r = [];
    for (const i of Object.keys(t)) {
      const o = Qe(i);
      r.push(Uint8Array.from([o.byteLength]), o, this.formatHeaderValue(t[i]));
    }
    const n = new Uint8Array(r.reduce((i, o) => i + o.byteLength, 0));
    let s = 0;
    for (const i of r)
      n.set(i, s), s += i.byteLength;
    return n;
  }
  formatHeaderValue(t) {
    switch (t.type) {
      case "boolean":
        return Uint8Array.from([t.value ? 0 : 1]);
      case "byte":
        return Uint8Array.from([2, t.value]);
      case "short":
        const r = new DataView(new ArrayBuffer(3));
        return r.setUint8(0, 3), r.setInt16(1, t.value, false), new Uint8Array(r.buffer);
      case "integer":
        const n = new DataView(new ArrayBuffer(5));
        return n.setUint8(0, 4), n.setInt32(1, t.value, false), new Uint8Array(n.buffer);
      case "long":
        const s = new Uint8Array(9);
        return s[0] = 5, s.set(t.value.bytes, 1), s;
      case "binary":
        const i = new DataView(new ArrayBuffer(3 + t.value.byteLength));
        i.setUint8(0, 6), i.setUint16(1, t.value.byteLength, false);
        const o = new Uint8Array(i.buffer);
        return o.set(t.value, 3), o;
      case "string":
        const a = Qe(t.value), c2 = new DataView(new ArrayBuffer(3 + a.byteLength));
        c2.setUint8(0, 7), c2.setUint16(1, a.byteLength, false);
        const u = new Uint8Array(c2.buffer);
        return u.set(a, 3), u;
      case "timestamp":
        const l = new Uint8Array(9);
        return l[0] = 8, l.set(Pd.fromNumber(t.value.valueOf()).bytes, 1), l;
      case "uuid":
        if (!Nd.test(t.value))
          throw new Error(`Invalid UUID received: ${t.value}`);
        const h = new Uint8Array(17);
        return h[0] = 9, h.set(zo(t.value.replace(/\-/g, "")), 1), h;
    }
  }
};
var Rs;
(function(e) {
  e[e.boolTrue = 0] = "boolTrue", e[e.boolFalse = 1] = "boolFalse", e[e.byte = 2] = "byte", e[e.short = 3] = "short", e[e.integer = 4] = "integer", e[e.long = 5] = "long", e[e.byteArray = 6] = "byteArray", e[e.string = 7] = "string", e[e.timestamp = 8] = "timestamp", e[e.uuid = 9] = "uuid";
})(Rs || (Rs = {}));
var Nd = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
var Pd = class ia {
  constructor(t) {
    if (this.bytes = t, t.byteLength !== 8)
      throw new Error("Int64 buffers must be exactly 8 bytes");
  }
  static fromNumber(t) {
    if (t > 9223372036854776e3 || t < -9223372036854776e3)
      throw new Error(`${t} is too large (or, if negative, too small) to represent as an Int64`);
    const r = new Uint8Array(8);
    for (let n = 7, s = Math.abs(Math.round(t)); n > -1 && s > 0; n--, s /= 256)
      r[n] = s;
    return t < 0 && _s(r), new ia(r);
  }
  valueOf() {
    const t = this.bytes.slice(0), r = t[0] & 128;
    return r && _s(t), parseInt(he(t), 16) * (r ? -1 : 1);
  }
  toString() {
    return String(this.valueOf());
  }
};
function _s(e) {
  for (let t = 0; t < 8; t++)
    e[t] ^= 255;
  for (let t = 7; t > -1 && (e[t]++, e[t] === 0); t--)
    ;
}
var Od = (e, t) => {
  e = e.toLowerCase();
  for (const r of Object.keys(t))
    if (e === r.toLowerCase())
      return true;
  return false;
};
var oa = ({ headers: e, query: t, ...r }) => ({
  ...r,
  headers: { ...e },
  query: t ? Md(t) : void 0
});
var Md = (e) => Object.keys(e).reduce((t, r) => {
  const n = e[r];
  return {
    ...t,
    [r]: Array.isArray(n) ? [...n] : n
  };
}, {});
var Id = (e, t = {}) => {
  var s;
  const { headers: r, query: n = {} } = typeof e.clone == "function" ? e.clone() : oa(e);
  for (const i of Object.keys(r)) {
    const o = i.toLowerCase();
    o.slice(0, 6) === "x-amz-" && !((s = t.unhoistableHeaders) != null && s.has(o)) && (n[i] = r[i], delete r[i]);
  }
  return {
    ...e,
    headers: r,
    query: n
  };
};
var Ts = (e) => {
  e = typeof e.clone == "function" ? e.clone() : oa(e);
  for (const t of Object.keys(e.headers))
    bd.indexOf(t.toLowerCase()) > -1 && delete e.headers[t];
  return e;
};
var Fd = (e) => Dd(e).toISOString().replace(/\.\d{3}Z$/, "Z");
var Dd = (e) => typeof e == "number" ? new Date(e * 1e3) : typeof e == "string" ? Number(e) ? new Date(Number(e) * 1e3) : new Date(e) : e;
var hn = class {
  constructor({ applyChecksum: t, credentials: r, region: n, service: s, sha256: i, uriEscapePath: o = true }) {
    this.headerFormatter = new kd(), this.service = s, this.sha256 = i, this.uriEscapePath = o, this.applyChecksum = typeof t == "boolean" ? t : true, this.regionProvider = ve(n), this.credentialProvider = ve(r);
  }
  async presign(t, r = {}) {
    const { signingDate: n = /* @__PURE__ */ new Date(), expiresIn: s = 3600, unsignableHeaders: i, unhoistableHeaders: o, signableHeaders: a, signingRegion: c2, signingService: u } = r, l = await this.credentialProvider();
    this.validateResolvedCredentials(l);
    const h = c2 ?? await this.regionProvider(), { longDate: p, shortDate: g } = Ht(n);
    if (s > _d)
      return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
    const b = gr(g, h, u ?? this.service), A = Id(Ts(t), { unhoistableHeaders: o });
    l.sessionToken && (A.query[ea] = l.sessionToken), A.query[hd] = hr, A.query[pd] = `${l.accessKeyId}/${b}`, A.query[Qo] = p, A.query[md] = s.toString(10);
    const R = vs(A, i, a);
    return A.query[gd] = Bs(R), A.query[Jo] = await this.getSignature(p, b, this.getSigningKey(l, h, g, u), this.createCanonicalRequest(A, R, await mr(t, this.sha256))), A;
  }
  async sign(t, r) {
    return typeof t == "string" ? this.signString(t, r) : t.headers && t.payload ? this.signEvent(t, r) : t.message ? this.signMessage(t, r) : this.signRequest(t, r);
  }
  async signEvent({ headers: t, payload: r }, { signingDate: n = /* @__PURE__ */ new Date(), priorSignature: s, signingRegion: i, signingService: o }) {
    const a = i ?? await this.regionProvider(), { shortDate: c2, longDate: u } = Ht(n), l = gr(c2, a, o ?? this.service), h = await mr({ headers: {}, body: r }, this.sha256), p = new this.sha256();
    p.update(t);
    const g = he(await p.digest()), b = [
      Cd,
      u,
      l,
      s,
      g,
      h
    ].join(`
`);
    return this.signString(b, { signingDate: n, signingRegion: a, signingService: o });
  }
  async signMessage(t, { signingDate: r = /* @__PURE__ */ new Date(), signingRegion: n, signingService: s }) {
    return this.signEvent({
      headers: this.headerFormatter.format(t.message.headers),
      payload: t.message.body
    }, {
      signingDate: r,
      signingRegion: n,
      signingService: s,
      priorSignature: t.priorSignature
    }).then((o) => ({ message: t.message, signature: o }));
  }
  async signString(t, { signingDate: r = /* @__PURE__ */ new Date(), signingRegion: n, signingService: s } = {}) {
    const i = await this.credentialProvider();
    this.validateResolvedCredentials(i);
    const o = n ?? await this.regionProvider(), { shortDate: a } = Ht(r), c2 = new this.sha256(await this.getSigningKey(i, o, a, s));
    return c2.update(ot(t)), he(await c2.digest());
  }
  async signRequest(t, { signingDate: r = /* @__PURE__ */ new Date(), signableHeaders: n, unsignableHeaders: s, signingRegion: i, signingService: o } = {}) {
    const a = await this.credentialProvider();
    this.validateResolvedCredentials(a);
    const c2 = i ?? await this.regionProvider(), u = Ts(t), { longDate: l, shortDate: h } = Ht(r), p = gr(h, c2, o ?? this.service);
    u.headers[ra] = l, a.sessionToken && (u.headers[xd] = a.sessionToken);
    const g = await mr(u, this.sha256);
    !Od(fn, u.headers) && this.applyChecksum && (u.headers[fn] = g);
    const b = vs(u, s, n), A = await this.getSignature(l, p, this.getSigningKey(a, c2, h, o), this.createCanonicalRequest(u, b, g));
    return u.headers[ta] = `${hr} Credential=${a.accessKeyId}/${p}, SignedHeaders=${Bs(b)}, Signature=${A}`, u;
  }
  createCanonicalRequest(t, r, n) {
    const s = Object.keys(r).sort();
    return `${t.method}
${this.getCanonicalPath(t)}
${Bd(t)}
${s.map((i) => `${i}:${r[i]}`).join(`
`)}

${s.join(";")}
${n}`;
  }
  async createStringToSign(t, r, n) {
    const s = new this.sha256();
    s.update(ot(n));
    const i = await s.digest();
    return `${hr}
${t}
${r}
${he(i)}`;
  }
  getCanonicalPath({ path: t }) {
    if (this.uriEscapePath) {
      const r = [];
      for (const i of t.split("/"))
        (i == null ? void 0 : i.length) !== 0 && i !== "." && (i === ".." ? r.pop() : r.push(i));
      const n = `${t != null && t.startsWith("/") ? "/" : ""}${r.join("/")}${r.length > 0 && (t != null && t.endsWith("/")) ? "/" : ""}`;
      return He(n).replace(/%2F/g, "/");
    }
    return t;
  }
  async getSignature(t, r, n, s) {
    const i = await this.createStringToSign(t, r, s), o = new this.sha256(await n);
    return o.update(ot(i)), he(await o.digest());
  }
  getSigningKey(t, r, n, s) {
    return Td(this.sha256, t, n, r, s || this.service);
  }
  validateResolvedCredentials(t) {
    if (typeof t != "object" || typeof t.accessKeyId != "string" || typeof t.secretAccessKey != "string")
      throw new Error("Resolved credential object is not valid");
  }
};
var Ht = (e) => {
  const t = Fd(e).replace(/[\-:]/g, "");
  return {
    longDate: t,
    shortDate: t.slice(0, 8)
  };
};
var Bs = (e) => Object.keys(e).sort().join(";");
var ks;
(function(e) {
  e.ENV = "env", e.CONFIG = "shared config entry";
})(ks || (ks = {}));
var Ud = "Directory";
var $d = "S3Express";
var Ld = "sigv4-s3express";
var pn = "X-Amz-S3session-Token";
var gn = pn.toLowerCase();
var Hd = class extends hn {
  async signWithCredentials(t, r, n) {
    const s = Ns(r);
    t.headers[gn] = r.sessionToken;
    const i = this;
    return Ps(i, s), i.signRequest(t, n ?? {});
  }
  async presignWithCredentials(t, r, n) {
    const s = Ns(r);
    return delete t.headers[gn], t.headers[pn] = r.sessionToken, t.query = t.query ?? {}, t.query[pn] = r.sessionToken, Ps(this, s), this.presign(t, n);
  }
};
function Ns(e) {
  return {
    accessKeyId: e.accessKeyId,
    secretAccessKey: e.secretAccessKey,
    expiration: e.expiration
  };
}
function Ps(e, t) {
  const r = setTimeout(() => {
    throw new Error("SignatureV4S3Express credential override was created but not called.");
  }, 10), n = e.credentialProvider, s = () => (clearTimeout(r), e.credentialProvider = n, Promise.resolve(t));
  e.credentialProvider = s;
}
var jd = (e) => (t, r) => async (n) => {
  var s, i, o, a, c2;
  if (r.endpointV2) {
    const u = r.endpointV2, l = ((o = (i = (s = u.properties) == null ? void 0 : s.authSchemes) == null ? void 0 : i[0]) == null ? void 0 : o.name) === Ld;
    if ((((a = u.properties) == null ? void 0 : a.backend) === $d || ((c2 = u.properties) == null ? void 0 : c2.bucketType) === Ud) && (r.isS3ExpressBucket = true), l) {
      const p = n.input.Bucket;
      if (p) {
        const g = await e.s3ExpressIdentityProvider.getS3ExpressIdentity(await e.credentials(), {
          Bucket: p
        });
        r.s3ExpressIdentity = g, ge.isInstance(n.request) && g.sessionToken && (n.request.headers[gn] = g.sessionToken);
      }
    }
  }
  return t(n);
};
var zd = {
  name: "s3ExpressMiddleware",
  step: "build",
  tags: ["S3", "S3_EXPRESS"],
  override: true
};
var qd = (e) => ({
  applyToStack: (t) => {
    t.add(jd(e), zd);
  }
});
var Wd = (e, { session: t }) => {
  const [r, n] = t;
  return {
    ...e,
    forcePathStyle: e.forcePathStyle ?? false,
    useAccelerateEndpoint: e.useAccelerateEndpoint ?? false,
    disableMultiregionAccessPoints: e.disableMultiregionAccessPoints ?? false,
    followRegionRedirects: e.followRegionRedirects ?? false,
    s3ExpressIdentityProvider: e.s3ExpressIdentityProvider ?? new ar(async (s) => r().send(new n({
      Bucket: s,
      SessionMode: "ReadWrite"
    }))),
    bucketEndpoint: e.bucketEndpoint ?? false
  };
};
var Gd = (e) => typeof e == "string" && e.indexOf("arn:") === 0 && e.split(":").length >= 6;
function Vd(e) {
  return (t, r) => async (n) => {
    var s, i, o, a;
    if (e.bucketEndpoint) {
      const c2 = r.endpointV2;
      if (c2) {
        const u = n.input.Bucket;
        if (typeof u == "string")
          try {
            const l = new URL(u);
            c2.url = l;
          } catch (l) {
            const h = `@aws-sdk/middleware-sdk-s3: bucketEndpoint=true was set but Bucket=${u} could not be parsed as URL.`;
            throw ((i = (s = r.logger) == null ? void 0 : s.constructor) == null ? void 0 : i.name) === "NoOpLogger" || (a = (o = r.logger) == null ? void 0 : o.warn) == null || a.call(o, h), l;
          }
      }
    }
    return t(n);
  };
}
var Kd = {
  name: "bucketEndpointMiddleware",
  override: true,
  relation: "after",
  toMiddleware: "endpointV2Middleware"
};
function Xd({ bucketEndpoint: e }) {
  return (t) => async (r) => {
    const { input: { Bucket: n } } = r;
    if (!e && typeof n == "string" && !Gd(n) && n.indexOf("/") >= 0) {
      const s = new Error(`Bucket name shouldn't contain '/', received '${n}'`);
      throw s.name = "InvalidBucketName", s;
    }
    return t({ ...r });
  };
}
var Zd = {
  step: "initialize",
  tags: ["VALIDATE_BUCKET_NAME"],
  name: "validateBucketNameMiddleware",
  override: true
};
var Yd = (e) => ({
  applyToStack: (t) => {
    t.add(Xd(e), Zd), t.addRelativeTo(Vd(e), Kd);
  }
});
var aa = (e, t, r) => {
  let n, s, i, o = false;
  const a = async () => {
    s || (s = e());
    try {
      n = await s, i = true, o = false;
    } finally {
      s = void 0;
    }
    return n;
  };
  return t === void 0 ? async (c2) => ((!i || c2 != null && c2.forceRefresh) && (n = await a()), n) : async (c2) => ((!i || c2 != null && c2.forceRefresh) && (n = await a()), o ? n : r && !r(n) ? (o = true, n) : (t(n) && await a(), n));
};
var Qd = 3e5;
var Jd = (e) => {
  const t = e.credentials ? el(e.credentials) : e.credentialDefaultProvider(Object.assign({}, e, {
    parentClientConfig: e
  })), { signingEscapePath: r = true, systemClockOffset: n = e.systemClockOffset || 0, sha256: s } = e;
  let i;
  return e.signer ? i = ve(e.signer) : e.regionInfoProvider ? i = () => ve(e.region)().then(async (o) => [
    await e.regionInfoProvider(o, {
      useFipsEndpoint: await e.useFipsEndpoint(),
      useDualstackEndpoint: await e.useDualstackEndpoint()
    }) || {},
    o
  ]).then(([o, a]) => {
    const { signingRegion: c2, signingService: u } = o;
    e.signingRegion = e.signingRegion || c2 || a, e.signingName = e.signingName || u || e.serviceId;
    const l = {
      ...e,
      credentials: t,
      region: e.signingRegion,
      service: e.signingName,
      sha256: s,
      uriEscapePath: r
    }, h = e.signerConstructor || hn;
    return new h(l);
  }) : i = async (o) => {
    o = Object.assign({}, {
      name: "sigv4",
      signingName: e.signingName || e.defaultSigningName,
      signingRegion: await ve(e.region)(),
      properties: {}
    }, o);
    const a = (o == null ? void 0 : o.name) === "sigv4a", c2 = o.signingRegion, u = o.signingName;
    let l;
    a ? l = e.signingRegion || c2 : (e.signingRegion = e.signingRegion || c2, l = e.signingRegion), e.signingName = e.signingName || u || e.serviceId;
    const h = {
      ...e,
      credentials: t,
      region: l,
      service: e.signingName,
      sha256: s,
      uriEscapePath: r
    }, p = e.signerConstructor || hn;
    return new p(h);
  }, {
    ...e,
    systemClockOffset: n,
    signingEscapePath: r,
    credentials: t,
    signer: i
  };
};
var el = (e) => typeof e == "function" ? aa(e, (t) => t.expiration !== void 0 && t.expiration.getTime() - Date.now() < Qd, (t) => t.expiration !== void 0) : ve(e);
var ca = (e) => new Date(Date.now() + e);
var tl = (e, t) => Math.abs(ca(t).getTime() - e) >= 3e5;
var Os = (e, t) => {
  const r = Date.parse(e);
  return tl(r, t) ? r - Date.now() : t;
};
var rl = (e) => (t, r) => async function(n) {
  var b, A, R, T, I, $, X;
  if (!ge.isInstance(n.request))
    return t(n);
  let s, i;
  const o = (R = (A = (b = r.endpointV2) == null ? void 0 : b.properties) == null ? void 0 : A.authSchemes) == null ? void 0 : R[0], a = ($ = (I = (T = r.endpointV2) == null ? void 0 : T.properties) == null ? void 0 : I.authSchemes) == null ? void 0 : $[1];
  if ((o == null ? void 0 : o.name) === "sigv4a" && a) {
    i = await e.signer(s = o);
    const Z = i;
    (() => {
      var et;
      if (typeof (Z == null ? void 0 : Z.getSigv4aSigner) == "function") {
        if (((et = Z == null ? void 0 : Z.signerOptions) == null ? void 0 : et.runtime) !== "node")
          return false;
        try {
          return Z.getSigv4aSigner(), true;
        } catch {
        }
      }
      return false;
    })() || (i = await e.signer(s = a));
  } else
    i = await e.signer(s = o);
  let u;
  const l = (s == null ? void 0 : s.name) === "sigv4a" ? (X = s == null ? void 0 : s.signingRegionSet) == null ? void 0 : X.join(",") : void 0, h = {
    signingDate: ca(e.systemClockOffset),
    signingRegion: l || r.signing_region,
    signingService: r.signing_service
  };
  if (r.s3ExpressIdentity) {
    if (u = await i.signWithCredentials(n.request, r.s3ExpressIdentity, h), u.headers["X-Amz-Security-Token"] || u.headers["x-amz-security-token"])
      throw new Error("X-Amz-Security-Token must not be set for s3-express requests.");
  } else
    u = await i.sign(n.request, h);
  const p = await t({
    ...n,
    request: u
  }).catch((Z) => {
    const Oe = Z.ServerTime ?? Ms(Z.$response);
    throw Oe && (e.systemClockOffset = Os(Oe, e.systemClockOffset)), Z;
  }), g = Ms(p.response);
  return g && (e.systemClockOffset = Os(g, e.systemClockOffset)), p;
};
var Ms = (e) => {
  var t, r;
  return Qt.isInstance(e) ? ((t = e.headers) == null ? void 0 : t.date) ?? ((r = e.headers) == null ? void 0 : r.Date) : void 0;
};
var nl = {
  name: "awsAuthMiddleware",
  tags: ["SIGNATURE", "AWSAUTH"],
  relation: "after",
  toMiddleware: "retryMiddleware",
  override: true
};
var sl = (e) => ({
  applyToStack: (t) => {
    t.addRelativeTo(rl(e), nl);
  }
});
function il(e) {
  return {
    ...e,
    customUserAgent: typeof e.customUserAgent == "string" ? [[e.customUserAgent]] : e.customUserAgent
  };
}
var ol = new RegExp("^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$");
var ua = (e) => ol.test(e) || e.startsWith("[") && e.endsWith("]");
var al = new RegExp("^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$");
var Fn = (e, t = false) => {
  if (!t)
    return al.test(e);
  const r = e.split(".");
  for (const n of r)
    if (!Fn(n))
      return false;
  return true;
};
var er = {};
var Dt = "endpoints";
function ze(e) {
  return typeof e != "object" || e == null ? e : "ref" in e ? `$${ze(e.ref)}` : "fn" in e ? `${e.fn}(${(e.argv || []).map(ze).join(", ")})` : JSON.stringify(e, null, 2);
}
var ye = class extends Error {
  constructor(t) {
    super(t), this.name = "EndpointError";
  }
};
var cl = (e, t) => e === t;
var ul = (e) => {
  const t = e.split("."), r = [];
  for (const n of t) {
    const s = n.indexOf("[");
    if (s !== -1) {
      if (n.indexOf("]") !== n.length - 1)
        throw new ye(`Path: '${e}' does not end with ']'`);
      const i = n.slice(s + 1, -1);
      if (Number.isNaN(parseInt(i)))
        throw new ye(`Invalid array index: '${i}' in path: '${e}'`);
      s !== 0 && r.push(n.slice(0, s)), r.push(i);
    } else
      r.push(n);
  }
  return r;
};
var da = (e, t) => ul(t).reduce((r, n) => {
  if (typeof r != "object")
    throw new ye(`Index '${n}' in '${t}' not found in '${JSON.stringify(e)}'`);
  return Array.isArray(r) ? r[parseInt(n)] : r[n];
}, e);
var dl = (e) => e != null;
var ll = (e) => !e;
var yr = {
  [Ft.HTTP]: 80,
  [Ft.HTTPS]: 443
};
var fl = (e) => {
  const t = (() => {
    try {
      if (e instanceof URL)
        return e;
      if (typeof e == "object" && "hostname" in e) {
        const { hostname: p, port: g, protocol: b = "", path: A = "", query: R = {} } = e, T = new URL(`${b}//${p}${g ? `:${g}` : ""}${A}`);
        return T.search = Object.entries(R).map(([I, $]) => `${I}=${$}`).join("&"), T;
      }
      return new URL(e);
    } catch {
      return null;
    }
  })();
  if (!t)
    return null;
  const r = t.href, { host: n, hostname: s, pathname: i, protocol: o, search: a } = t;
  if (a)
    return null;
  const c2 = o.slice(0, -1);
  if (!Object.values(Ft).includes(c2))
    return null;
  const u = ua(s), l = r.includes(`${n}:${yr[c2]}`) || typeof e == "string" && e.includes(`${n}:${yr[c2]}`), h = `${n}${l ? `:${yr[c2]}` : ""}`;
  return {
    scheme: c2,
    authority: h,
    path: i,
    normalizedPath: i.endsWith("/") ? i : `${i}/`,
    isIp: u
  };
};
var hl = (e, t) => e === t;
var pl = (e, t, r, n) => t >= r || e.length < r ? null : n ? e.substring(e.length - r, e.length - t) : e.substring(t, r);
var gl = (e) => encodeURIComponent(e).replace(/[!*'()]/g, (t) => `%${t.charCodeAt(0).toString(16).toUpperCase()}`);
var ml = {
  booleanEquals: cl,
  getAttr: da,
  isSet: dl,
  isValidHostLabel: Fn,
  not: ll,
  parseURL: fl,
  stringEquals: hl,
  substring: pl,
  uriEncode: gl
};
var la = (e, t) => {
  const r = [], n = {
    ...t.endpointParams,
    ...t.referenceRecord
  };
  let s = 0;
  for (; s < e.length; ) {
    const i = e.indexOf("{", s);
    if (i === -1) {
      r.push(e.slice(s));
      break;
    }
    r.push(e.slice(s, i));
    const o = e.indexOf("}", i);
    if (o === -1) {
      r.push(e.slice(i));
      break;
    }
    e[i + 1] === "{" && e[o + 1] === "}" && (r.push(e.slice(i + 1, o)), s = o + 2);
    const a = e.substring(i + 1, o);
    if (a.includes("#")) {
      const [c2, u] = a.split("#");
      r.push(da(n[c2], u));
    } else
      r.push(n[a]);
    s = o + 1;
  }
  return r.join("");
};
var yl = ({ ref: e }, t) => ({
  ...t.endpointParams,
  ...t.referenceRecord
})[e];
var cr = (e, t, r) => {
  if (typeof e == "string")
    return la(e, r);
  if (e.fn)
    return fa(e, r);
  if (e.ref)
    return yl(e, r);
  throw new ye(`'${t}': ${String(e)} is not a string, function or reference.`);
};
var fa = ({ fn: e, argv: t }, r) => {
  const n = t.map((i) => ["boolean", "number"].includes(typeof i) ? i : cr(i, "arg", r)), s = e.split(".");
  return s[0] in er && s[1] != null ? er[s[0]][s[1]](...n) : ml[e](...n);
};
var bl = ({ assign: e, ...t }, r) => {
  var s, i;
  if (e && e in r.referenceRecord)
    throw new ye(`'${e}' is already defined in Reference Record.`);
  const n = fa(t, r);
  return (i = (s = r.logger) == null ? void 0 : s.debug) == null || i.call(s, `${Dt} evaluateCondition: ${ze(t)} = ${ze(n)}`), {
    result: n === "" ? true : !!n,
    ...e != null && { toAssign: { name: e, value: n } }
  };
};
var Dn = (e = [], t) => {
  var n, s;
  const r = {};
  for (const i of e) {
    const { result: o, toAssign: a } = bl(i, {
      ...t,
      referenceRecord: {
        ...t.referenceRecord,
        ...r
      }
    });
    if (!o)
      return { result: o };
    a && (r[a.name] = a.value, (s = (n = t.logger) == null ? void 0 : n.debug) == null || s.call(n, `${Dt} assign: ${a.name} := ${ze(a.value)}`));
  }
  return { result: true, referenceRecord: r };
};
var wl = (e, t) => Object.entries(e).reduce((r, [n, s]) => ({
  ...r,
  [n]: s.map((i) => {
    const o = cr(i, "Header value entry", t);
    if (typeof o != "string")
      throw new ye(`Header '${n}' value '${o}' is not a string`);
    return o;
  })
}), {});
var ha = (e, t) => {
  if (Array.isArray(e))
    return e.map((r) => ha(r, t));
  switch (typeof e) {
    case "string":
      return la(e, t);
    case "object":
      if (e === null)
        throw new ye(`Unexpected endpoint property: ${e}`);
      return pa(e, t);
    case "boolean":
      return e;
    default:
      throw new ye(`Unexpected endpoint property type: ${typeof e}`);
  }
};
var pa = (e, t) => Object.entries(e).reduce((r, [n, s]) => ({
  ...r,
  [n]: ha(s, t)
}), {});
var xl = (e, t) => {
  const r = cr(e, "Endpoint URL", t);
  if (typeof r == "string")
    try {
      return new URL(r);
    } catch (n) {
      throw n;
    }
  throw new ye(`Endpoint URL must be a string, got ${typeof r}`);
};
var El = (e, t) => {
  var l, h;
  const { conditions: r, endpoint: n } = e, { result: s, referenceRecord: i } = Dn(r, t);
  if (!s)
    return;
  const o = {
    ...t,
    referenceRecord: { ...t.referenceRecord, ...i }
  }, { url: a, properties: c2, headers: u } = n;
  return (h = (l = t.logger) == null ? void 0 : l.debug) == null || h.call(l, `${Dt} Resolving endpoint from template: ${ze(n)}`), {
    ...u != null && {
      headers: wl(u, o)
    },
    ...c2 != null && {
      properties: pa(c2, o)
    },
    url: xl(a, o)
  };
};
var Al = (e, t) => {
  const { conditions: r, error: n } = e, { result: s, referenceRecord: i } = Dn(r, t);
  if (s)
    throw new ye(cr(n, "Error", {
      ...t,
      referenceRecord: { ...t.referenceRecord, ...i }
    }));
};
var Sl = (e, t) => {
  const { conditions: r, rules: n } = e, { result: s, referenceRecord: i } = Dn(r, t);
  if (s)
    return ga(n, {
      ...t,
      referenceRecord: { ...t.referenceRecord, ...i }
    });
};
var ga = (e, t) => {
  for (const r of e)
    if (r.type === "endpoint") {
      const n = El(r, t);
      if (n)
        return n;
    } else if (r.type === "error")
      Al(r, t);
    else if (r.type === "tree") {
      const n = Sl(r, t);
      if (n)
        return n;
    } else
      throw new ye(`Unknown endpoint rule: ${r}`);
  throw new ye("Rules evaluation failed");
};
var Cl = (e, t) => {
  var u, l, h, p, g;
  const { endpointParams: r, logger: n } = t, { parameters: s, rules: i } = e;
  (l = (u = t.logger) == null ? void 0 : u.debug) == null || l.call(u, `${Dt} Initial EndpointParams: ${ze(r)}`);
  const o = Object.entries(s).filter(([, b]) => b.default != null).map(([b, A]) => [b, A.default]);
  if (o.length > 0)
    for (const [b, A] of o)
      r[b] = r[b] ?? A;
  const a = Object.entries(s).filter(([, b]) => b.required).map(([b]) => b);
  for (const b of a)
    if (r[b] == null)
      throw new ye(`Missing required parameter: '${b}'`);
  const c2 = ga(i, { endpointParams: r, logger: n, referenceRecord: {} });
  if ((h = t.endpointParams) != null && h.Endpoint)
    try {
      const b = new URL(t.endpointParams.Endpoint), { protocol: A, port: R } = b;
      c2.url.protocol = A, c2.url.port = R;
    } catch {
    }
  return (g = (p = t.logger) == null ? void 0 : p.debug) == null || g.call(p, `${Dt} Resolved endpoint: ${ze(c2)}`), c2;
};
var ma = (e, t = false) => {
  if (t) {
    for (const r of e.split("."))
      if (!ma(r))
        return false;
    return true;
  }
  return !(!Fn(e) || e.length < 3 || e.length > 63 || e !== e.toLowerCase() || ua(e));
};
var vl = (e) => {
  const t = e.split(":");
  if (t.length < 6)
    return null;
  const [r, n, s, i, o, ...a] = t;
  return r !== "arn" || n === "" || s === "" || a[0] === "" ? null : {
    partition: n,
    service: s,
    region: i,
    accountId: o,
    resourceId: a[0].includes("/") ? a[0].split("/") : a
  };
};
var Rl = [
  {
    id: "aws",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      implicitGlobalRegion: "us-east-1",
      name: "aws",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^(us|eu|ap|sa|ca|me|af|il)\\-\\w+\\-\\d+$",
    regions: {
      "af-south-1": {
        description: "Africa (Cape Town)"
      },
      "ap-east-1": {
        description: "Asia Pacific (Hong Kong)"
      },
      "ap-northeast-1": {
        description: "Asia Pacific (Tokyo)"
      },
      "ap-northeast-2": {
        description: "Asia Pacific (Seoul)"
      },
      "ap-northeast-3": {
        description: "Asia Pacific (Osaka)"
      },
      "ap-south-1": {
        description: "Asia Pacific (Mumbai)"
      },
      "ap-south-2": {
        description: "Asia Pacific (Hyderabad)"
      },
      "ap-southeast-1": {
        description: "Asia Pacific (Singapore)"
      },
      "ap-southeast-2": {
        description: "Asia Pacific (Sydney)"
      },
      "ap-southeast-3": {
        description: "Asia Pacific (Jakarta)"
      },
      "ap-southeast-4": {
        description: "Asia Pacific (Melbourne)"
      },
      "aws-global": {
        description: "AWS Standard global region"
      },
      "ca-central-1": {
        description: "Canada (Central)"
      },
      "ca-west-1": {
        description: "Canada West (Calgary)"
      },
      "eu-central-1": {
        description: "Europe (Frankfurt)"
      },
      "eu-central-2": {
        description: "Europe (Zurich)"
      },
      "eu-north-1": {
        description: "Europe (Stockholm)"
      },
      "eu-south-1": {
        description: "Europe (Milan)"
      },
      "eu-south-2": {
        description: "Europe (Spain)"
      },
      "eu-west-1": {
        description: "Europe (Ireland)"
      },
      "eu-west-2": {
        description: "Europe (London)"
      },
      "eu-west-3": {
        description: "Europe (Paris)"
      },
      "il-central-1": {
        description: "Israel (Tel Aviv)"
      },
      "me-central-1": {
        description: "Middle East (UAE)"
      },
      "me-south-1": {
        description: "Middle East (Bahrain)"
      },
      "sa-east-1": {
        description: "South America (Sao Paulo)"
      },
      "us-east-1": {
        description: "US East (N. Virginia)"
      },
      "us-east-2": {
        description: "US East (Ohio)"
      },
      "us-west-1": {
        description: "US West (N. California)"
      },
      "us-west-2": {
        description: "US West (Oregon)"
      }
    }
  },
  {
    id: "aws-cn",
    outputs: {
      dnsSuffix: "amazonaws.com.cn",
      dualStackDnsSuffix: "api.amazonwebservices.com.cn",
      implicitGlobalRegion: "cn-northwest-1",
      name: "aws-cn",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^cn\\-\\w+\\-\\d+$",
    regions: {
      "aws-cn-global": {
        description: "AWS China global region"
      },
      "cn-north-1": {
        description: "China (Beijing)"
      },
      "cn-northwest-1": {
        description: "China (Ningxia)"
      }
    }
  },
  {
    id: "aws-us-gov",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      implicitGlobalRegion: "us-gov-west-1",
      name: "aws-us-gov",
      supportsDualStack: true,
      supportsFIPS: true
    },
    regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
    regions: {
      "aws-us-gov-global": {
        description: "AWS GovCloud (US) global region"
      },
      "us-gov-east-1": {
        description: "AWS GovCloud (US-East)"
      },
      "us-gov-west-1": {
        description: "AWS GovCloud (US-West)"
      }
    }
  },
  {
    id: "aws-iso",
    outputs: {
      dnsSuffix: "c2s.ic.gov",
      dualStackDnsSuffix: "c2s.ic.gov",
      implicitGlobalRegion: "us-iso-east-1",
      name: "aws-iso",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-global": {
        description: "AWS ISO (US) global region"
      },
      "us-iso-east-1": {
        description: "US ISO East"
      },
      "us-iso-west-1": {
        description: "US ISO WEST"
      }
    }
  },
  {
    id: "aws-iso-b",
    outputs: {
      dnsSuffix: "sc2s.sgov.gov",
      dualStackDnsSuffix: "sc2s.sgov.gov",
      implicitGlobalRegion: "us-isob-east-1",
      name: "aws-iso-b",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-b-global": {
        description: "AWS ISOB (US) global region"
      },
      "us-isob-east-1": {
        description: "US ISOB East (Ohio)"
      }
    }
  },
  {
    id: "aws-iso-e",
    outputs: {
      dnsSuffix: "cloud.adc-e.uk",
      dualStackDnsSuffix: "cloud.adc-e.uk",
      implicitGlobalRegion: "eu-isoe-west-1",
      name: "aws-iso-e",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
    regions: {
      "eu-isoe-west-1": {
        description: "EU ISOE West"
      }
    }
  },
  {
    id: "aws-iso-f",
    outputs: {
      dnsSuffix: "csp.hci.ic.gov",
      dualStackDnsSuffix: "csp.hci.ic.gov",
      implicitGlobalRegion: "us-isof-south-1",
      name: "aws-iso-f",
      supportsDualStack: false,
      supportsFIPS: true
    },
    regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
    regions: {}
  }
];
var _l = "1.1";
var Tl = {
  partitions: Rl,
  version: _l
};
var Bl = Tl;
var kl = (e) => {
  const { partitions: t } = Bl;
  for (const n of t) {
    const { regions: s, outputs: i } = n;
    for (const [o, a] of Object.entries(s))
      if (o === e)
        return {
          ...i,
          ...a
        };
  }
  for (const n of t) {
    const { regionRegex: s, outputs: i } = n;
    if (new RegExp(s).test(e))
      return {
        ...i
      };
  }
  const r = t.find((n) => n.id === "aws");
  if (!r)
    throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
  return {
    ...r.outputs
  };
};
var ya = {
  isVirtualHostableS3Bucket: ma,
  parseArn: vl,
  partition: kl
};
er.aws = ya;
var Is = "user-agent";
var br = "x-amz-user-agent";
var Fs = " ";
var wr = "/";
var Nl = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
var Pl = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;
var Ds = "-";
var Ol = (e) => (t, r) => async (n) => {
  var h, p;
  const { request: s } = n;
  if (!ge.isInstance(s))
    return t(n);
  const { headers: i } = s, o = ((h = r == null ? void 0 : r.userAgent) == null ? void 0 : h.map(xr)) || [], a = (await e.defaultUserAgentProvider()).map(xr), c2 = ((p = e == null ? void 0 : e.customUserAgent) == null ? void 0 : p.map(xr)) || [], u = [].concat([...a, ...o, ...c2]).join(Fs), l = [
    ...a.filter((g) => g.startsWith("aws-sdk-")),
    ...c2
  ].join(Fs);
  return e.runtime !== "browser" ? (l && (i[br] = i[br] ? `${i[Is]} ${l}` : l), i[Is] = u) : i[br] = u, t({
    ...n,
    request: s
  });
};
var xr = (e) => {
  var o;
  const t = e[0].split(wr).map((a) => a.replace(Nl, Ds)).join(wr), r = (o = e[1]) == null ? void 0 : o.replace(Pl, Ds), n = t.indexOf(wr), s = t.substring(0, n);
  let i = t.substring(n + 1);
  return s === "api" && (i = i.toLowerCase()), [s, i, r].filter((a) => a && a.length > 0).reduce((a, c2, u) => {
    switch (u) {
      case 0:
        return c2;
      case 1:
        return `${a}/${c2}`;
      default:
        return `${a}#${c2}`;
    }
  }, "");
};
var Ml = {
  name: "getUserAgentMiddleware",
  step: "build",
  priority: "low",
  tags: ["SET_USER_AGENT", "USER_AGENT"],
  override: true
};
var Il = (e) => ({
  applyToStack: (t) => {
    t.add(Ol(e), Ml);
  }
});
var Fl = false;
var Dl = false;
var ba = (e) => typeof e == "string" && (e.startsWith("fips-") || e.endsWith("-fips"));
var Us = (e) => ba(e) ? ["fips-aws-global", "aws-fips"].includes(e) ? "us-east-1" : e.replace(/fips-(dkr-|prod-)?|-fips/, "") : e;
var Ul = (e) => {
  const { region: t, useFipsEndpoint: r } = e;
  if (!t)
    throw new Error("Region is missing");
  return {
    ...e,
    region: async () => {
      if (typeof t == "string")
        return Us(t);
      const n = await t();
      return Us(n);
    },
    useFipsEndpoint: async () => {
      const n = typeof t == "string" ? t : await t();
      return ba(n) ? true : typeof r != "function" ? Promise.resolve(!!r) : r();
    }
  };
};
var $l = (e) => ({
  ...e,
  eventStreamMarshaller: e.eventStreamSerdeProvider(e)
});
var $s = "content-length";
function Ll(e) {
  return (t) => async (r) => {
    const n = r.request;
    if (ge.isInstance(n)) {
      const { body: s, headers: i } = n;
      if (s && Object.keys(i).map((o) => o.toLowerCase()).indexOf($s) === -1)
        try {
          const o = e(s);
          n.headers = {
            ...n.headers,
            [$s]: String(o)
          };
        } catch {
        }
    }
    return t({
      ...r,
      request: n
    });
  };
}
var Hl = {
  step: "build",
  tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
  name: "contentLengthMiddleware",
  override: true
};
var jl = (e) => ({
  applyToStack: (t) => {
    t.add(Ll(e.bodyLengthChecker), Hl);
  }
});
var zl = async (e) => {
  const t = (e == null ? void 0 : e.Bucket) || "";
  if (typeof e.Bucket == "string" && (e.Bucket = t.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"))), Kl(t)) {
    if (e.ForcePathStyle === true)
      throw new Error("Path-style addressing cannot be used with ARN buckets");
  } else
    (!Vl(t) || t.indexOf(".") !== -1 && !String(e.Endpoint).startsWith("http:") || t.toLowerCase() !== t || t.length < 3) && (e.ForcePathStyle = true);
  return e.DisableMultiRegionAccessPoints && (e.disableMultiRegionAccessPoints = true, e.DisableMRAP = true), e;
};
var ql = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
var Wl = /(\d+\.){3}\d+/;
var Gl = /\.\./;
var Vl = (e) => ql.test(e) && !Wl.test(e) && !Gl.test(e);
var Kl = (e) => {
  const [t, r, n, , , s] = e.split(":"), i = t === "arn" && e.split(":").length >= 6, o = !!(i && r && n && s);
  if (i && !o)
    throw new Error(`Invalid ARN: ${e} was an invalid ARN.`);
  return o;
};
var Xl = (e, t, r) => {
  const n = async () => {
    const s = r[e] ?? r[t];
    return typeof s == "function" ? s() : s;
  };
  return e === "credentialScope" || t === "CredentialScope" ? async () => {
    const s = typeof r.credentials == "function" ? await r.credentials() : r.credentials;
    return (s == null ? void 0 : s.credentialScope) ?? (s == null ? void 0 : s.CredentialScope);
  } : e === "endpoint" || t === "endpoint" ? async () => {
    const s = await n();
    if (s && typeof s == "object") {
      if ("url" in s)
        return s.url.href;
      if ("hostname" in s) {
        const { protocol: i, hostname: o, port: a, path: c2 } = s;
        return `${i}//${o}${a ? ":" + a : ""}${c2}`;
      }
    }
    return s;
  } : n;
};
var Zl = async (e) => {
};
function Yl(e) {
  const t = {};
  if (e = e.replace(/^\?/, ""), e)
    for (const r of e.split("&")) {
      let [n, s = null] = r.split("=");
      n = decodeURIComponent(n), s && (s = decodeURIComponent(s)), n in t ? Array.isArray(t[n]) ? t[n].push(s) : t[n] = [t[n], s] : t[n] = s;
    }
  return t;
}
var tr = (e) => {
  if (typeof e == "string")
    return tr(new URL(e));
  const { hostname: t, pathname: r, port: n, protocol: s, search: i } = e;
  let o;
  return i && (o = Yl(i)), {
    hostname: t,
    port: n ? parseInt(n) : void 0,
    protocol: s,
    path: r,
    query: o
  };
};
var wa = (e) => typeof e == "object" ? "url" in e ? tr(e.url) : e : tr(e);
var Ql = async (e, t, r, n) => {
  if (!r.endpoint) {
    const o = await Zl(r.serviceId || "");
    o && (r.endpoint = () => Promise.resolve(wa(o)));
  }
  const s = await Jl(e, t, r);
  if (typeof r.endpointProvider != "function")
    throw new Error("config.endpointProvider is not set.");
  return r.endpointProvider(s, n);
};
var Jl = async (e, t, r) => {
  var i;
  const n = {}, s = ((i = t == null ? void 0 : t.getEndpointParameterInstructions) == null ? void 0 : i.call(t)) || {};
  for (const [o, a] of Object.entries(s))
    switch (a.type) {
      case "staticContextParams":
        n[o] = a.value;
        break;
      case "contextParams":
        n[o] = e[a.name];
        break;
      case "clientContextParams":
      case "builtInParams":
        n[o] = await Xl(a.name, o, r)();
        break;
      default:
        throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(a));
    }
  return Object.keys(s).length === 0 && Object.assign(n, r), String(r.serviceId).toLowerCase() === "s3" && await zl(n), n;
};
var ef = ({ config: e, instructions: t }) => (r, n) => async (s) => {
  var a, c2, u;
  const i = await Ql(s.input, {
    getEndpointParameterInstructions() {
      return t;
    }
  }, { ...e }, n);
  n.endpointV2 = i, n.authSchemes = (a = i.properties) == null ? void 0 : a.authSchemes;
  const o = (c2 = n.authSchemes) == null ? void 0 : c2[0];
  if (o) {
    n.signing_region = o.signingRegion, n.signing_service = o.signingName;
    const l = fd(n), h = (u = l == null ? void 0 : l.selectedHttpAuthScheme) == null ? void 0 : u.httpAuthOption;
    h && (h.signingProperties = Object.assign(h.signingProperties || {}, {
      signing_region: o.signingRegion,
      signingRegion: o.signingRegion,
      signing_service: o.signingName,
      signingName: o.signingName,
      signingRegionSet: o.signingRegionSet
    }, o.properties));
  }
  return r({
    ...s
  });
};
var tf = (e, t) => (r) => async (n) => {
  const { response: s } = await r(n);
  try {
    const i = await t(s, e);
    return {
      response: s,
      output: i
    };
  } catch (i) {
    if (Object.defineProperty(i, "$response", {
      value: s
    }), !("$metadata" in i)) {
      const o = "Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.";
      i.message += `
  ` + o, typeof i.$responseBodyText < "u" && i.$response && (i.$response.body = i.$responseBodyText);
    }
    throw i;
  }
};
var rf = (e, t) => (r, n) => async (s) => {
  var a;
  const i = (a = n.endpointV2) != null && a.url && e.urlParser ? async () => e.urlParser(n.endpointV2.url) : e.endpoint;
  if (!i)
    throw new Error("No valid endpoint provider available.");
  const o = await t(s.input, { ...e, endpoint: i });
  return r({
    ...s,
    request: o
  });
};
var nf = {
  name: "deserializerMiddleware",
  step: "deserialize",
  tags: ["DESERIALIZER"],
  override: true
};
var Un = {
  name: "serializerMiddleware",
  step: "serialize",
  tags: ["SERIALIZER"],
  override: true
};
function xa(e, t, r) {
  return {
    applyToStack: (n) => {
      n.add(tf(e, r), nf), n.add(rf(e, t), Un);
    }
  };
}
var Ea = {
  step: "serialize",
  tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
  name: "endpointV2Middleware",
  override: true,
  relation: "before",
  toMiddleware: Un.name
};
var Aa = (e, t) => ({
  applyToStack: (r) => {
    r.addRelativeTo(ef({
      config: e,
      instructions: t
    }), Ea);
  }
});
var sf = (e) => {
  const t = e.tls ?? true, { endpoint: r } = e, n = r != null ? async () => wa(await ve(r)()) : void 0;
  return {
    ...e,
    endpoint: n,
    tls: t,
    isCustomEndpoint: !!r,
    useDualstackEndpoint: ve(e.useDualstackEndpoint ?? false),
    useFipsEndpoint: ve(e.useFipsEndpoint ?? false)
  };
};
var at;
(function(e) {
  e.STANDARD = "standard", e.ADAPTIVE = "adaptive";
})(at || (at = {}));
var $n = 3;
var of = at.STANDARD;
var af = [
  "BandwidthLimitExceeded",
  "EC2ThrottledException",
  "LimitExceededException",
  "PriorRequestNotComplete",
  "ProvisionedThroughputExceededException",
  "RequestLimitExceeded",
  "RequestThrottled",
  "RequestThrottledException",
  "SlowDown",
  "ThrottledException",
  "Throttling",
  "ThrottlingException",
  "TooManyRequestsException",
  "TransactionInProgressException"
];
var cf = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
var uf = [500, 502, 503, 504];
var df = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];
var lf = (e) => {
  var t;
  return (t = e.$metadata) == null ? void 0 : t.clockSkewCorrected;
};
var Sa = (e) => {
  var t, r;
  return ((t = e.$metadata) == null ? void 0 : t.httpStatusCode) === 429 || af.includes(e.name) || ((r = e.$retryable) == null ? void 0 : r.throttling) == true;
};
var Ca = (e) => {
  var t;
  return lf(e) || cf.includes(e.name) || df.includes((e == null ? void 0 : e.code) || "") || uf.includes(((t = e.$metadata) == null ? void 0 : t.httpStatusCode) || 0);
};
var ff = (e) => {
  var t;
  if (((t = e.$metadata) == null ? void 0 : t.httpStatusCode) !== void 0) {
    const r = e.$metadata.httpStatusCode;
    return 500 <= r && r <= 599 && !Ca(e);
  }
  return false;
};
var hf = class {
  constructor(t) {
    this.currentCapacity = 0, this.enabled = false, this.lastMaxRate = 0, this.measuredTxRate = 0, this.requestCount = 0, this.lastTimestamp = 0, this.timeWindow = 0, this.beta = (t == null ? void 0 : t.beta) ?? 0.7, this.minCapacity = (t == null ? void 0 : t.minCapacity) ?? 1, this.minFillRate = (t == null ? void 0 : t.minFillRate) ?? 0.5, this.scaleConstant = (t == null ? void 0 : t.scaleConstant) ?? 0.4, this.smooth = (t == null ? void 0 : t.smooth) ?? 0.8;
    const r = this.getCurrentTimeInSeconds();
    this.lastThrottleTime = r, this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds()), this.fillRate = this.minFillRate, this.maxCapacity = this.minCapacity;
  }
  getCurrentTimeInSeconds() {
    return Date.now() / 1e3;
  }
  async getSendToken() {
    return this.acquireTokenBucket(1);
  }
  async acquireTokenBucket(t) {
    if (this.enabled) {
      if (this.refillTokenBucket(), t > this.currentCapacity) {
        const r = (t - this.currentCapacity) / this.fillRate * 1e3;
        await new Promise((n) => setTimeout(n, r));
      }
      this.currentCapacity = this.currentCapacity - t;
    }
  }
  refillTokenBucket() {
    const t = this.getCurrentTimeInSeconds();
    if (!this.lastTimestamp) {
      this.lastTimestamp = t;
      return;
    }
    const r = (t - this.lastTimestamp) * this.fillRate;
    this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + r), this.lastTimestamp = t;
  }
  updateClientSendingRate(t) {
    let r;
    if (this.updateMeasuredRate(), Sa(t)) {
      const s = this.enabled ? Math.min(this.measuredTxRate, this.fillRate) : this.measuredTxRate;
      this.lastMaxRate = s, this.calculateTimeWindow(), this.lastThrottleTime = this.getCurrentTimeInSeconds(), r = this.cubicThrottle(s), this.enableTokenBucket();
    } else
      this.calculateTimeWindow(), r = this.cubicSuccess(this.getCurrentTimeInSeconds());
    const n = Math.min(r, 2 * this.measuredTxRate);
    this.updateTokenBucketRate(n);
  }
  calculateTimeWindow() {
    this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
  }
  cubicThrottle(t) {
    return this.getPrecise(t * this.beta);
  }
  cubicSuccess(t) {
    return this.getPrecise(this.scaleConstant * Math.pow(t - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
  }
  enableTokenBucket() {
    this.enabled = true;
  }
  updateTokenBucketRate(t) {
    this.refillTokenBucket(), this.fillRate = Math.max(t, this.minFillRate), this.maxCapacity = Math.max(t, this.minCapacity), this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
  }
  updateMeasuredRate() {
    const t = this.getCurrentTimeInSeconds(), r = Math.floor(t * 2) / 2;
    if (this.requestCount++, r > this.lastTxRateBucket) {
      const n = this.requestCount / (r - this.lastTxRateBucket);
      this.measuredTxRate = this.getPrecise(n * this.smooth + this.measuredTxRate * (1 - this.smooth)), this.requestCount = 0, this.lastTxRateBucket = r;
    }
  }
  getPrecise(t) {
    return parseFloat(t.toFixed(8));
  }
};
var mn = 100;
var va = 20 * 1e3;
var pf = 500;
var Ls = 500;
var gf = 5;
var mf = 10;
var yf = 1;
var bf = "amz-sdk-invocation-id";
var wf = "amz-sdk-request";
var xf = () => {
  let e = mn;
  return {
    computeNextBackoffDelay: (n) => Math.floor(Math.min(va, Math.random() * 2 ** n * e)),
    setDelayBase: (n) => {
      e = n;
    }
  };
};
var Hs = ({ retryDelay: e, retryCount: t, retryCost: r }) => ({
  getRetryCount: () => t,
  getRetryDelay: () => Math.min(va, e),
  getRetryCost: () => r
});
var Ra = class {
  constructor(t) {
    this.maxAttempts = t, this.mode = at.STANDARD, this.capacity = Ls, this.retryBackoffStrategy = xf(), this.maxAttemptsProvider = typeof t == "function" ? t : async () => t;
  }
  async acquireInitialRetryToken(t) {
    return Hs({
      retryDelay: mn,
      retryCount: 0
    });
  }
  async refreshRetryTokenForRetry(t, r) {
    const n = await this.getMaxAttempts();
    if (this.shouldRetry(t, r, n)) {
      const s = r.errorType;
      this.retryBackoffStrategy.setDelayBase(s === "THROTTLING" ? pf : mn);
      const i = this.retryBackoffStrategy.computeNextBackoffDelay(t.getRetryCount()), o = r.retryAfterHint ? Math.max(r.retryAfterHint.getTime() - Date.now() || 0, i) : i, a = this.getCapacityCost(s);
      return this.capacity -= a, Hs({
        retryDelay: o,
        retryCount: t.getRetryCount() + 1,
        retryCost: a
      });
    }
    throw new Error("No retry token available");
  }
  recordSuccess(t) {
    this.capacity = Math.max(Ls, this.capacity + (t.getRetryCost() ?? yf));
  }
  getCapacity() {
    return this.capacity;
  }
  async getMaxAttempts() {
    try {
      return await this.maxAttemptsProvider();
    } catch {
      return $n;
    }
  }
  shouldRetry(t, r, n) {
    return t.getRetryCount() + 1 < n && this.capacity >= this.getCapacityCost(r.errorType) && this.isRetryableError(r.errorType);
  }
  getCapacityCost(t) {
    return t === "TRANSIENT" ? mf : gf;
  }
  isRetryableError(t) {
    return t === "THROTTLING" || t === "TRANSIENT";
  }
};
var Ef = class {
  constructor(t, r) {
    this.maxAttemptsProvider = t, this.mode = at.ADAPTIVE;
    const { rateLimiter: n } = r ?? {};
    this.rateLimiter = n ?? new hf(), this.standardRetryStrategy = new Ra(t);
  }
  async acquireInitialRetryToken(t) {
    return await this.rateLimiter.getSendToken(), this.standardRetryStrategy.acquireInitialRetryToken(t);
  }
  async refreshRetryTokenForRetry(t, r) {
    return this.rateLimiter.updateClientSendingRate(r), this.standardRetryStrategy.refreshRetryTokenForRetry(t, r);
  }
  recordSuccess(t) {
    this.rateLimiter.updateClientSendingRate({}), this.standardRetryStrategy.recordSuccess(t);
  }
};
var jt;
var Af = new Uint8Array(16);
function Sf() {
  if (!jt && (jt = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !jt))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return jt(Af);
}
var re = [];
for (let e = 0; e < 256; ++e)
  re.push((e + 256).toString(16).slice(1));
function Cf(e, t = 0) {
  return re[e[t + 0]] + re[e[t + 1]] + re[e[t + 2]] + re[e[t + 3]] + "-" + re[e[t + 4]] + re[e[t + 5]] + "-" + re[e[t + 6]] + re[e[t + 7]] + "-" + re[e[t + 8]] + re[e[t + 9]] + "-" + re[e[t + 10]] + re[e[t + 11]] + re[e[t + 12]] + re[e[t + 13]] + re[e[t + 14]] + re[e[t + 15]];
}
var vf = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var js = {
  randomUUID: vf
};
function Rf(e, t, r) {
  if (js.randomUUID && !t && !e)
    return js.randomUUID();
  e = e || {};
  const n = e.random || (e.rng || Sf)();
  if (n[6] = n[6] & 15 | 64, n[8] = n[8] & 63 | 128, t) {
    r = r || 0;
    for (let s = 0; s < 16; ++s)
      t[r + s] = n[s];
    return t;
  }
  return Cf(n);
}
var _f = (e) => e instanceof Error ? e : e instanceof Object ? Object.assign(new Error(), e) : typeof e == "string" ? new Error(e) : new Error(`AWS SDK error wrapper for ${e}`);
var Tf = (e) => {
  const { retryStrategy: t } = e, r = ve(e.maxAttempts ?? $n);
  return {
    ...e,
    maxAttempts: r,
    retryStrategy: async () => t || (await ve(e.retryMode)() === at.ADAPTIVE ? new Ef(r) : new Ra(r))
  };
};
var Bf = (e) => (e == null ? void 0 : e.body) instanceof ReadableStream;
var kf = (e) => (t, r) => async (n) => {
  var o;
  let s = await e.retryStrategy();
  const i = await e.maxAttempts();
  if (Nf(s)) {
    s = s;
    let a = await s.acquireInitialRetryToken(r.partition_id), c2 = new Error(), u = 0, l = 0;
    const { request: h } = n, p = ge.isInstance(h);
    for (p && (h.headers[bf] = Rf()); ; )
      try {
        p && (h.headers[wf] = `attempt=${u + 1}; max=${i}`);
        const { response: g, output: b } = await t(n);
        return s.recordSuccess(a), b.$metadata.attempts = u + 1, b.$metadata.totalRetryDelay = l, { response: g, output: b };
      } catch (g) {
        const b = Pf(g);
        if (c2 = _f(g), p && Bf(h))
          throw (o = r.logger instanceof Tn ? console : r.logger) == null || o.warn("An error was encountered in a non-retryable streaming request."), c2;
        try {
          a = await s.refreshRetryTokenForRetry(a, b);
        } catch {
          throw c2.$metadata || (c2.$metadata = {}), c2.$metadata.attempts = u + 1, c2.$metadata.totalRetryDelay = l, c2;
        }
        u = a.getRetryCount();
        const A = a.getRetryDelay();
        l += A, await new Promise((R) => setTimeout(R, A));
      }
  } else
    return s = s, s != null && s.mode && (r.userAgent = [...r.userAgent || [], ["cfg/retry-mode", s.mode]]), s.retry(t, n);
};
var Nf = (e) => typeof e.acquireInitialRetryToken < "u" && typeof e.refreshRetryTokenForRetry < "u" && typeof e.recordSuccess < "u";
var Pf = (e) => {
  const t = {
    error: e,
    errorType: Of(e)
  }, r = If(e.$response);
  return r && (t.retryAfterHint = r), t;
};
var Of = (e) => Sa(e) ? "THROTTLING" : Ca(e) ? "TRANSIENT" : ff(e) ? "SERVER_ERROR" : "CLIENT_ERROR";
var _a = {
  name: "retryMiddleware",
  tags: ["RETRY"],
  step: "finalizeRequest",
  priority: "high",
  override: true
};
var Mf = (e) => ({
  applyToStack: (t) => {
    t.add(kf(e), _a);
  }
});
var If = (e) => {
  if (!Qt.isInstance(e))
    return;
  const t = Object.keys(e.headers).find((i) => i.toLowerCase() === "retry-after");
  if (!t)
    return;
  const r = e.headers[t], n = Number(r);
  return Number.isNaN(n) ? new Date(r) : new Date(n * 1e3);
};
var Ff = (e) => ({
  ...e,
  useFipsEndpoint: e.useFipsEndpoint ?? false,
  useDualstackEndpoint: e.useDualstackEndpoint ?? false,
  forcePathStyle: e.forcePathStyle ?? false,
  useAccelerateEndpoint: e.useAccelerateEndpoint ?? false,
  useGlobalEndpoint: e.useGlobalEndpoint ?? false,
  disableMultiregionAccessPoints: e.disableMultiregionAccessPoints ?? false,
  defaultSigningName: "s3"
});
var Ta = {
  ForcePathStyle: { type: "clientContextParams", name: "forcePathStyle" },
  UseArnRegion: { type: "clientContextParams", name: "useArnRegion" },
  DisableMultiRegionAccessPoints: { type: "clientContextParams", name: "disableMultiregionAccessPoints" },
  Accelerate: { type: "clientContextParams", name: "useAccelerateEndpoint" },
  DisableS3ExpressSessionAuth: { type: "clientContextParams", name: "disableS3ExpressSessionAuth" },
  UseGlobalEndpoint: { type: "builtInParams", name: "useGlobalEndpoint" },
  UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
  Endpoint: { type: "builtInParams", name: "endpoint" },
  Region: { type: "builtInParams", name: "region" },
  UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
};
var Ee = class _Ee extends In {
  constructor(t) {
    super(t), Object.setPrototypeOf(this, _Ee.prototype);
  }
};
var Ln = class _Ln extends Ee {
  constructor(t) {
    super({
      name: "NoSuchUpload",
      $fault: "client",
      ...t
    }), this.name = "NoSuchUpload", this.$fault = "client", Object.setPrototypeOf(this, _Ln.prototype);
  }
};
var Hn = class _Hn extends Ee {
  constructor(t) {
    super({
      name: "ObjectNotInActiveTierError",
      $fault: "client",
      ...t
    }), this.name = "ObjectNotInActiveTierError", this.$fault = "client", Object.setPrototypeOf(this, _Hn.prototype);
  }
};
var jn = class _jn extends Ee {
  constructor(t) {
    super({
      name: "BucketAlreadyExists",
      $fault: "client",
      ...t
    }), this.name = "BucketAlreadyExists", this.$fault = "client", Object.setPrototypeOf(this, _jn.prototype);
  }
};
var zn = class _zn extends Ee {
  constructor(t) {
    super({
      name: "BucketAlreadyOwnedByYou",
      $fault: "client",
      ...t
    }), this.name = "BucketAlreadyOwnedByYou", this.$fault = "client", Object.setPrototypeOf(this, _zn.prototype);
  }
};
var qn = class _qn extends Ee {
  constructor(t) {
    super({
      name: "NoSuchBucket",
      $fault: "client",
      ...t
    }), this.name = "NoSuchBucket", this.$fault = "client", Object.setPrototypeOf(this, _qn.prototype);
  }
};
var zs;
(function(e) {
  e.visit = (t, r) => t.Prefix !== void 0 ? r.Prefix(t.Prefix) : t.Tag !== void 0 ? r.Tag(t.Tag) : t.And !== void 0 ? r.And(t.And) : r._(t.$unknown[0], t.$unknown[1]);
})(zs || (zs = {}));
var qs;
(function(e) {
  e.visit = (t, r) => t.Prefix !== void 0 ? r.Prefix(t.Prefix) : t.Tag !== void 0 ? r.Tag(t.Tag) : t.ObjectSizeGreaterThan !== void 0 ? r.ObjectSizeGreaterThan(t.ObjectSizeGreaterThan) : t.ObjectSizeLessThan !== void 0 ? r.ObjectSizeLessThan(t.ObjectSizeLessThan) : t.And !== void 0 ? r.And(t.And) : r._(t.$unknown[0], t.$unknown[1]);
})(qs || (qs = {}));
var Ws;
(function(e) {
  e.visit = (t, r) => t.Prefix !== void 0 ? r.Prefix(t.Prefix) : t.Tag !== void 0 ? r.Tag(t.Tag) : t.AccessPointArn !== void 0 ? r.AccessPointArn(t.AccessPointArn) : t.And !== void 0 ? r.And(t.And) : r._(t.$unknown[0], t.$unknown[1]);
})(Ws || (Ws = {}));
var Gs;
(function(e) {
  e.visit = (t, r) => t.Prefix !== void 0 ? r.Prefix(t.Prefix) : t.Tag !== void 0 ? r.Tag(t.Tag) : t.And !== void 0 ? r.And(t.And) : r._(t.$unknown[0], t.$unknown[1]);
})(Gs || (Gs = {}));
var Wn = class _Wn extends Ee {
  constructor(t) {
    super({
      name: "InvalidObjectState",
      $fault: "client",
      ...t
    }), this.name = "InvalidObjectState", this.$fault = "client", Object.setPrototypeOf(this, _Wn.prototype), this.StorageClass = t.StorageClass, this.AccessTier = t.AccessTier;
  }
};
var Gn = class _Gn extends Ee {
  constructor(t) {
    super({
      name: "NoSuchKey",
      $fault: "client",
      ...t
    }), this.name = "NoSuchKey", this.$fault = "client", Object.setPrototypeOf(this, _Gn.prototype);
  }
};
var Vn = class _Vn extends Ee {
  constructor(t) {
    super({
      name: "NotFound",
      $fault: "client",
      ...t
    }), this.name = "NotFound", this.$fault = "client", Object.setPrototypeOf(this, _Vn.prototype);
  }
};
var Df = (e) => ({
  ...e,
  ...e.SecretAccessKey && { SecretAccessKey: Ye },
  ...e.SessionToken && { SessionToken: Ye }
});
var Uf = (e) => ({
  ...e,
  ...e.Credentials && { Credentials: Df(e.Credentials) }
});
Ea.name;
Un.name;
_a.name;
function Ba(e, t) {
  return new $f(e, t);
}
var $f = class {
  constructor(t, r) {
    this.input = t, this.context = r, this.query = {}, this.method = "", this.headers = {}, this.path = "", this.body = null, this.hostname = "", this.resolvePathStack = [];
  }
  async build() {
    const { hostname: t, protocol: r = "https", port: n, path: s } = await this.context.endpoint();
    this.path = s;
    for (const i of this.resolvePathStack)
      i(this.path);
    return new ge({
      protocol: r,
      hostname: this.hostname || t,
      port: n,
      method: this.method,
      path: this.path,
      query: this.query,
      body: this.body,
      headers: this.headers
    });
  }
  hn(t) {
    return this.hostname = t, this;
  }
  bp(t) {
    return this.resolvePathStack.push((r) => {
      this.path = `${r != null && r.endsWith("/") ? r.slice(0, -1) : r || ""}` + t;
    }), this;
  }
  p(t, r, n, s) {
    return this.resolvePathStack.push((i) => {
      this.path = td(i, this.input, t, r, n, s);
    }), this;
  }
  h(t) {
    return this.headers = t, this;
  }
  q(t) {
    return this.query = t, this;
  }
  b(t) {
    return this.body = t, this;
  }
  m(t) {
    return this.method = t, this;
  }
};
var Lf = (e, t) => qo(e, t).then((r) => t.utf8Encoder(r));
var Kn = {};
var ur = {};
(function(e) {
  const t = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", r = t + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040", n = "[" + t + "][" + r + "]*", s = new RegExp("^" + n + "$"), i = function(a, c2) {
    const u = [];
    let l = c2.exec(a);
    for (; l; ) {
      const h = [];
      h.startIndex = c2.lastIndex - l[0].length;
      const p = l.length;
      for (let g = 0; g < p; g++)
        h.push(l[g]);
      u.push(h), l = c2.exec(a);
    }
    return u;
  }, o = function(a) {
    const c2 = s.exec(a);
    return !(c2 === null || typeof c2 > "u");
  };
  e.isExist = function(a) {
    return typeof a < "u";
  }, e.isEmptyObject = function(a) {
    return Object.keys(a).length === 0;
  }, e.merge = function(a, c2, u) {
    if (c2) {
      const l = Object.keys(c2), h = l.length;
      for (let p = 0; p < h; p++)
        u === "strict" ? a[l[p]] = [c2[l[p]]] : a[l[p]] = c2[l[p]];
    }
  }, e.getValue = function(a) {
    return e.isExist(a) ? a : "";
  }, e.isName = o, e.getAllMatches = i, e.nameRegexp = n;
})(ur);
var Xn = ur;
var Hf = {
  allowBooleanAttributes: false,
  //A tag can have attributes without any value
  unpairedTags: []
};
Kn.validate = function(e, t) {
  t = Object.assign({}, Hf, t);
  const r = [];
  let n = false, s = false;
  e[0] === "\uFEFF" && (e = e.substr(1));
  for (let i = 0; i < e.length; i++)
    if (e[i] === "<" && e[i + 1] === "?") {
      if (i += 2, i = Ks(e, i), i.err)
        return i;
    } else if (e[i] === "<") {
      let o = i;
      if (i++, e[i] === "!") {
        i = Xs(e, i);
        continue;
      } else {
        let a = false;
        e[i] === "/" && (a = true, i++);
        let c2 = "";
        for (; i < e.length && e[i] !== ">" && e[i] !== " " && e[i] !== "	" && e[i] !== `
` && e[i] !== "\r"; i++)
          c2 += e[i];
        if (c2 = c2.trim(), c2[c2.length - 1] === "/" && (c2 = c2.substring(0, c2.length - 1), i--), !Xf(c2)) {
          let h;
          return c2.trim().length === 0 ? h = "Invalid space after '<'." : h = "Tag '" + c2 + "' is an invalid name.", G("InvalidTag", h, fe(e, i));
        }
        const u = qf(e, i);
        if (u === false)
          return G("InvalidAttr", "Attributes for '" + c2 + "' have open quote.", fe(e, i));
        let l = u.value;
        if (i = u.index, l[l.length - 1] === "/") {
          const h = i - l.length;
          l = l.substring(0, l.length - 1);
          const p = Zs(l, t);
          if (p === true)
            n = true;
          else
            return G(p.err.code, p.err.msg, fe(e, h + p.err.line));
        } else if (a)
          if (u.tagClosed) {
            if (l.trim().length > 0)
              return G("InvalidTag", "Closing tag '" + c2 + "' can't have attributes or invalid starting.", fe(e, o));
            {
              const h = r.pop();
              if (c2 !== h.tagName) {
                let p = fe(e, h.tagStartPos);
                return G(
                  "InvalidTag",
                  "Expected closing tag '" + h.tagName + "' (opened in line " + p.line + ", col " + p.col + ") instead of closing tag '" + c2 + "'.",
                  fe(e, o)
                );
              }
              r.length == 0 && (s = true);
            }
          } else
            return G("InvalidTag", "Closing tag '" + c2 + "' doesn't have proper closing.", fe(e, i));
        else {
          const h = Zs(l, t);
          if (h !== true)
            return G(h.err.code, h.err.msg, fe(e, i - l.length + h.err.line));
          if (s === true)
            return G("InvalidXml", "Multiple possible root nodes found.", fe(e, i));
          t.unpairedTags.indexOf(c2) !== -1 || r.push({ tagName: c2, tagStartPos: o }), n = true;
        }
        for (i++; i < e.length; i++)
          if (e[i] === "<")
            if (e[i + 1] === "!") {
              i++, i = Xs(e, i);
              continue;
            } else if (e[i + 1] === "?") {
              if (i = Ks(e, ++i), i.err)
                return i;
            } else
              break;
          else if (e[i] === "&") {
            const h = Vf(e, i);
            if (h == -1)
              return G("InvalidChar", "char '&' is not expected.", fe(e, i));
            i = h;
          } else if (s === true && !Vs(e[i]))
            return G("InvalidXml", "Extra text at the end", fe(e, i));
        e[i] === "<" && i--;
      }
    } else {
      if (Vs(e[i]))
        continue;
      return G("InvalidChar", "char '" + e[i] + "' is not expected.", fe(e, i));
    }
  if (n) {
    if (r.length == 1)
      return G("InvalidTag", "Unclosed tag '" + r[0].tagName + "'.", fe(e, r[0].tagStartPos));
    if (r.length > 0)
      return G("InvalidXml", "Invalid '" + JSON.stringify(r.map((i) => i.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
  } else
    return G("InvalidXml", "Start tag expected.", 1);
  return true;
};
function Vs(e) {
  return e === " " || e === "	" || e === `
` || e === "\r";
}
function Ks(e, t) {
  const r = t;
  for (; t < e.length; t++)
    if (e[t] == "?" || e[t] == " ") {
      const n = e.substr(r, t - r);
      if (t > 5 && n === "xml")
        return G("InvalidXml", "XML declaration allowed only at the start of the document.", fe(e, t));
      if (e[t] == "?" && e[t + 1] == ">") {
        t++;
        break;
      } else
        continue;
    }
  return t;
}
function Xs(e, t) {
  if (e.length > t + 5 && e[t + 1] === "-" && e[t + 2] === "-") {
    for (t += 3; t < e.length; t++)
      if (e[t] === "-" && e[t + 1] === "-" && e[t + 2] === ">") {
        t += 2;
        break;
      }
  } else if (e.length > t + 8 && e[t + 1] === "D" && e[t + 2] === "O" && e[t + 3] === "C" && e[t + 4] === "T" && e[t + 5] === "Y" && e[t + 6] === "P" && e[t + 7] === "E") {
    let r = 1;
    for (t += 8; t < e.length; t++)
      if (e[t] === "<")
        r++;
      else if (e[t] === ">" && (r--, r === 0))
        break;
  } else if (e.length > t + 9 && e[t + 1] === "[" && e[t + 2] === "C" && e[t + 3] === "D" && e[t + 4] === "A" && e[t + 5] === "T" && e[t + 6] === "A" && e[t + 7] === "[") {
    for (t += 8; t < e.length; t++)
      if (e[t] === "]" && e[t + 1] === "]" && e[t + 2] === ">") {
        t += 2;
        break;
      }
  }
  return t;
}
var jf = '"';
var zf = "'";
function qf(e, t) {
  let r = "", n = "", s = false;
  for (; t < e.length; t++) {
    if (e[t] === jf || e[t] === zf)
      n === "" ? n = e[t] : n !== e[t] || (n = "");
    else if (e[t] === ">" && n === "") {
      s = true;
      break;
    }
    r += e[t];
  }
  return n !== "" ? false : {
    value: r,
    index: t,
    tagClosed: s
  };
}
var Wf = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
function Zs(e, t) {
  const r = Xn.getAllMatches(e, Wf), n = {};
  for (let s = 0; s < r.length; s++) {
    if (r[s][1].length === 0)
      return G("InvalidAttr", "Attribute '" + r[s][2] + "' has no space in starting.", lt(r[s]));
    if (r[s][3] !== void 0 && r[s][4] === void 0)
      return G("InvalidAttr", "Attribute '" + r[s][2] + "' is without value.", lt(r[s]));
    if (r[s][3] === void 0 && !t.allowBooleanAttributes)
      return G("InvalidAttr", "boolean attribute '" + r[s][2] + "' is not allowed.", lt(r[s]));
    const i = r[s][2];
    if (!Kf(i))
      return G("InvalidAttr", "Attribute '" + i + "' is an invalid name.", lt(r[s]));
    if (!n.hasOwnProperty(i))
      n[i] = 1;
    else
      return G("InvalidAttr", "Attribute '" + i + "' is repeated.", lt(r[s]));
  }
  return true;
}
function Gf(e, t) {
  let r = /\d/;
  for (e[t] === "x" && (t++, r = /[\da-fA-F]/); t < e.length; t++) {
    if (e[t] === ";")
      return t;
    if (!e[t].match(r))
      break;
  }
  return -1;
}
function Vf(e, t) {
  if (t++, e[t] === ";")
    return -1;
  if (e[t] === "#")
    return t++, Gf(e, t);
  let r = 0;
  for (; t < e.length; t++, r++)
    if (!(e[t].match(/\w/) && r < 20)) {
      if (e[t] === ";")
        break;
      return -1;
    }
  return t;
}
function G(e, t, r) {
  return {
    err: {
      code: e,
      msg: t,
      line: r.line || r,
      col: r.col
    }
  };
}
function Kf(e) {
  return Xn.isName(e);
}
function Xf(e) {
  return Xn.isName(e);
}
function fe(e, t) {
  const r = e.substring(0, t).split(/\r?\n/);
  return {
    line: r.length,
    // column number is last line's length + 1, because column numbering starts at 1:
    col: r[r.length - 1].length + 1
  };
}
function lt(e) {
  return e.startIndex + e[1].length;
}
var Zn = {};
var ka = {
  preserveOrder: false,
  attributeNamePrefix: "@_",
  attributesGroupName: false,
  textNodeName: "#text",
  ignoreAttributes: true,
  removeNSPrefix: false,
  // remove NS from tag name or attribute name if true
  allowBooleanAttributes: false,
  //a tag can have attributes without any value
  //ignoreRootElement : false,
  parseTagValue: true,
  parseAttributeValue: false,
  trimValues: true,
  //Trim string values of tag and attributes
  cdataPropName: false,
  numberParseOptions: {
    hex: true,
    leadingZeros: true,
    eNotation: true
  },
  tagValueProcessor: function(e, t) {
    return t;
  },
  attributeValueProcessor: function(e, t) {
    return t;
  },
  stopNodes: [],
  //nested tags will not be parsed even for errors
  alwaysCreateTextNode: false,
  isArray: () => false,
  commentPropName: false,
  unpairedTags: [],
  processEntities: true,
  htmlEntities: false,
  ignoreDeclaration: false,
  ignorePiTags: false,
  transformTagName: false,
  transformAttributeName: false,
  updateTag: function(e, t, r) {
    return e;
  }
  // skipEmptyListItem: false
};
var Zf = function(e) {
  return Object.assign({}, ka, e);
};
Zn.buildOptions = Zf;
Zn.defaultOptions = ka;
var Yf = class {
  constructor(t) {
    this.tagname = t, this.child = [], this[":@"] = {};
  }
  add(t, r) {
    t === "__proto__" && (t = "#__proto__"), this.child.push({ [t]: r });
  }
  addChild(t) {
    t.tagname === "__proto__" && (t.tagname = "#__proto__"), t[":@"] && Object.keys(t[":@"]).length > 0 ? this.child.push({ [t.tagname]: t.child, ":@": t[":@"] }) : this.child.push({ [t.tagname]: t.child });
  }
};
var Qf = Yf;
var Jf = ur;
function eh(e, t) {
  const r = {};
  if (e[t + 3] === "O" && e[t + 4] === "C" && e[t + 5] === "T" && e[t + 6] === "Y" && e[t + 7] === "P" && e[t + 8] === "E") {
    t = t + 9;
    let n = 1, s = false, i = false, o = "";
    for (; t < e.length; t++)
      if (e[t] === "<" && !i) {
        if (s && nh(e, t))
          t += 7, [entityName, val, t] = th(e, t + 1), val.indexOf("&") === -1 && (r[ah(entityName)] = {
            regx: RegExp(`&${entityName};`, "g"),
            val
          });
        else if (s && sh(e, t))
          t += 8;
        else if (s && ih(e, t))
          t += 8;
        else if (s && oh(e, t))
          t += 9;
        else if (rh)
          i = true;
        else
          throw new Error("Invalid DOCTYPE");
        n++, o = "";
      } else if (e[t] === ">") {
        if (i ? e[t - 1] === "-" && e[t - 2] === "-" && (i = false, n--) : n--, n === 0)
          break;
      } else
        e[t] === "[" ? s = true : o += e[t];
    if (n !== 0)
      throw new Error("Unclosed DOCTYPE");
  } else
    throw new Error("Invalid Tag instead of DOCTYPE");
  return { entities: r, i: t };
}
function th(e, t) {
  let r = "";
  for (; t < e.length && e[t] !== "'" && e[t] !== '"'; t++)
    r += e[t];
  if (r = r.trim(), r.indexOf(" ") !== -1)
    throw new Error("External entites are not supported");
  const n = e[t++];
  let s = "";
  for (; t < e.length && e[t] !== n; t++)
    s += e[t];
  return [r, s, t];
}
function rh(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "-" && e[t + 3] === "-";
}
function nh(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "E" && e[t + 3] === "N" && e[t + 4] === "T" && e[t + 5] === "I" && e[t + 6] === "T" && e[t + 7] === "Y";
}
function sh(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "E" && e[t + 3] === "L" && e[t + 4] === "E" && e[t + 5] === "M" && e[t + 6] === "E" && e[t + 7] === "N" && e[t + 8] === "T";
}
function ih(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "A" && e[t + 3] === "T" && e[t + 4] === "T" && e[t + 5] === "L" && e[t + 6] === "I" && e[t + 7] === "S" && e[t + 8] === "T";
}
function oh(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "N" && e[t + 3] === "O" && e[t + 4] === "T" && e[t + 5] === "A" && e[t + 6] === "T" && e[t + 7] === "I" && e[t + 8] === "O" && e[t + 9] === "N";
}
function ah(e) {
  if (Jf.isName(e))
    return e;
  throw new Error(`Invalid entity name ${e}`);
}
var ch = eh;
var uh = /^[-+]?0x[a-fA-F0-9]+$/;
var dh = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
!Number.parseInt && window.parseInt && (Number.parseInt = window.parseInt);
!Number.parseFloat && window.parseFloat && (Number.parseFloat = window.parseFloat);
var lh = {
  hex: true,
  leadingZeros: true,
  decimalPoint: ".",
  eNotation: true
  //skipLike: /regex/
};
function fh(e, t = {}) {
  if (t = Object.assign({}, lh, t), !e || typeof e != "string")
    return e;
  let r = e.trim();
  if (t.skipLike !== void 0 && t.skipLike.test(r))
    return e;
  if (t.hex && uh.test(r))
    return Number.parseInt(r, 16);
  {
    const n = dh.exec(r);
    if (n) {
      const s = n[1], i = n[2];
      let o = hh(n[3]);
      const a = n[4] || n[6];
      if (!t.leadingZeros && i.length > 0 && s && r[2] !== ".")
        return e;
      if (!t.leadingZeros && i.length > 0 && !s && r[1] !== ".")
        return e;
      {
        const c2 = Number(r), u = "" + c2;
        return u.search(/[eE]/) !== -1 || a ? t.eNotation ? c2 : e : r.indexOf(".") !== -1 ? u === "0" && o === "" || u === o || s && u === "-" + o ? c2 : e : i ? o === u || s + o === u ? c2 : e : r === u || r === s + u ? c2 : e;
      }
    } else
      return e;
  }
}
function hh(e) {
  return e && e.indexOf(".") !== -1 && (e = e.replace(/0+$/, ""), e === "." ? e = "0" : e[0] === "." ? e = "0" + e : e[e.length - 1] === "." && (e = e.substr(0, e.length - 1))), e;
}
var ph = fh;
var Yn = ur;
var ft = Qf;
var gh = ch;
var mh = ph;
"<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)".replace(/NAME/g, Yn.nameRegexp);
var yh = class {
  constructor(t) {
    this.options = t, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = {
      apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
      gt: { regex: /&(gt|#62|#x3E);/g, val: ">" },
      lt: { regex: /&(lt|#60|#x3C);/g, val: "<" },
      quot: { regex: /&(quot|#34|#x22);/g, val: '"' }
    }, this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }, this.htmlEntities = {
      space: { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      cent: { regex: /&(cent|#162);/g, val: "" },
      pound: { regex: /&(pound|#163);/g, val: "" },
      yen: { regex: /&(yen|#165);/g, val: "" },
      euro: { regex: /&(euro|#8364);/g, val: "" },
      copyright: { regex: /&(copy|#169);/g, val: "" },
      reg: { regex: /&(reg|#174);/g, val: "" },
      inr: { regex: /&(inr|#8377);/g, val: "" }
    }, this.addExternalEntities = bh, this.parseXml = Sh, this.parseTextData = wh, this.resolveNameSpace = xh, this.buildAttributesMap = Ah, this.isItStopNode = _h, this.replaceEntitiesValue = vh, this.readStopNodeData = Bh, this.saveTextToParentTag = Rh, this.addChild = Ch;
  }
};
function bh(e) {
  const t = Object.keys(e);
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    this.lastEntities[n] = {
      regex: new RegExp("&" + n + ";", "g"),
      val: e[n]
    };
  }
}
function wh(e, t, r, n, s, i, o) {
  if (e !== void 0 && (this.options.trimValues && !n && (e = e.trim()), e.length > 0)) {
    o || (e = this.replaceEntitiesValue(e));
    const a = this.options.tagValueProcessor(t, e, r, s, i);
    return a == null ? e : typeof a != typeof e || a !== e ? a : this.options.trimValues ? bn(e, this.options.parseTagValue, this.options.numberParseOptions) : e.trim() === e ? bn(e, this.options.parseTagValue, this.options.numberParseOptions) : e;
  }
}
function xh(e) {
  if (this.options.removeNSPrefix) {
    const t = e.split(":"), r = e.charAt(0) === "/" ? "/" : "";
    if (t[0] === "xmlns")
      return "";
    t.length === 2 && (e = r + t[1]);
  }
  return e;
}
var Eh = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
function Ah(e, t, r) {
  if (!this.options.ignoreAttributes && typeof e == "string") {
    const n = Yn.getAllMatches(e, Eh), s = n.length, i = {};
    for (let o = 0; o < s; o++) {
      const a = this.resolveNameSpace(n[o][1]);
      let c2 = n[o][4], u = this.options.attributeNamePrefix + a;
      if (a.length)
        if (this.options.transformAttributeName && (u = this.options.transformAttributeName(u)), u === "__proto__" && (u = "#__proto__"), c2 !== void 0) {
          this.options.trimValues && (c2 = c2.trim()), c2 = this.replaceEntitiesValue(c2);
          const l = this.options.attributeValueProcessor(a, c2, t);
          l == null ? i[u] = c2 : typeof l != typeof c2 || l !== c2 ? i[u] = l : i[u] = bn(
            c2,
            this.options.parseAttributeValue,
            this.options.numberParseOptions
          );
        } else
          this.options.allowBooleanAttributes && (i[u] = true);
    }
    if (!Object.keys(i).length)
      return;
    if (this.options.attributesGroupName) {
      const o = {};
      return o[this.options.attributesGroupName] = i, o;
    }
    return i;
  }
}
var Sh = function(e) {
  e = e.replace(/\r\n?/g, `
`);
  const t = new ft("!xml");
  let r = t, n = "", s = "";
  for (let i = 0; i < e.length; i++)
    if (e[i] === "<")
      if (e[i + 1] === "/") {
        const a = Xe(e, ">", i, "Closing Tag is not closed.");
        let c2 = e.substring(i + 2, a).trim();
        if (this.options.removeNSPrefix) {
          const h = c2.indexOf(":");
          h !== -1 && (c2 = c2.substr(h + 1));
        }
        this.options.transformTagName && (c2 = this.options.transformTagName(c2)), r && (n = this.saveTextToParentTag(n, r, s));
        const u = s.substring(s.lastIndexOf(".") + 1);
        if (c2 && this.options.unpairedTags.indexOf(c2) !== -1)
          throw new Error(`Unpaired tag can not be used as closing tag: </${c2}>`);
        let l = 0;
        u && this.options.unpairedTags.indexOf(u) !== -1 ? (l = s.lastIndexOf(".", s.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : l = s.lastIndexOf("."), s = s.substring(0, l), r = this.tagsNodeStack.pop(), n = "", i = a;
      } else if (e[i + 1] === "?") {
        let a = yn(e, i, false, "?>");
        if (!a)
          throw new Error("Pi Tag is not closed.");
        if (n = this.saveTextToParentTag(n, r, s), !(this.options.ignoreDeclaration && a.tagName === "?xml" || this.options.ignorePiTags)) {
          const c2 = new ft(a.tagName);
          c2.add(this.options.textNodeName, ""), a.tagName !== a.tagExp && a.attrExpPresent && (c2[":@"] = this.buildAttributesMap(a.tagExp, s, a.tagName)), this.addChild(r, c2, s);
        }
        i = a.closeIndex + 1;
      } else if (e.substr(i + 1, 3) === "!--") {
        const a = Xe(e, "-->", i + 4, "Comment is not closed.");
        if (this.options.commentPropName) {
          const c2 = e.substring(i + 4, a - 2);
          n = this.saveTextToParentTag(n, r, s), r.add(this.options.commentPropName, [{ [this.options.textNodeName]: c2 }]);
        }
        i = a;
      } else if (e.substr(i + 1, 2) === "!D") {
        const a = gh(e, i);
        this.docTypeEntities = a.entities, i = a.i;
      } else if (e.substr(i + 1, 2) === "![") {
        const a = Xe(e, "]]>", i, "CDATA is not closed.") - 2, c2 = e.substring(i + 9, a);
        if (n = this.saveTextToParentTag(n, r, s), this.options.cdataPropName)
          r.add(this.options.cdataPropName, [{ [this.options.textNodeName]: c2 }]);
        else {
          let u = this.parseTextData(c2, r.tagname, s, true, false, true);
          u == null && (u = ""), r.add(this.options.textNodeName, u);
        }
        i = a + 2;
      } else {
        let a = yn(e, i, this.options.removeNSPrefix), c2 = a.tagName, u = a.tagExp, l = a.attrExpPresent, h = a.closeIndex;
        this.options.transformTagName && (c2 = this.options.transformTagName(c2)), r && n && r.tagname !== "!xml" && (n = this.saveTextToParentTag(n, r, s, false));
        const p = r;
        if (p && this.options.unpairedTags.indexOf(p.tagname) !== -1 && (r = this.tagsNodeStack.pop(), s = s.substring(0, s.lastIndexOf("."))), c2 !== t.tagname && (s += s ? "." + c2 : c2), this.isItStopNode(this.options.stopNodes, s, c2)) {
          let g = "";
          if (u.length > 0 && u.lastIndexOf("/") === u.length - 1)
            i = a.closeIndex;
          else if (this.options.unpairedTags.indexOf(c2) !== -1)
            i = a.closeIndex;
          else {
            const A = this.readStopNodeData(e, c2, h + 1);
            if (!A)
              throw new Error(`Unexpected end of ${c2}`);
            i = A.i, g = A.tagContent;
          }
          const b = new ft(c2);
          c2 !== u && l && (b[":@"] = this.buildAttributesMap(u, s, c2)), g && (g = this.parseTextData(g, c2, s, true, l, true, true)), s = s.substr(0, s.lastIndexOf(".")), b.add(this.options.textNodeName, g), this.addChild(r, b, s);
        } else {
          if (u.length > 0 && u.lastIndexOf("/") === u.length - 1) {
            c2[c2.length - 1] === "/" ? (c2 = c2.substr(0, c2.length - 1), u = c2) : u = u.substr(0, u.length - 1), this.options.transformTagName && (c2 = this.options.transformTagName(c2));
            const g = new ft(c2);
            c2 !== u && l && (g[":@"] = this.buildAttributesMap(u, s, c2)), this.addChild(r, g, s), s = s.substr(0, s.lastIndexOf("."));
          } else {
            const g = new ft(c2);
            this.tagsNodeStack.push(r), c2 !== u && l && (g[":@"] = this.buildAttributesMap(u, s, c2)), this.addChild(r, g, s), r = g;
          }
          n = "", i = h;
        }
      }
    else
      n += e[i];
  return t.child;
};
function Ch(e, t, r) {
  const n = this.options.updateTag(t.tagname, r, t[":@"]);
  n === false || (typeof n == "string" && (t.tagname = n), e.addChild(t));
}
var vh = function(e) {
  if (this.options.processEntities) {
    for (let t in this.docTypeEntities) {
      const r = this.docTypeEntities[t];
      e = e.replace(r.regx, r.val);
    }
    for (let t in this.lastEntities) {
      const r = this.lastEntities[t];
      e = e.replace(r.regex, r.val);
    }
    if (this.options.htmlEntities)
      for (let t in this.htmlEntities) {
        const r = this.htmlEntities[t];
        e = e.replace(r.regex, r.val);
      }
    e = e.replace(this.ampEntity.regex, this.ampEntity.val);
  }
  return e;
};
function Rh(e, t, r, n) {
  return e && (n === void 0 && (n = Object.keys(t.child).length === 0), e = this.parseTextData(
    e,
    t.tagname,
    r,
    false,
    t[":@"] ? Object.keys(t[":@"]).length !== 0 : false,
    n
  ), e !== void 0 && e !== "" && t.add(this.options.textNodeName, e), e = ""), e;
}
function _h(e, t, r) {
  const n = "*." + r;
  for (const s in e) {
    const i = e[s];
    if (n === i || t === i)
      return true;
  }
  return false;
}
function Th(e, t, r = ">") {
  let n, s = "";
  for (let i = t; i < e.length; i++) {
    let o = e[i];
    if (n)
      o === n && (n = "");
    else if (o === '"' || o === "'")
      n = o;
    else if (o === r[0])
      if (r[1]) {
        if (e[i + 1] === r[1])
          return {
            data: s,
            index: i
          };
      } else
        return {
          data: s,
          index: i
        };
    else
      o === "	" && (o = " ");
    s += o;
  }
}
function Xe(e, t, r, n) {
  const s = e.indexOf(t, r);
  if (s === -1)
    throw new Error(n);
  return s + t.length - 1;
}
function yn(e, t, r, n = ">") {
  const s = Th(e, t + 1, n);
  if (!s)
    return;
  let i = s.data;
  const o = s.index, a = i.search(/\s/);
  let c2 = i, u = true;
  if (a !== -1 && (c2 = i.substr(0, a).replace(/\s\s*$/, ""), i = i.substr(a + 1)), r) {
    const l = c2.indexOf(":");
    l !== -1 && (c2 = c2.substr(l + 1), u = c2 !== s.data.substr(l + 1));
  }
  return {
    tagName: c2,
    tagExp: i,
    closeIndex: o,
    attrExpPresent: u
  };
}
function Bh(e, t, r) {
  const n = r;
  let s = 1;
  for (; r < e.length; r++)
    if (e[r] === "<")
      if (e[r + 1] === "/") {
        const i = Xe(e, ">", r, `${t} is not closed`);
        if (e.substring(r + 2, i).trim() === t && (s--, s === 0))
          return {
            tagContent: e.substring(n, r),
            i
          };
        r = i;
      } else if (e[r + 1] === "?")
        r = Xe(e, "?>", r + 1, "StopNode is not closed.");
      else if (e.substr(r + 1, 3) === "!--")
        r = Xe(e, "-->", r + 3, "StopNode is not closed.");
      else if (e.substr(r + 1, 2) === "![")
        r = Xe(e, "]]>", r, "StopNode is not closed.") - 2;
      else {
        const i = yn(e, r, ">");
        i && ((i && i.tagName) === t && i.tagExp[i.tagExp.length - 1] !== "/" && s++, r = i.closeIndex);
      }
}
function bn(e, t, r) {
  if (t && typeof e == "string") {
    const n = e.trim();
    return n === "true" ? true : n === "false" ? false : mh(e, r);
  } else
    return Yn.isExist(e) ? e : "";
}
var kh = yh;
var Na = {};
function Nh(e, t) {
  return Pa(e, t);
}
function Pa(e, t, r) {
  let n;
  const s = {};
  for (let i = 0; i < e.length; i++) {
    const o = e[i], a = Ph(o);
    let c2 = "";
    if (r === void 0 ? c2 = a : c2 = r + "." + a, a === t.textNodeName)
      n === void 0 ? n = o[a] : n += "" + o[a];
    else {
      if (a === void 0)
        continue;
      if (o[a]) {
        let u = Pa(o[a], t, c2);
        const l = Mh(u, t);
        o[":@"] ? Oh(u, o[":@"], c2, t) : Object.keys(u).length === 1 && u[t.textNodeName] !== void 0 && !t.alwaysCreateTextNode ? u = u[t.textNodeName] : Object.keys(u).length === 0 && (t.alwaysCreateTextNode ? u[t.textNodeName] = "" : u = ""), s[a] !== void 0 && s.hasOwnProperty(a) ? (Array.isArray(s[a]) || (s[a] = [s[a]]), s[a].push(u)) : t.isArray(a, c2, l) ? s[a] = [u] : s[a] = u;
      }
    }
  }
  return typeof n == "string" ? n.length > 0 && (s[t.textNodeName] = n) : n !== void 0 && (s[t.textNodeName] = n), s;
}
function Ph(e) {
  const t = Object.keys(e);
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    if (n !== ":@")
      return n;
  }
}
function Oh(e, t, r, n) {
  if (t) {
    const s = Object.keys(t), i = s.length;
    for (let o = 0; o < i; o++) {
      const a = s[o];
      n.isArray(a, r + "." + a, true, true) ? e[a] = [t[a]] : e[a] = t[a];
    }
  }
}
function Mh(e, t) {
  const { textNodeName: r } = t, n = Object.keys(e).length;
  return !!(n === 0 || n === 1 && (e[r] || typeof e[r] == "boolean" || e[r] === 0));
}
Na.prettify = Nh;
var { buildOptions: Ih } = Zn;
var Fh = kh;
var { prettify: Dh } = Na;
var Uh = Kn;
var $h = class {
  constructor(t) {
    this.externalEntities = {}, this.options = Ih(t);
  }
  /**
   * Parse XML dats to JS object 
   * @param {string|Buffer} xmlData 
   * @param {boolean|Object} validationOption 
   */
  parse(t, r) {
    if (typeof t != "string")
      if (t.toString)
        t = t.toString();
      else
        throw new Error("XML data is accepted in String or Bytes[] form.");
    if (r) {
      r === true && (r = {});
      const i = Uh.validate(t, r);
      if (i !== true)
        throw Error(`${i.err.msg}:${i.err.line}:${i.err.col}`);
    }
    const n = new Fh(this.options);
    n.addExternalEntities(this.externalEntities);
    const s = n.parseXml(t);
    return this.options.preserveOrder || s === void 0 ? s : Dh(s, this.options);
  }
  /**
   * Add Entity which is not by default supported by this library
   * @param {string} key 
   * @param {string} value 
   */
  addEntity(t, r) {
    if (r.indexOf("&") !== -1)
      throw new Error("Entity value can't have '&'");
    if (t.indexOf("&") !== -1 || t.indexOf(";") !== -1)
      throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
    if (r === "&")
      throw new Error("An entity with value '&' is not permitted");
    this.externalEntities[t] = r;
  }
};
var Lh = $h;
var Hh = `
`;
function jh(e, t) {
  let r = "";
  return t.format && t.indentBy.length > 0 && (r = Hh), Oa(e, t, "", r);
}
function Oa(e, t, r, n) {
  let s = "", i = false;
  for (let o = 0; o < e.length; o++) {
    const a = e[o], c2 = zh(a);
    let u = "";
    if (r.length === 0 ? u = c2 : u = `${r}.${c2}`, c2 === t.textNodeName) {
      let b = a[c2];
      qh(u, t) || (b = t.tagValueProcessor(c2, b), b = Ma(b, t)), i && (s += n), s += b, i = false;
      continue;
    } else if (c2 === t.cdataPropName) {
      i && (s += n), s += `<![CDATA[${a[c2][0][t.textNodeName]}]]>`, i = false;
      continue;
    } else if (c2 === t.commentPropName) {
      s += n + `<!--${a[c2][0][t.textNodeName]}-->`, i = true;
      continue;
    } else if (c2[0] === "?") {
      const b = Ys(a[":@"], t), A = c2 === "?xml" ? "" : n;
      let R = a[c2][0][t.textNodeName];
      R = R.length !== 0 ? " " + R : "", s += A + `<${c2}${R}${b}?>`, i = true;
      continue;
    }
    let l = n;
    l !== "" && (l += t.indentBy);
    const h = Ys(a[":@"], t), p = n + `<${c2}${h}`, g = Oa(a[c2], t, u, l);
    t.unpairedTags.indexOf(c2) !== -1 ? t.suppressUnpairedNode ? s += p + ">" : s += p + "/>" : (!g || g.length === 0) && t.suppressEmptyNode ? s += p + "/>" : g && g.endsWith(">") ? s += p + `>${g}${n}</${c2}>` : (s += p + ">", g && n !== "" && (g.includes("/>") || g.includes("</")) ? s += n + t.indentBy + g + n : s += g, s += `</${c2}>`), i = true;
  }
  return s;
}
function zh(e) {
  const t = Object.keys(e);
  for (let r = 0; r < t.length; r++) {
    const n = t[r];
    if (n !== ":@")
      return n;
  }
}
function Ys(e, t) {
  let r = "";
  if (e && !t.ignoreAttributes)
    for (let n in e) {
      let s = t.attributeValueProcessor(n, e[n]);
      s = Ma(s, t), s === true && t.suppressBooleanAttributes ? r += ` ${n.substr(t.attributeNamePrefix.length)}` : r += ` ${n.substr(t.attributeNamePrefix.length)}="${s}"`;
    }
  return r;
}
function qh(e, t) {
  e = e.substr(0, e.length - t.textNodeName.length - 1);
  let r = e.substr(e.lastIndexOf(".") + 1);
  for (let n in t.stopNodes)
    if (t.stopNodes[n] === e || t.stopNodes[n] === "*." + r)
      return true;
  return false;
}
function Ma(e, t) {
  if (e && e.length > 0 && t.processEntities)
    for (let r = 0; r < t.entities.length; r++) {
      const n = t.entities[r];
      e = e.replace(n.regex, n.val);
    }
  return e;
}
var Wh = jh;
var Gh = Wh;
var Vh = {
  attributeNamePrefix: "@_",
  attributesGroupName: false,
  textNodeName: "#text",
  ignoreAttributes: true,
  cdataPropName: false,
  format: false,
  indentBy: "  ",
  suppressEmptyNode: false,
  suppressUnpairedNode: true,
  suppressBooleanAttributes: true,
  tagValueProcessor: function(e, t) {
    return t;
  },
  attributeValueProcessor: function(e, t) {
    return t;
  },
  preserveOrder: false,
  commentPropName: false,
  unpairedTags: [],
  entities: [
    { regex: new RegExp("&", "g"), val: "&amp;" },
    //it must be on top
    { regex: new RegExp(">", "g"), val: "&gt;" },
    { regex: new RegExp("<", "g"), val: "&lt;" },
    { regex: new RegExp("'", "g"), val: "&apos;" },
    { regex: new RegExp('"', "g"), val: "&quot;" }
  ],
  processEntities: true,
  stopNodes: [],
  // transformTagName: false,
  // transformAttributeName: false,
  oneListGroup: false
};
function qe(e) {
  this.options = Object.assign({}, Vh, e), this.options.ignoreAttributes || this.options.attributesGroupName ? this.isAttribute = function() {
    return false;
  } : (this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = Zh), this.processTextOrObjNode = Kh, this.options.format ? (this.indentate = Xh, this.tagEndChar = `>
`, this.newLine = `
`) : (this.indentate = function() {
    return "";
  }, this.tagEndChar = ">", this.newLine = "");
}
qe.prototype.build = function(e) {
  return this.options.preserveOrder ? Gh(e, this.options) : (Array.isArray(e) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (e = {
    [this.options.arrayNodeName]: e
  }), this.j2x(e, 0).val);
};
qe.prototype.j2x = function(e, t) {
  let r = "", n = "";
  for (let s in e)
    if (!(typeof e[s] > "u"))
      if (e[s] === null)
        s[0] === "?" ? n += this.indentate(t) + "<" + s + "?" + this.tagEndChar : n += this.indentate(t) + "<" + s + "/" + this.tagEndChar;
      else if (e[s] instanceof Date)
        n += this.buildTextValNode(e[s], s, "", t);
      else if (typeof e[s] != "object") {
        const i = this.isAttribute(s);
        if (i)
          r += this.buildAttrPairStr(i, "" + e[s]);
        else if (s === this.options.textNodeName) {
          let o = this.options.tagValueProcessor(s, "" + e[s]);
          n += this.replaceEntitiesValue(o);
        } else
          n += this.buildTextValNode(e[s], s, "", t);
      } else if (Array.isArray(e[s])) {
        const i = e[s].length;
        let o = "";
        for (let a = 0; a < i; a++) {
          const c2 = e[s][a];
          typeof c2 > "u" || (c2 === null ? s[0] === "?" ? n += this.indentate(t) + "<" + s + "?" + this.tagEndChar : n += this.indentate(t) + "<" + s + "/" + this.tagEndChar : typeof c2 == "object" ? this.options.oneListGroup ? o += this.j2x(c2, t + 1).val : o += this.processTextOrObjNode(c2, s, t) : o += this.buildTextValNode(c2, s, "", t));
        }
        this.options.oneListGroup && (o = this.buildObjectNode(o, s, "", t)), n += o;
      } else if (this.options.attributesGroupName && s === this.options.attributesGroupName) {
        const i = Object.keys(e[s]), o = i.length;
        for (let a = 0; a < o; a++)
          r += this.buildAttrPairStr(i[a], "" + e[s][i[a]]);
      } else
        n += this.processTextOrObjNode(e[s], s, t);
  return { attrStr: r, val: n };
};
qe.prototype.buildAttrPairStr = function(e, t) {
  return t = this.options.attributeValueProcessor(e, "" + t), t = this.replaceEntitiesValue(t), this.options.suppressBooleanAttributes && t === "true" ? " " + e : " " + e + '="' + t + '"';
};
function Kh(e, t, r) {
  const n = this.j2x(e, r + 1);
  return e[this.options.textNodeName] !== void 0 && Object.keys(e).length === 1 ? this.buildTextValNode(e[this.options.textNodeName], t, n.attrStr, r) : this.buildObjectNode(n.val, t, n.attrStr, r);
}
qe.prototype.buildObjectNode = function(e, t, r, n) {
  if (e === "")
    return t[0] === "?" ? this.indentate(n) + "<" + t + r + "?" + this.tagEndChar : this.indentate(n) + "<" + t + r + this.closeTag(t) + this.tagEndChar;
  {
    let s = "</" + t + this.tagEndChar, i = "";
    return t[0] === "?" && (i = "?", s = ""), r && e.indexOf("<") === -1 ? this.indentate(n) + "<" + t + r + i + ">" + e + s : this.options.commentPropName !== false && t === this.options.commentPropName && i.length === 0 ? this.indentate(n) + `<!--${e}-->` + this.newLine : this.indentate(n) + "<" + t + r + i + this.tagEndChar + e + this.indentate(n) + s;
  }
};
qe.prototype.closeTag = function(e) {
  let t = "";
  return this.options.unpairedTags.indexOf(e) !== -1 ? this.options.suppressUnpairedNode || (t = "/") : this.options.suppressEmptyNode ? t = "/" : t = `></${e}`, t;
};
qe.prototype.buildTextValNode = function(e, t, r, n) {
  if (this.options.cdataPropName !== false && t === this.options.cdataPropName)
    return this.indentate(n) + `<![CDATA[${e}]]>` + this.newLine;
  if (this.options.commentPropName !== false && t === this.options.commentPropName)
    return this.indentate(n) + `<!--${e}-->` + this.newLine;
  if (t[0] === "?")
    return this.indentate(n) + "<" + t + r + "?" + this.tagEndChar;
  {
    let s = this.options.tagValueProcessor(t, e);
    return s = this.replaceEntitiesValue(s), s === "" ? this.indentate(n) + "<" + t + r + this.closeTag(t) + this.tagEndChar : this.indentate(n) + "<" + t + r + ">" + s + "</" + t + this.tagEndChar;
  }
};
qe.prototype.replaceEntitiesValue = function(e) {
  if (e && e.length > 0 && this.options.processEntities)
    for (let t = 0; t < this.options.entities.length; t++) {
      const r = this.options.entities[t];
      e = e.replace(r.regex, r.val);
    }
  return e;
};
function Xh(e) {
  return this.options.indentBy.repeat(e);
}
function Zh(e) {
  return e.startsWith(this.options.attributeNamePrefix) ? e.substr(this.attrPrefixLen) : false;
}
var Yh = qe;
var Qh = Kn;
var Jh = Lh;
var ep = Yh;
var tp = {
  XMLParser: Jh,
  XMLValidator: Qh,
  XMLBuilder: ep
};
var Ia = (e, t) => Lf(e, t).then((r) => {
  if (r.length) {
    const n = new tp.XMLParser({
      attributeNamePrefix: "",
      htmlEntities: true,
      ignoreAttributes: false,
      ignoreDeclaration: true,
      parseTagValue: false,
      trimValues: false,
      tagValueProcessor: (c2, u) => u.trim() === "" && u.includes(`
`) ? "" : void 0
    });
    n.addEntity("#xD", "\r"), n.addEntity("#10", `
`);
    let s;
    try {
      s = n.parse(r, true);
    } catch (c2) {
      throw c2 && typeof c2 == "object" && Object.defineProperty(c2, "$responseBodyText", {
        value: r
      }), c2;
    }
    const i = "#text", o = Object.keys(s)[0], a = s[o];
    return a[i] && (a[o] = a[i], delete a[i]), Yo(a);
  }
  return {};
});
var rp = async (e, t) => {
  const r = await Ia(e, t);
  return r.Error && (r.Error.message = r.Error.message ?? r.Error.Message), r;
};
var np = (e, t) => {
  var r;
  if (((r = t == null ? void 0 : t.Error) == null ? void 0 : r.Code) !== void 0)
    return t.Error.Code;
  if ((t == null ? void 0 : t.Code) !== void 0)
    return t.Code;
  if (e.statusCode == 404)
    return "NotFound";
};
var Qn = class _Qn extends Ee {
  constructor(t) {
    super({
      name: "ObjectAlreadyInActiveTierError",
      $fault: "client",
      ...t
    }), this.name = "ObjectAlreadyInActiveTierError", this.$fault = "client", Object.setPrototypeOf(this, _Qn.prototype);
  }
};
var Qs;
(function(e) {
  e.visit = (t, r) => t.Records !== void 0 ? r.Records(t.Records) : t.Stats !== void 0 ? r.Stats(t.Stats) : t.Progress !== void 0 ? r.Progress(t.Progress) : t.Cont !== void 0 ? r.Cont(t.Cont) : t.End !== void 0 ? r.End(t.End) : r._(t.$unknown[0], t.$unknown[1]);
})(Qs || (Qs = {}));
var sp = (e) => ({
  ...e,
  ...e.SSEKMSKeyId && { SSEKMSKeyId: Ye },
  ...e.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: Ye }
});
var ip = (e) => ({
  ...e,
  ...e.SSECustomerKey && { SSECustomerKey: Ye },
  ...e.SSEKMSKeyId && { SSEKMSKeyId: Ye },
  ...e.SSEKMSEncryptionContext && { SSEKMSEncryptionContext: Ye }
});
var op = async (e, t) => {
  const r = Ba(e, t), n = ae({}, st, {
    [tg]: e[$p]
  });
  r.bp("/"), r.p("Bucket", () => e.Bucket, "{Bucket}", false);
  const s = ae({
    [Jp]: [, ""]
  });
  let i;
  return r.m("GET").h(n).q(s).b(i), r.build();
};
var ap = async (e, t) => {
  const r = Ba(e, t), n = ae({}, st, {
    [Zp]: e[Tp] || "application/octet-stream",
    [eg]: e[Ep],
    [qp]: e[Sp],
    [Wp]: e[Cp],
    [Gp]: e[vp],
    [Vp]: e[Rp],
    [Kp]: [() => st(e[Js]), () => e[Js].toString()],
    [Xp]: e[_p],
    [pg]: e[Ap],
    [Ga]: e[Da],
    [Va]: e[Ua],
    [Ka]: e[$a],
    [Xa]: e[La],
    [Yp]: [() => st(e[ei]), () => Pu(e[ei]).toString()],
    [sg]: e[Np],
    [ig]: e[Pp],
    [og]: e[Op],
    [ag]: e[Mp],
    [Za]: e[Ha],
    [hg]: e[Vt],
    [bg]: e[zp],
    [Ja]: e[ja],
    [gg]: e[Lp],
    [ec]: e[za],
    [Ya]: e[Wa],
    [Qa]: e[qa],
    [xn]: [() => st(e[wn]), () => e[wn].toString()],
    [fg]: e[Up],
    [mg]: e[Hp],
    [ug]: e[Fp],
    [dg]: [() => st(e[ti]), () => rd(e[ti]).toString()],
    [cg]: e[Ip],
    [ng]: e[Bp],
    ...e.Metadata !== void 0 && Object.keys(e.Metadata).reduce((a, c2) => (a[`x-amz-meta-${c2.toLowerCase()}`] = e.Metadata[c2], a), {})
  });
  r.bp("/{Key+}"), r.p("Bucket", () => e.Bucket, "{Bucket}", false), r.p("Key", () => e.Key, "{Key+}", true);
  const s = ae({
    [wg]: [, "PutObject"]
  });
  let i, o;
  return e.Body !== void 0 && (o = e.Body, i = o), r.m("PUT").h(n).q(s).b(i), r.build();
};
var cp = async (e, t) => {
  if (e.statusCode !== 200 && e.statusCode >= 300)
    return Fa(e, t);
  const r = ae({
    $metadata: Re(e)
  }), n = Go(Ru(await Ia(e.body, t)), "body");
  return n[Sr] != null && (r[Sr] = xp(n[Sr])), r;
};
var up = async (e, t) => {
  if (e.statusCode !== 200 && e.statusCode >= 300)
    return Fa(e, t);
  const r = ae({
    $metadata: Re(e),
    [Gt]: [, e.headers[rg]],
    [kp]: [, e.headers[Qp]],
    [Da]: [, e.headers[Ga]],
    [Ua]: [, e.headers[Va]],
    [$a]: [, e.headers[Ka]],
    [La]: [, e.headers[Xa]],
    [Ha]: [, e.headers[Za]],
    [jp]: [, e.headers[yg]],
    [ja]: [, e.headers[Ja]],
    [za]: [, e.headers[ec]],
    [Wa]: [, e.headers[Ya]],
    [qa]: [, e.headers[Qa]],
    [wn]: [() => e.headers[xn] !== void 0, () => Eu(e.headers[xn])],
    [Dp]: [, e.headers[lg]]
  });
  return await qo(e.body, t), r;
};
var Fa = async (e, t) => {
  const r = {
    ...e,
    body: await rp(e.body, t)
  }, n = np(e, r.body);
  switch (n) {
    case "NoSuchUpload":
    case "com.amazonaws.s3#NoSuchUpload":
      throw await mp(r);
    case "ObjectNotInActiveTierError":
    case "com.amazonaws.s3#ObjectNotInActiveTierError":
      throw await wp(r);
    case "BucketAlreadyExists":
    case "com.amazonaws.s3#BucketAlreadyExists":
      throw await lp(r);
    case "BucketAlreadyOwnedByYou":
    case "com.amazonaws.s3#BucketAlreadyOwnedByYou":
      throw await fp(r);
    case "NoSuchBucket":
    case "com.amazonaws.s3#NoSuchBucket":
      throw await pp(r);
    case "InvalidObjectState":
    case "com.amazonaws.s3#InvalidObjectState":
      throw await hp(r);
    case "NoSuchKey":
    case "com.amazonaws.s3#NoSuchKey":
      throw await gp(r);
    case "NotFound":
    case "com.amazonaws.s3#NotFound":
      throw await yp(r);
    case "ObjectAlreadyInActiveTierError":
    case "com.amazonaws.s3#ObjectAlreadyInActiveTierError":
      throw await bp(r);
    default:
      const s = r.body;
      return dp({
        output: e,
        parsedBody: s,
        errorCode: n
      });
  }
};
var dp = ju(Ee);
var lp = async (e, t) => {
  const r = ae({});
  e.body;
  const n = new jn({
    $metadata: Re(e),
    ...r
  });
  return Ne(n, e.body);
};
var fp = async (e, t) => {
  const r = ae({});
  e.body;
  const n = new zn({
    $metadata: Re(e),
    ...r
  });
  return Ne(n, e.body);
};
var hp = async (e, t) => {
  const r = ae({}), n = e.body;
  n[Ar] != null && (r[Ar] = Ot(n[Ar])), n[Vt] != null && (r[Vt] = Ot(n[Vt]));
  const s = new Wn({
    $metadata: Re(e),
    ...r
  });
  return Ne(s, e.body);
};
var pp = async (e, t) => {
  const r = ae({});
  e.body;
  const n = new qn({
    $metadata: Re(e),
    ...r
  });
  return Ne(n, e.body);
};
var gp = async (e, t) => {
  const r = ae({});
  e.body;
  const n = new Gn({
    $metadata: Re(e),
    ...r
  });
  return Ne(n, e.body);
};
var mp = async (e, t) => {
  const r = ae({});
  e.body;
  const n = new Ln({
    $metadata: Re(e),
    ...r
  });
  return Ne(n, e.body);
};
var yp = async (e, t) => {
  const r = ae({});
  e.body;
  const n = new Vn({
    $metadata: Re(e),
    ...r
  });
  return Ne(n, e.body);
};
var bp = async (e, t) => {
  const r = ae({});
  e.body;
  const n = new Qn({
    $metadata: Re(e),
    ...r
  });
  return Ne(n, e.body);
};
var wp = async (e, t) => {
  const r = ae({});
  e.body;
  const n = new Hn({
    $metadata: Re(e),
    ...r
  });
  return Ne(n, e.body);
};
var xp = (e, t) => {
  const r = {};
  return e[Er] != null && (r[Er] = Ot(e[Er])), e[Cr] != null && (r[Cr] = Ot(e[Cr])), e[vr] != null && (r[vr] = Ot(e[vr])), e[Gt] != null && (r[Gt] = Go(Mu(e[Gt]))), r;
};
var Re = (e) => ({
  httpStatusCode: e.statusCode,
  requestId: e.headers["x-amzn-requestid"] ?? e.headers["x-amzn-request-id"] ?? e.headers["x-amz-request-id"],
  extendedRequestId: e.headers["x-amz-id-2"],
  cfId: e.headers["x-amz-cf-id"]
});
var st = (e) => e != null && e !== "" && (!Object.getOwnPropertyNames(e).includes("length") || e.length != 0) && (!Object.getOwnPropertyNames(e).includes("size") || e.size != 0);
var Ep = "ACL";
var Er = "AccessKeyId";
var Ar = "AccessTier";
var wn = "BucketKeyEnabled";
var Sr = "Credentials";
var Ap = "ChecksumAlgorithm";
var Sp = "CacheControl";
var Da = "ChecksumCRC32";
var Ua = "ChecksumCRC32C";
var Cp = "ContentDisposition";
var vp = "ContentEncoding";
var Rp = "ContentLanguage";
var Js = "ContentLength";
var _p = "ContentMD5";
var $a = "ChecksumSHA1";
var La = "ChecksumSHA256";
var Tp = "ContentType";
var ei = "Expires";
var Bp = "ExpectedBucketOwner";
var kp = "ETag";
var Gt = "Expiration";
var Np = "GrantFullControl";
var Pp = "GrantRead";
var Op = "GrantReadACP";
var Mp = "GrantWriteACP";
var Ip = "ObjectLockLegalHoldStatus";
var Fp = "ObjectLockMode";
var ti = "ObjectLockRetainUntilDate";
var Dp = "RequestCharged";
var Up = "RequestPayer";
var Cr = "SecretAccessKey";
var Vt = "StorageClass";
var $p = "SessionMode";
var Ha = "ServerSideEncryption";
var ja = "SSECustomerAlgorithm";
var Lp = "SSECustomerKey";
var za = "SSECustomerKeyMD5";
var qa = "SSEKMSEncryptionContext";
var Wa = "SSEKMSKeyId";
var vr = "SessionToken";
var Hp = "Tagging";
var jp = "VersionId";
var zp = "WebsiteRedirectLocation";
var qp = "cache-control";
var Wp = "content-disposition";
var Gp = "content-encoding";
var Vp = "content-language";
var Kp = "content-length";
var Xp = "content-md5";
var Zp = "content-type";
var Yp = "expires";
var Qp = "etag";
var Jp = "session";
var eg = "x-amz-acl";
var Ga = "x-amz-checksum-crc32";
var Va = "x-amz-checksum-crc32c";
var Ka = "x-amz-checksum-sha1";
var Xa = "x-amz-checksum-sha256";
var tg = "x-amz-create-session-mode";
var rg = "x-amz-expiration";
var ng = "x-amz-expected-bucket-owner";
var sg = "x-amz-grant-full-control";
var ig = "x-amz-grant-read";
var og = "x-amz-grant-read-acp";
var ag = "x-amz-grant-write-acp";
var cg = "x-amz-object-lock-legal-hold";
var ug = "x-amz-object-lock-mode";
var dg = "x-amz-object-lock-retain-until-date";
var lg = "x-amz-request-charged";
var fg = "x-amz-request-payer";
var hg = "x-amz-storage-class";
var pg = "x-amz-sdk-checksum-algorithm";
var Za = "x-amz-server-side-encryption";
var Ya = "x-amz-server-side-encryption-aws-kms-key-id";
var xn = "x-amz-server-side-encryption-bucket-key-enabled";
var Qa = "x-amz-server-side-encryption-context";
var Ja = "x-amz-server-side-encryption-customer-algorithm";
var gg = "x-amz-server-side-encryption-customer-key";
var ec = "x-amz-server-side-encryption-customer-key-md5";
var mg = "x-amz-tagging";
var yg = "x-amz-version-id";
var bg = "x-amz-website-redirect-location";
var wg = "x-id";
var xg = class extends On.classBuilder().ep({
  ...Ta,
  DisableS3ExpressSessionAuth: { type: "staticContextParams", value: true },
  Bucket: { type: "contextParams", name: "Bucket" }
}).m(function(t, r, n, s) {
  return [
    xa(n, this.serialize, this.deserialize),
    Aa(n, t.getEndpointParameterInstructions())
  ];
}).s("AmazonS3", "CreateSession", {}).n("S3Client", "CreateSessionCommand").f(void 0, Uf).ser(op).de(cp).build() {
};
var Eg = "@aws-sdk/client-s3";
var Ag = "AWS SDK for JavaScript S3 Client for Node.js, Browser and React Native";
var Sg = "3.596.0";
var Cg = {
  build: "concurrently 'yarn:build:cjs' 'yarn:build:es' 'yarn:build:types'",
  "build:cjs": "node ../../scripts/compilation/inline client-s3",
  "build:es": "tsc -p tsconfig.es.json",
  "build:include:deps": "lerna run --scope $npm_package_name --include-dependencies build",
  "build:types": "tsc -p tsconfig.types.json",
  "build:types:downlevel": "downlevel-dts dist-types dist-types/ts3.4",
  clean: "rimraf ./dist-* && rimraf *.tsbuildinfo",
  "extract:docs": "api-extractor run --local",
  "generate:client": "node ../../scripts/generate-clients/single-service --solo s3",
  test: "yarn test:unit",
  "test:e2e": "yarn test:e2e:node && yarn test:e2e:browser",
  "test:e2e:browser": "ts-mocha test/**/*.browser.ispec.ts && karma start karma.conf.js",
  "test:e2e:node": "jest --c jest.config.e2e.js",
  "test:unit": "ts-mocha test/unit/**/*.spec.ts"
};
var vg = "./dist-cjs/index.js";
var Rg = "./dist-types/index.d.ts";
var _g = "./dist-es/index.js";
var Tg = false;
var Bg = {
  "@aws-crypto/sha1-browser": "3.0.0",
  "@aws-crypto/sha256-browser": "3.0.0",
  "@aws-crypto/sha256-js": "3.0.0",
  "@aws-sdk/client-sso-oidc": "3.596.0",
  "@aws-sdk/client-sts": "3.596.0",
  "@aws-sdk/core": "3.592.0",
  "@aws-sdk/credential-provider-node": "3.596.0",
  "@aws-sdk/middleware-bucket-endpoint": "3.587.0",
  "@aws-sdk/middleware-expect-continue": "3.577.0",
  "@aws-sdk/middleware-flexible-checksums": "3.587.0",
  "@aws-sdk/middleware-host-header": "3.577.0",
  "@aws-sdk/middleware-location-constraint": "3.577.0",
  "@aws-sdk/middleware-logger": "3.577.0",
  "@aws-sdk/middleware-recursion-detection": "3.577.0",
  "@aws-sdk/middleware-sdk-s3": "3.587.0",
  "@aws-sdk/middleware-signing": "3.587.0",
  "@aws-sdk/middleware-ssec": "3.577.0",
  "@aws-sdk/middleware-user-agent": "3.587.0",
  "@aws-sdk/region-config-resolver": "3.587.0",
  "@aws-sdk/signature-v4-multi-region": "3.587.0",
  "@aws-sdk/types": "3.577.0",
  "@aws-sdk/util-endpoints": "3.587.0",
  "@aws-sdk/util-user-agent-browser": "3.577.0",
  "@aws-sdk/util-user-agent-node": "3.587.0",
  "@aws-sdk/xml-builder": "3.575.0",
  "@smithy/config-resolver": "^3.0.1",
  "@smithy/core": "^2.2.0",
  "@smithy/eventstream-serde-browser": "^3.0.0",
  "@smithy/eventstream-serde-config-resolver": "^3.0.0",
  "@smithy/eventstream-serde-node": "^3.0.0",
  "@smithy/fetch-http-handler": "^3.0.1",
  "@smithy/hash-blob-browser": "^3.0.0",
  "@smithy/hash-node": "^3.0.0",
  "@smithy/hash-stream-node": "^3.0.0",
  "@smithy/invalid-dependency": "^3.0.0",
  "@smithy/md5-js": "^3.0.0",
  "@smithy/middleware-content-length": "^3.0.0",
  "@smithy/middleware-endpoint": "^3.0.1",
  "@smithy/middleware-retry": "^3.0.3",
  "@smithy/middleware-serde": "^3.0.0",
  "@smithy/middleware-stack": "^3.0.0",
  "@smithy/node-config-provider": "^3.1.0",
  "@smithy/node-http-handler": "^3.0.0",
  "@smithy/protocol-http": "^4.0.0",
  "@smithy/smithy-client": "^3.1.1",
  "@smithy/types": "^3.0.0",
  "@smithy/url-parser": "^3.0.0",
  "@smithy/util-base64": "^3.0.0",
  "@smithy/util-body-length-browser": "^3.0.0",
  "@smithy/util-body-length-node": "^3.0.0",
  "@smithy/util-defaults-mode-browser": "^3.0.3",
  "@smithy/util-defaults-mode-node": "^3.0.3",
  "@smithy/util-endpoints": "^2.0.1",
  "@smithy/util-retry": "^3.0.0",
  "@smithy/util-stream": "^3.0.1",
  "@smithy/util-utf8": "^3.0.0",
  "@smithy/util-waiter": "^3.0.0",
  tslib: "^2.6.2"
};
var kg = {
  "@aws-sdk/signature-v4-crt": "3.587.0",
  "@tsconfig/node16": "16.1.3",
  "@types/chai": "^4.2.11",
  "@types/mocha": "^8.0.4",
  "@types/node": "^16.18.96",
  concurrently: "7.0.0",
  "downlevel-dts": "0.10.1",
  rimraf: "3.0.2",
  typescript: "~4.9.5"
};
var Ng = {
  node: ">=16.0.0"
};
var Pg = {
  "<4.0": {
    "dist-types/*": [
      "dist-types/ts3.4/*"
    ]
  }
};
var Og = [
  "dist-*/**"
];
var Mg = {
  name: "AWS SDK for JavaScript Team",
  url: "https://aws.amazon.com/javascript/"
};
var Ig = "Apache-2.0";
var Fg = {
  "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.browser"
};
var Dg = "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-s3";
var Ug = {
  type: "git",
  url: "https://github.com/aws/aws-sdk-js-v3.git",
  directory: "clients/client-s3"
};
var $g = {
  name: Eg,
  description: Ag,
  version: Sg,
  scripts: Cg,
  main: vg,
  types: Rg,
  module: _g,
  sideEffects: Tg,
  dependencies: Bg,
  devDependencies: kg,
  engines: Ng,
  typesVersions: Pg,
  files: Og,
  author: Mg,
  license: Ig,
  browser: Fg,
  "react-native": {
    "./dist-es/runtimeConfig": "./dist-es/runtimeConfig.native"
  },
  homepage: Dg,
  repository: Ug
};
var tc = {};
var En = function(e, t) {
  return En = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, n) {
    r.__proto__ = n;
  } || function(r, n) {
    for (var s in n)
      n.hasOwnProperty(s) && (r[s] = n[s]);
  }, En(e, t);
};
function Lg(e, t) {
  En(e, t);
  function r() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (r.prototype = t.prototype, new r());
}
var An = function() {
  return An = Object.assign || function(t) {
    for (var r, n = 1, s = arguments.length; n < s; n++) {
      r = arguments[n];
      for (var i in r)
        Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]);
    }
    return t;
  }, An.apply(this, arguments);
};
function Hg(e, t) {
  var r = {};
  for (var n in e)
    Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var s = 0, n = Object.getOwnPropertySymbols(e); s < n.length; s++)
      t.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[s]) && (r[n[s]] = e[n[s]]);
  return r;
}
function jg(e, t, r, n) {
  var s = arguments.length, i = s < 3 ? t : n === null ? n = Object.getOwnPropertyDescriptor(t, r) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    i = Reflect.decorate(e, t, r, n);
  else
    for (var a = e.length - 1; a >= 0; a--)
      (o = e[a]) && (i = (s < 3 ? o(i) : s > 3 ? o(t, r, i) : o(t, r)) || i);
  return s > 3 && i && Object.defineProperty(t, r, i), i;
}
function zg(e, t) {
  return function(r, n) {
    t(r, n, e);
  };
}
function qg(e, t) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(e, t);
}
function Wg(e, t, r, n) {
  function s(i) {
    return i instanceof r ? i : new r(function(o) {
      o(i);
    });
  }
  return new (r || (r = Promise))(function(i, o) {
    function a(l) {
      try {
        u(n.next(l));
      } catch (h) {
        o(h);
      }
    }
    function c2(l) {
      try {
        u(n.throw(l));
      } catch (h) {
        o(h);
      }
    }
    function u(l) {
      l.done ? i(l.value) : s(l.value).then(a, c2);
    }
    u((n = n.apply(e, t || [])).next());
  });
}
function Gg(e, t) {
  var r = { label: 0, sent: function() {
    if (i[0] & 1)
      throw i[1];
    return i[1];
  }, trys: [], ops: [] }, n, s, i, o;
  return o = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
    return this;
  }), o;
  function a(u) {
    return function(l) {
      return c2([u, l]);
    };
  }
  function c2(u) {
    if (n)
      throw new TypeError("Generator is already executing.");
    for (; r; )
      try {
        if (n = 1, s && (i = u[0] & 2 ? s.return : u[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, u[1])).done)
          return i;
        switch (s = 0, i && (u = [u[0] & 2, i.value]), u[0]) {
          case 0:
          case 1:
            i = u;
            break;
          case 4:
            return r.label++, { value: u[1], done: false };
          case 5:
            r.label++, s = u[1], u = [0];
            continue;
          case 7:
            u = r.ops.pop(), r.trys.pop();
            continue;
          default:
            if (i = r.trys, !(i = i.length > 0 && i[i.length - 1]) && (u[0] === 6 || u[0] === 2)) {
              r = 0;
              continue;
            }
            if (u[0] === 3 && (!i || u[1] > i[0] && u[1] < i[3])) {
              r.label = u[1];
              break;
            }
            if (u[0] === 6 && r.label < i[1]) {
              r.label = i[1], i = u;
              break;
            }
            if (i && r.label < i[2]) {
              r.label = i[2], r.ops.push(u);
              break;
            }
            i[2] && r.ops.pop(), r.trys.pop();
            continue;
        }
        u = t.call(e, r);
      } catch (l) {
        u = [6, l], s = 0;
      } finally {
        n = i = 0;
      }
    if (u[0] & 5)
      throw u[1];
    return { value: u[0] ? u[1] : void 0, done: true };
  }
}
function Vg(e, t, r, n) {
  n === void 0 && (n = r), e[n] = t[r];
}
function Kg(e, t) {
  for (var r in e)
    r !== "default" && !t.hasOwnProperty(r) && (t[r] = e[r]);
}
function Sn(e) {
  var t = typeof Symbol == "function" && Symbol.iterator, r = t && e[t], n = 0;
  if (r)
    return r.call(e);
  if (e && typeof e.length == "number")
    return {
      next: function() {
        return e && n >= e.length && (e = void 0), { value: e && e[n++], done: !e };
      }
    };
  throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function rc(e, t) {
  var r = typeof Symbol == "function" && e[Symbol.iterator];
  if (!r)
    return e;
  var n = r.call(e), s, i = [], o;
  try {
    for (; (t === void 0 || t-- > 0) && !(s = n.next()).done; )
      i.push(s.value);
  } catch (a) {
    o = { error: a };
  } finally {
    try {
      s && !s.done && (r = n.return) && r.call(n);
    } finally {
      if (o)
        throw o.error;
    }
  }
  return i;
}
function Xg() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e = e.concat(rc(arguments[t]));
  return e;
}
function Zg() {
  for (var e = 0, t = 0, r = arguments.length; t < r; t++)
    e += arguments[t].length;
  for (var n = Array(e), s = 0, t = 0; t < r; t++)
    for (var i = arguments[t], o = 0, a = i.length; o < a; o++, s++)
      n[s] = i[o];
  return n;
}
function Ut(e) {
  return this instanceof Ut ? (this.v = e, this) : new Ut(e);
}
function Yg(e, t, r) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = r.apply(e, t || []), s, i = [];
  return s = {}, o("next"), o("throw"), o("return"), s[Symbol.asyncIterator] = function() {
    return this;
  }, s;
  function o(p) {
    n[p] && (s[p] = function(g) {
      return new Promise(function(b, A) {
        i.push([p, g, b, A]) > 1 || a(p, g);
      });
    });
  }
  function a(p, g) {
    try {
      c2(n[p](g));
    } catch (b) {
      h(i[0][3], b);
    }
  }
  function c2(p) {
    p.value instanceof Ut ? Promise.resolve(p.value.v).then(u, l) : h(i[0][2], p);
  }
  function u(p) {
    a("next", p);
  }
  function l(p) {
    a("throw", p);
  }
  function h(p, g) {
    p(g), i.shift(), i.length && a(i[0][0], i[0][1]);
  }
}
function Qg(e) {
  var t, r;
  return t = {}, n("next"), n("throw", function(s) {
    throw s;
  }), n("return"), t[Symbol.iterator] = function() {
    return this;
  }, t;
  function n(s, i) {
    t[s] = e[s] ? function(o) {
      return (r = !r) ? { value: Ut(e[s](o)), done: s === "return" } : i ? i(o) : o;
    } : i;
  }
}
function Jg(e) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var t = e[Symbol.asyncIterator], r;
  return t ? t.call(e) : (e = typeof Sn == "function" ? Sn(e) : e[Symbol.iterator](), r = {}, n("next"), n("throw"), n("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r);
  function n(i) {
    r[i] = e[i] && function(o) {
      return new Promise(function(a, c2) {
        o = e[i](o), s(a, c2, o.done, o.value);
      });
    };
  }
  function s(i, o, a, c2) {
    Promise.resolve(c2).then(function(u) {
      i({ value: u, done: a });
    }, o);
  }
}
function e0(e, t) {
  return Object.defineProperty ? Object.defineProperty(e, "raw", { value: t }) : e.raw = t, e;
}
function t0(e) {
  if (e && e.__esModule)
    return e;
  var t = {};
  if (e != null)
    for (var r in e)
      Object.hasOwnProperty.call(e, r) && (t[r] = e[r]);
  return t.default = e, t;
}
function r0(e) {
  return e && e.__esModule ? e : { default: e };
}
function n0(e, t) {
  if (!t.has(e))
    throw new TypeError("attempted to get private field on non-instance");
  return t.get(e);
}
function s0(e, t, r) {
  if (!t.has(e))
    throw new TypeError("attempted to set private field on non-instance");
  return t.set(e, r), r;
}
var i0 = Object.freeze(Object.defineProperty({
  __proto__: null,
  get __assign() {
    return An;
  },
  __asyncDelegator: Qg,
  __asyncGenerator: Yg,
  __asyncValues: Jg,
  __await: Ut,
  __awaiter: Wg,
  __classPrivateFieldGet: n0,
  __classPrivateFieldSet: s0,
  __createBinding: Vg,
  __decorate: jg,
  __exportStar: Kg,
  __extends: Lg,
  __generator: Gg,
  __importDefault: r0,
  __importStar: t0,
  __makeTemplateObject: e0,
  __metadata: qg,
  __param: zg,
  __read: rc,
  __rest: Hg,
  __spread: Xg,
  __spreadArrays: Zg,
  __values: Sn
}, Symbol.toStringTag, { value: "Module" }));
var _e = c(i0);
var ht = {};
var pt = {};
var gt = {};
var ri;
function nc() {
  if (ri)
    return gt;
  ri = 1, Object.defineProperty(gt, "__esModule", { value: true }), gt.isEmptyData = void 0;
  function e(t) {
    return typeof t == "string" ? t.length === 0 : t.byteLength === 0;
  }
  return gt.isEmptyData = e, gt;
}
var Rr = {};
var ni;
function sc() {
  return ni || (ni = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: true }), e.EMPTY_DATA_SHA_1 = e.SHA_1_HMAC_ALGO = e.SHA_1_HASH = void 0, e.SHA_1_HASH = { name: "SHA-1" }, e.SHA_1_HMAC_ALGO = {
      name: "HMAC",
      hash: e.SHA_1_HASH
    }, e.EMPTY_DATA_SHA_1 = new Uint8Array([
      218,
      57,
      163,
      238,
      94,
      107,
      75,
      13,
      50,
      85,
      191,
      239,
      149,
      96,
      24,
      144,
      175,
      216,
      7,
      9
    ]);
  }(Rr)), Rr;
}
var o0 = (e) => {
  const t = [];
  for (let r = 0, n = e.length; r < n; r++) {
    const s = e.charCodeAt(r);
    if (s < 128)
      t.push(s);
    else if (s < 2048)
      t.push(s >> 6 | 192, s & 63 | 128);
    else if (r + 1 < e.length && (s & 64512) === 55296 && (e.charCodeAt(r + 1) & 64512) === 56320) {
      const i = 65536 + ((s & 1023) << 10) + (e.charCodeAt(++r) & 1023);
      t.push(i >> 18 | 240, i >> 12 & 63 | 128, i >> 6 & 63 | 128, i & 63 | 128);
    } else
      t.push(s >> 12 | 224, s >> 6 & 63 | 128, s & 63 | 128);
  }
  return Uint8Array.from(t);
};
var a0 = (e) => {
  let t = "";
  for (let r = 0, n = e.length; r < n; r++) {
    const s = e[r];
    if (s < 128)
      t += String.fromCharCode(s);
    else if (192 <= s && s < 224) {
      const i = e[++r];
      t += String.fromCharCode((s & 31) << 6 | i & 63);
    } else if (240 <= s && s < 365) {
      const o = "%" + [s, e[++r], e[++r], e[++r]].map((a) => a.toString(16)).join("%");
      t += decodeURIComponent(o);
    } else
      t += String.fromCharCode((s & 15) << 12 | (e[++r] & 63) << 6 | e[++r] & 63);
  }
  return t;
};
function c0(e) {
  return new TextEncoder().encode(e);
}
function u0(e) {
  return new TextDecoder("utf-8").decode(e);
}
var d0 = (e) => typeof TextEncoder == "function" ? c0(e) : o0(e);
var l0 = (e) => typeof TextDecoder == "function" ? u0(e) : a0(e);
var f0 = Object.freeze(Object.defineProperty({
  __proto__: null,
  fromUtf8: d0,
  toUtf8: l0
}, Symbol.toStringTag, { value: "Module" }));
var dr = c(f0);
var h0 = {};
function p0() {
  return typeof window < "u" ? window : typeof self < "u" ? self : h0;
}
var g0 = Object.freeze(Object.defineProperty({
  __proto__: null,
  locateWindow: p0
}, Symbol.toStringTag, { value: "Module" }));
var dt = c(g0);
var si;
function ic() {
  if (si)
    return pt;
  si = 1, Object.defineProperty(pt, "__esModule", { value: true }), pt.Sha1 = void 0;
  var e = nc(), t = sc(), r = dr, n = dt, s = (
    /** @class */
    function() {
      function a(c2) {
        this.secret = c2, this.reset();
      }
      return a.prototype.update = function(c2) {
        var u = this;
        (0, e.isEmptyData)(c2) || (this.operation = this.operation.then(function(l) {
          return l.onerror = function() {
            u.operation = Promise.reject(new Error("Error encountered updating hash"));
          }, l.process(o(c2)), l;
        }), this.operation.catch(function() {
        }));
      }, a.prototype.digest = function() {
        return this.operation.then(function(c2) {
          return new Promise(function(u, l) {
            c2.onerror = function() {
              l(new Error("Error encountered finalizing hash"));
            }, c2.oncomplete = function() {
              c2.result && u(new Uint8Array(c2.result)), l(new Error("Error encountered finalizing hash"));
            }, c2.finish();
          });
        });
      }, a.prototype.reset = function() {
        this.secret ? (this.operation = i(this.secret).then(function(c2) {
          return (0, n.locateWindow)().msCrypto.subtle.sign(t.SHA_1_HMAC_ALGO, c2);
        }), this.operation.catch(function() {
        })) : this.operation = Promise.resolve((0, n.locateWindow)().msCrypto.subtle.digest("SHA-1"));
      }, a;
    }()
  );
  pt.Sha1 = s;
  function i(a) {
    return new Promise(function(c2, u) {
      var l = (0, n.locateWindow)().msCrypto.subtle.importKey("raw", o(a), t.SHA_1_HMAC_ALGO, false, ["sign"]);
      l.oncomplete = function() {
        l.result && c2(l.result), u(new Error("ImportKey completed without importing key."));
      }, l.onerror = function() {
        u(new Error("ImportKey failed to import key."));
      };
    });
  }
  function o(a) {
    return typeof a == "string" ? (0, r.fromUtf8)(a) : ArrayBuffer.isView(a) ? new Uint8Array(a.buffer, a.byteOffset, a.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(a);
  }
  return pt;
}
var mt = {};
var ii;
function oc() {
  if (ii)
    return mt;
  ii = 1, Object.defineProperty(mt, "__esModule", { value: true }), mt.Sha1 = void 0;
  var e = dr, t = nc(), r = sc(), n = dt, s = (
    /** @class */
    function() {
      function o(a) {
        this.toHash = new Uint8Array(0), a !== void 0 && (this.key = new Promise(function(c2, u) {
          (0, n.locateWindow)().crypto.subtle.importKey("raw", i(a), r.SHA_1_HMAC_ALGO, false, ["sign"]).then(c2, u);
        }), this.key.catch(function() {
        }));
      }
      return o.prototype.update = function(a) {
        if (!(0, t.isEmptyData)(a)) {
          var c2 = i(a), u = new Uint8Array(this.toHash.byteLength + c2.byteLength);
          u.set(this.toHash, 0), u.set(c2, this.toHash.byteLength), this.toHash = u;
        }
      }, o.prototype.digest = function() {
        var a = this;
        return this.key ? this.key.then(function(c2) {
          return (0, n.locateWindow)().crypto.subtle.sign(r.SHA_1_HMAC_ALGO, c2, a.toHash).then(function(u) {
            return new Uint8Array(u);
          });
        }) : (0, t.isEmptyData)(this.toHash) ? Promise.resolve(r.EMPTY_DATA_SHA_1) : Promise.resolve().then(function() {
          return (0, n.locateWindow)().crypto.subtle.digest(r.SHA_1_HASH, a.toHash);
        }).then(function(c2) {
          return Promise.resolve(new Uint8Array(c2));
        });
      }, o.prototype.reset = function() {
        this.toHash = new Uint8Array(0);
      }, o;
    }()
  );
  mt.Sha1 = s;
  function i(o) {
    return typeof o == "string" ? (0, e.fromUtf8)(o) : ArrayBuffer.isView(o) ? new Uint8Array(o.buffer, o.byteOffset, o.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(o);
  }
  return mt;
}
var _r = {};
var Ae = {};
var oi;
function m0() {
  if (oi)
    return Ae;
  oi = 1, Object.defineProperty(Ae, "__esModule", { value: true }), Ae.supportsZeroByteGCM = Ae.supportsSubtleCrypto = Ae.supportsSecureRandom = Ae.supportsWebCrypto = void 0;
  var e = _e, t = [
    "decrypt",
    "digest",
    "encrypt",
    "exportKey",
    "generateKey",
    "importKey",
    "sign",
    "verify"
  ];
  function r(o) {
    if (n(o) && typeof o.crypto.subtle == "object") {
      var a = o.crypto.subtle;
      return s(a);
    }
    return false;
  }
  Ae.supportsWebCrypto = r;
  function n(o) {
    if (typeof o == "object" && typeof o.crypto == "object") {
      var a = o.crypto.getRandomValues;
      return typeof a == "function";
    }
    return false;
  }
  Ae.supportsSecureRandom = n;
  function s(o) {
    return o && t.every(function(a) {
      return typeof o[a] == "function";
    });
  }
  Ae.supportsSubtleCrypto = s;
  function i(o) {
    return e.__awaiter(this, void 0, void 0, function() {
      var a, c2;
      return e.__generator(this, function(u) {
        switch (u.label) {
          case 0:
            if (!s(o))
              return [2, false];
            u.label = 1;
          case 1:
            return u.trys.push([1, 4, , 5]), [4, o.generateKey({ name: "AES-GCM", length: 128 }, false, ["encrypt"])];
          case 2:
            return a = u.sent(), [4, o.encrypt({
              name: "AES-GCM",
              iv: new Uint8Array(Array(12)),
              additionalData: new Uint8Array(Array(16)),
              tagLength: 128
            }, a, new Uint8Array(0))];
          case 3:
            return c2 = u.sent(), [2, c2.byteLength === 16];
          case 4:
            return u.sent(), [2, false];
          case 5:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }
  return Ae.supportsZeroByteGCM = i, Ae;
}
var ai;
function ac() {
  return ai || (ai = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: true });
    var t = _e;
    t.__exportStar(m0(), e);
  }(_r)), _r;
}
var Tr = {};
var Br = {};
var ci;
function y0() {
  return ci || (ci = 1, Object.defineProperty(Br, "__esModule", { value: true })), Br;
}
var kr = {};
var ui;
function b0() {
  return ui || (ui = 1, Object.defineProperty(kr, "__esModule", { value: true })), kr;
}
var Nr = {};
var di;
function w0() {
  return di || (di = 1, Object.defineProperty(Nr, "__esModule", { value: true })), Nr;
}
var Pr = {};
var li;
function x0() {
  return li || (li = 1, Object.defineProperty(Pr, "__esModule", { value: true })), Pr;
}
var yt = {};
var fi;
function E0() {
  if (fi)
    return yt;
  fi = 1, Object.defineProperty(yt, "__esModule", { value: true }), yt.isMsWindow = void 0;
  var e = [
    "decrypt",
    "digest",
    "encrypt",
    "exportKey",
    "generateKey",
    "importKey",
    "sign",
    "verify"
  ];
  function t(n) {
    return "MSInputMethodContext" in n && "msCrypto" in n;
  }
  function r(n) {
    if (t(n) && n.msCrypto.subtle !== void 0) {
      var s = n.msCrypto, i = s.getRandomValues, o = s.subtle;
      return e.map(function(a) {
        return o[a];
      }).concat(i).every(function(a) {
        return typeof a == "function";
      });
    }
    return false;
  }
  return yt.isMsWindow = r, yt;
}
var hi;
function cc() {
  return hi || (hi = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: true });
    var t = _e;
    t.__exportStar(y0(), e), t.__exportStar(b0(), e), t.__exportStar(w0(), e), t.__exportStar(x0(), e), t.__exportStar(E0(), e);
  }(Tr)), Tr;
}
var Or = {};
var bt = {};
var pi;
function A0() {
  if (pi)
    return bt;
  pi = 1, Object.defineProperty(bt, "__esModule", { value: true }), bt.convertToBuffer = void 0;
  var e = dr, t = typeof Buffer < "u" && Buffer.from ? function(n) {
    return Buffer.from(n, "utf8");
  } : e.fromUtf8;
  function r(n) {
    return n instanceof Uint8Array ? n : typeof n == "string" ? t(n) : ArrayBuffer.isView(n) ? new Uint8Array(n.buffer, n.byteOffset, n.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(n);
  }
  return bt.convertToBuffer = r, bt;
}
var wt = {};
var gi;
function S0() {
  if (gi)
    return wt;
  gi = 1, Object.defineProperty(wt, "__esModule", { value: true }), wt.isEmptyData = void 0;
  function e(t) {
    return typeof t == "string" ? t.length === 0 : t.byteLength === 0;
  }
  return wt.isEmptyData = e, wt;
}
var xt = {};
var mi;
function C0() {
  if (mi)
    return xt;
  mi = 1, Object.defineProperty(xt, "__esModule", { value: true }), xt.numToUint8 = void 0;
  function e(t) {
    return new Uint8Array([
      (t & 4278190080) >> 24,
      (t & 16711680) >> 16,
      (t & 65280) >> 8,
      t & 255
    ]);
  }
  return xt.numToUint8 = e, xt;
}
var Et = {};
var yi;
function v0() {
  if (yi)
    return Et;
  yi = 1, Object.defineProperty(Et, "__esModule", { value: true }), Et.uint32ArrayFrom = void 0;
  function e(t) {
    if (!Uint32Array.from) {
      for (var r = new Uint32Array(t.length), n = 0; n < t.length; )
        r[n] = t[n], n += 1;
      return r;
    }
    return Uint32Array.from(t);
  }
  return Et.uint32ArrayFrom = e, Et;
}
var bi;
function We() {
  return bi || (bi = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: true }), e.uint32ArrayFrom = e.numToUint8 = e.isEmptyData = e.convertToBuffer = void 0;
    var t = A0();
    Object.defineProperty(e, "convertToBuffer", { enumerable: true, get: function() {
      return t.convertToBuffer;
    } });
    var r = S0();
    Object.defineProperty(e, "isEmptyData", { enumerable: true, get: function() {
      return r.isEmptyData;
    } });
    var n = C0();
    Object.defineProperty(e, "numToUint8", { enumerable: true, get: function() {
      return n.numToUint8;
    } });
    var s = v0();
    Object.defineProperty(e, "uint32ArrayFrom", { enumerable: true, get: function() {
      return s.uint32ArrayFrom;
    } });
  }(Or)), Or;
}
var wi;
function R0() {
  if (wi)
    return ht;
  wi = 1, Object.defineProperty(ht, "__esModule", { value: true }), ht.Sha1 = void 0;
  var e = ic(), t = oc(), r = ac(), n = cc(), s = dt, i = We(), o = (
    /** @class */
    function() {
      function a(c2) {
        if ((0, r.supportsWebCrypto)((0, s.locateWindow)()))
          this.hash = new t.Sha1(c2);
        else if ((0, n.isMsWindow)((0, s.locateWindow)()))
          this.hash = new e.Sha1(c2);
        else
          throw new Error("SHA1 not supported");
      }
      return a.prototype.update = function(c2, u) {
        this.hash.update((0, i.convertToBuffer)(c2));
      }, a.prototype.digest = function() {
        return this.hash.digest();
      }, a.prototype.reset = function() {
        this.hash.reset();
      }, a;
    }()
  );
  return ht.Sha1 = o, ht;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.WebCryptoSha1 = e.Ie11Sha1 = void 0;
  var t = _e;
  t.__exportStar(R0(), e);
  var r = ic();
  Object.defineProperty(e, "Ie11Sha1", { enumerable: true, get: function() {
    return r.Sha1;
  } });
  var n = oc();
  Object.defineProperty(e, "WebCryptoSha1", { enumerable: true, get: function() {
    return n.Sha1;
  } });
})(tc);
var uc = {};
var At = {};
var St = {};
var Ct = {};
var xi;
function _0() {
  if (xi)
    return Ct;
  xi = 1, Object.defineProperty(Ct, "__esModule", { value: true }), Ct.isEmptyData = void 0;
  function e(t) {
    return typeof t == "string" ? t.length === 0 : t.byteLength === 0;
  }
  return Ct.isEmptyData = e, Ct;
}
var Mr = {};
var Ei;
function dc() {
  return Ei || (Ei = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: true }), e.EMPTY_DATA_SHA_256 = e.SHA_256_HMAC_ALGO = e.SHA_256_HASH = void 0, e.SHA_256_HASH = { name: "SHA-256" }, e.SHA_256_HMAC_ALGO = {
      name: "HMAC",
      hash: e.SHA_256_HASH
    }, e.EMPTY_DATA_SHA_256 = new Uint8Array([
      227,
      176,
      196,
      66,
      152,
      252,
      28,
      20,
      154,
      251,
      244,
      200,
      153,
      111,
      185,
      36,
      39,
      174,
      65,
      228,
      100,
      155,
      147,
      76,
      164,
      149,
      153,
      27,
      120,
      82,
      184,
      85
    ]);
  }(Mr)), Mr;
}
var Ai;
function lc() {
  if (Ai)
    return St;
  Ai = 1, Object.defineProperty(St, "__esModule", { value: true }), St.Sha256 = void 0;
  var e = _0(), t = dc(), r = dr, n = dt, s = (
    /** @class */
    function() {
      function a(c2) {
        this.secret = c2, this.reset();
      }
      return a.prototype.update = function(c2) {
        var u = this;
        (0, e.isEmptyData)(c2) || (this.operation = this.operation.then(function(l) {
          return l.onerror = function() {
            u.operation = Promise.reject(new Error("Error encountered updating hash"));
          }, l.process(o(c2)), l;
        }), this.operation.catch(function() {
        }));
      }, a.prototype.digest = function() {
        return this.operation.then(function(c2) {
          return new Promise(function(u, l) {
            c2.onerror = function() {
              l(new Error("Error encountered finalizing hash"));
            }, c2.oncomplete = function() {
              c2.result && u(new Uint8Array(c2.result)), l(new Error("Error encountered finalizing hash"));
            }, c2.finish();
          });
        });
      }, a.prototype.reset = function() {
        this.secret ? (this.operation = i(this.secret).then(function(c2) {
          return (0, n.locateWindow)().msCrypto.subtle.sign(t.SHA_256_HMAC_ALGO, c2);
        }), this.operation.catch(function() {
        })) : this.operation = Promise.resolve((0, n.locateWindow)().msCrypto.subtle.digest("SHA-256"));
      }, a;
    }()
  );
  St.Sha256 = s;
  function i(a) {
    return new Promise(function(c2, u) {
      var l = (0, n.locateWindow)().msCrypto.subtle.importKey("raw", o(a), t.SHA_256_HMAC_ALGO, false, ["sign"]);
      l.oncomplete = function() {
        l.result && c2(l.result), u(new Error("ImportKey completed without importing key."));
      }, l.onerror = function() {
        u(new Error("ImportKey failed to import key."));
      };
    });
  }
  function o(a) {
    return typeof a == "string" ? (0, r.fromUtf8)(a) : ArrayBuffer.isView(a) ? new Uint8Array(a.buffer, a.byteOffset, a.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(a);
  }
  return St;
}
var vt = {};
var Si;
function fc() {
  if (Si)
    return vt;
  Si = 1, Object.defineProperty(vt, "__esModule", { value: true }), vt.Sha256 = void 0;
  var e = We(), t = dc(), r = dt, n = (
    /** @class */
    function() {
      function s(i) {
        this.toHash = new Uint8Array(0), this.secret = i, this.reset();
      }
      return s.prototype.update = function(i) {
        if (!(0, e.isEmptyData)(i)) {
          var o = (0, e.convertToBuffer)(i), a = new Uint8Array(this.toHash.byteLength + o.byteLength);
          a.set(this.toHash, 0), a.set(o, this.toHash.byteLength), this.toHash = a;
        }
      }, s.prototype.digest = function() {
        var i = this;
        return this.key ? this.key.then(function(o) {
          return (0, r.locateWindow)().crypto.subtle.sign(t.SHA_256_HMAC_ALGO, o, i.toHash).then(function(a) {
            return new Uint8Array(a);
          });
        }) : (0, e.isEmptyData)(this.toHash) ? Promise.resolve(t.EMPTY_DATA_SHA_256) : Promise.resolve().then(function() {
          return (0, r.locateWindow)().crypto.subtle.digest(t.SHA_256_HASH, i.toHash);
        }).then(function(o) {
          return Promise.resolve(new Uint8Array(o));
        });
      }, s.prototype.reset = function() {
        var i = this;
        this.toHash = new Uint8Array(0), this.secret && this.secret !== void 0 && (this.key = new Promise(function(o, a) {
          (0, r.locateWindow)().crypto.subtle.importKey("raw", (0, e.convertToBuffer)(i.secret), t.SHA_256_HMAC_ALGO, false, ["sign"]).then(o, a);
        }), this.key.catch(function() {
        }));
      }, s;
    }()
  );
  return vt.Sha256 = n, vt;
}
var Ir = {};
var Rt = {};
var me = {};
var Ci;
function hc() {
  return Ci || (Ci = 1, Object.defineProperty(me, "__esModule", { value: true }), me.MAX_HASHABLE_LENGTH = me.INIT = me.KEY = me.DIGEST_LENGTH = me.BLOCK_SIZE = void 0, me.BLOCK_SIZE = 64, me.DIGEST_LENGTH = 32, me.KEY = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]), me.INIT = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], me.MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1), me;
}
var _t = {};
var vi;
function T0() {
  if (vi)
    return _t;
  vi = 1, Object.defineProperty(_t, "__esModule", { value: true }), _t.RawSha256 = void 0;
  var e = hc(), t = (
    /** @class */
    function() {
      function r() {
        this.state = Int32Array.from(e.INIT), this.temp = new Int32Array(64), this.buffer = new Uint8Array(64), this.bufferLength = 0, this.bytesHashed = 0, this.finished = false;
      }
      return r.prototype.update = function(n) {
        if (this.finished)
          throw new Error("Attempted to update an already finished hash.");
        var s = 0, i = n.byteLength;
        if (this.bytesHashed += i, this.bytesHashed * 8 > e.MAX_HASHABLE_LENGTH)
          throw new Error("Cannot hash more than 2^53 - 1 bits");
        for (; i > 0; )
          this.buffer[this.bufferLength++] = n[s++], i--, this.bufferLength === e.BLOCK_SIZE && (this.hashBuffer(), this.bufferLength = 0);
      }, r.prototype.digest = function() {
        if (!this.finished) {
          var n = this.bytesHashed * 8, s = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength), i = this.bufferLength;
          if (s.setUint8(this.bufferLength++, 128), i % e.BLOCK_SIZE >= e.BLOCK_SIZE - 8) {
            for (var o = this.bufferLength; o < e.BLOCK_SIZE; o++)
              s.setUint8(o, 0);
            this.hashBuffer(), this.bufferLength = 0;
          }
          for (var o = this.bufferLength; o < e.BLOCK_SIZE - 8; o++)
            s.setUint8(o, 0);
          s.setUint32(e.BLOCK_SIZE - 8, Math.floor(n / 4294967296), true), s.setUint32(e.BLOCK_SIZE - 4, n), this.hashBuffer(), this.finished = true;
        }
        for (var a = new Uint8Array(e.DIGEST_LENGTH), o = 0; o < 8; o++)
          a[o * 4] = this.state[o] >>> 24 & 255, a[o * 4 + 1] = this.state[o] >>> 16 & 255, a[o * 4 + 2] = this.state[o] >>> 8 & 255, a[o * 4 + 3] = this.state[o] >>> 0 & 255;
        return a;
      }, r.prototype.hashBuffer = function() {
        for (var n = this, s = n.buffer, i = n.state, o = i[0], a = i[1], c2 = i[2], u = i[3], l = i[4], h = i[5], p = i[6], g = i[7], b = 0; b < e.BLOCK_SIZE; b++) {
          if (b < 16)
            this.temp[b] = (s[b * 4] & 255) << 24 | (s[b * 4 + 1] & 255) << 16 | (s[b * 4 + 2] & 255) << 8 | s[b * 4 + 3] & 255;
          else {
            var A = this.temp[b - 2], R = (A >>> 17 | A << 15) ^ (A >>> 19 | A << 13) ^ A >>> 10;
            A = this.temp[b - 15];
            var T = (A >>> 7 | A << 25) ^ (A >>> 18 | A << 14) ^ A >>> 3;
            this.temp[b] = (R + this.temp[b - 7] | 0) + (T + this.temp[b - 16] | 0);
          }
          var I = (((l >>> 6 | l << 26) ^ (l >>> 11 | l << 21) ^ (l >>> 25 | l << 7)) + (l & h ^ ~l & p) | 0) + (g + (e.KEY[b] + this.temp[b] | 0) | 0) | 0, $ = ((o >>> 2 | o << 30) ^ (o >>> 13 | o << 19) ^ (o >>> 22 | o << 10)) + (o & a ^ o & c2 ^ a & c2) | 0;
          g = p, p = h, h = l, l = u + I | 0, u = c2, c2 = a, a = o, o = I + $ | 0;
        }
        i[0] += o, i[1] += a, i[2] += c2, i[3] += u, i[4] += l, i[5] += h, i[6] += p, i[7] += g;
      }, r;
    }()
  );
  return _t.RawSha256 = t, _t;
}
var Ri;
function B0() {
  if (Ri)
    return Rt;
  Ri = 1, Object.defineProperty(Rt, "__esModule", { value: true }), Rt.Sha256 = void 0;
  var e = _e, t = hc(), r = T0(), n = We(), s = (
    /** @class */
    function() {
      function o(a) {
        this.secret = a, this.hash = new r.RawSha256(), this.reset();
      }
      return o.prototype.update = function(a) {
        if (!((0, n.isEmptyData)(a) || this.error))
          try {
            this.hash.update((0, n.convertToBuffer)(a));
          } catch (c2) {
            this.error = c2;
          }
      }, o.prototype.digestSync = function() {
        if (this.error)
          throw this.error;
        return this.outer ? (this.outer.finished || this.outer.update(this.hash.digest()), this.outer.digest()) : this.hash.digest();
      }, o.prototype.digest = function() {
        return e.__awaiter(this, void 0, void 0, function() {
          return e.__generator(this, function(a) {
            return [2, this.digestSync()];
          });
        });
      }, o.prototype.reset = function() {
        if (this.hash = new r.RawSha256(), this.secret) {
          this.outer = new r.RawSha256();
          var a = i(this.secret), c2 = new Uint8Array(t.BLOCK_SIZE);
          c2.set(a);
          for (var u = 0; u < t.BLOCK_SIZE; u++)
            a[u] ^= 54, c2[u] ^= 92;
          this.hash.update(a), this.outer.update(c2);
          for (var u = 0; u < a.byteLength; u++)
            a[u] = 0;
        }
      }, o;
    }()
  );
  Rt.Sha256 = s;
  function i(o) {
    var a = (0, n.convertToBuffer)(o);
    if (a.byteLength > t.BLOCK_SIZE) {
      var c2 = new r.RawSha256();
      c2.update(a), a = c2.digest();
    }
    var u = new Uint8Array(t.BLOCK_SIZE);
    return u.set(a), u;
  }
  return Rt;
}
var _i;
function k0() {
  return _i || (_i = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: true });
    var t = _e;
    t.__exportStar(B0(), e);
  }(Ir)), Ir;
}
var Ti;
function N0() {
  if (Ti)
    return At;
  Ti = 1, Object.defineProperty(At, "__esModule", { value: true }), At.Sha256 = void 0;
  var e = lc(), t = fc(), r = k0(), n = ac(), s = cc(), i = dt, o = We(), a = (
    /** @class */
    function() {
      function c2(u) {
        (0, n.supportsWebCrypto)((0, i.locateWindow)()) ? this.hash = new t.Sha256(u) : (0, s.isMsWindow)((0, i.locateWindow)()) ? this.hash = new e.Sha256(u) : this.hash = new r.Sha256(u);
      }
      return c2.prototype.update = function(u, l) {
        this.hash.update((0, o.convertToBuffer)(u));
      }, c2.prototype.digest = function() {
        return this.hash.digest();
      }, c2.prototype.reset = function() {
        this.hash.reset();
      }, c2;
    }()
  );
  return At.Sha256 = a, At;
}
(function(e) {
  Object.defineProperty(e, "__esModule", { value: true }), e.WebCryptoSha256 = e.Ie11Sha256 = void 0;
  var t = _e;
  t.__exportStar(N0(), e);
  var r = lc();
  Object.defineProperty(e, "Ie11Sha256", { enumerable: true, get: function() {
    return r.Sha256;
  } });
  var n = fc();
  Object.defineProperty(e, "WebCryptoSha256", { enumerable: true, get: function() {
    return n.Sha256;
  } });
})(uc);
var P0 = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
};
var pc = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
};
var j = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv"
};
var ue = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
};
var $e = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};
var w = class _w {
  /**
   * Get first matched item for a string
   * @param {RegExp} regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getFirstMatch(t, r) {
    const n = r.match(t);
    return n && n.length > 0 && n[1] || "";
  }
  /**
   * Get second matched item for a string
   * @param regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getSecondMatch(t, r) {
    const n = r.match(t);
    return n && n.length > 1 && n[2] || "";
  }
  /**
   * Match a regexp and return a constant or undefined
   * @param {RegExp} regexp
   * @param {String} ua
   * @param {*} _const Any const that will be returned if regexp matches the string
   * @return {*}
   */
  static matchAndReturnConst(t, r, n) {
    if (t.test(r))
      return n;
  }
  static getWindowsVersionName(t) {
    switch (t) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return;
    }
  }
  /**
   * Get macOS version name
   *    10.5 - Leopard
   *    10.6 - Snow Leopard
   *    10.7 - Lion
   *    10.8 - Mountain Lion
   *    10.9 - Mavericks
   *    10.10 - Yosemite
   *    10.11 - El Capitan
   *    10.12 - Sierra
   *    10.13 - High Sierra
   *    10.14 - Mojave
   *    10.15 - Catalina
   *
   * @example
   *   getMacOSVersionName("10.14") // 'Mojave'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getMacOSVersionName(t) {
    const r = t.split(".").splice(0, 2).map((n) => parseInt(n, 10) || 0);
    if (r.push(0), r[0] === 10)
      switch (r[1]) {
        case 5:
          return "Leopard";
        case 6:
          return "Snow Leopard";
        case 7:
          return "Lion";
        case 8:
          return "Mountain Lion";
        case 9:
          return "Mavericks";
        case 10:
          return "Yosemite";
        case 11:
          return "El Capitan";
        case 12:
          return "Sierra";
        case 13:
          return "High Sierra";
        case 14:
          return "Mojave";
        case 15:
          return "Catalina";
        default:
          return;
      }
  }
  /**
   * Get Android version name
   *    1.5 - Cupcake
   *    1.6 - Donut
   *    2.0 - Eclair
   *    2.1 - Eclair
   *    2.2 - Froyo
   *    2.x - Gingerbread
   *    3.x - Honeycomb
   *    4.0 - Ice Cream Sandwich
   *    4.1 - Jelly Bean
   *    4.4 - KitKat
   *    5.x - Lollipop
   *    6.x - Marshmallow
   *    7.x - Nougat
   *    8.x - Oreo
   *    9.x - Pie
   *
   * @example
   *   getAndroidVersionName("7.0") // 'Nougat'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getAndroidVersionName(t) {
    const r = t.split(".").splice(0, 2).map((n) => parseInt(n, 10) || 0);
    if (r.push(0), !(r[0] === 1 && r[1] < 5)) {
      if (r[0] === 1 && r[1] < 6)
        return "Cupcake";
      if (r[0] === 1 && r[1] >= 6)
        return "Donut";
      if (r[0] === 2 && r[1] < 2)
        return "Eclair";
      if (r[0] === 2 && r[1] === 2)
        return "Froyo";
      if (r[0] === 2 && r[1] > 2)
        return "Gingerbread";
      if (r[0] === 3)
        return "Honeycomb";
      if (r[0] === 4 && r[1] < 1)
        return "Ice Cream Sandwich";
      if (r[0] === 4 && r[1] < 4)
        return "Jelly Bean";
      if (r[0] === 4 && r[1] >= 4)
        return "KitKat";
      if (r[0] === 5)
        return "Lollipop";
      if (r[0] === 6)
        return "Marshmallow";
      if (r[0] === 7)
        return "Nougat";
      if (r[0] === 8)
        return "Oreo";
      if (r[0] === 9)
        return "Pie";
    }
  }
  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  static getVersionPrecision(t) {
    return t.split(".").length;
  }
  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1
   *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1
   *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0
   *   compareVersions('1.10.2.1',  '1.0800.2');     // -1
   *   compareVersions('1.10.2.1',  '1.10',  true);  // 0
   *
   * @param {String} versionA versions versions to compare
   * @param {String} versionB versions versions to compare
   * @param {boolean} [isLoose] enable loose comparison
   * @return {Number} comparison result: -1 when versionA is lower,
   * 1 when versionA is bigger, 0 when both equal
   */
  /* eslint consistent-return: 1 */
  static compareVersions(t, r, n = false) {
    const s = _w.getVersionPrecision(t), i = _w.getVersionPrecision(r);
    let o = Math.max(s, i), a = 0;
    const c2 = _w.map([t, r], (u) => {
      const l = o - _w.getVersionPrecision(u), h = u + new Array(l + 1).join(".0");
      return _w.map(h.split("."), (p) => new Array(20 - p.length).join("0") + p).reverse();
    });
    for (n && (a = o - Math.min(s, i)), o -= 1; o >= a; ) {
      if (c2[0][o] > c2[1][o])
        return 1;
      if (c2[0][o] === c2[1][o]) {
        if (o === a)
          return 0;
        o -= 1;
      } else if (c2[0][o] < c2[1][o])
        return -1;
    }
  }
  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  static map(t, r) {
    const n = [];
    let s;
    if (Array.prototype.map)
      return Array.prototype.map.call(t, r);
    for (s = 0; s < t.length; s += 1)
      n.push(r(t[s]));
    return n;
  }
  /**
   * Array::find polyfill
   *
   * @param  {Array} arr
   * @param  {Function} predicate
   * @return {Array}
   */
  static find(t, r) {
    let n, s;
    if (Array.prototype.find)
      return Array.prototype.find.call(t, r);
    for (n = 0, s = t.length; n < s; n += 1) {
      const i = t[n];
      if (r(i, n))
        return i;
    }
  }
  /**
   * Object::assign polyfill
   *
   * @param  {Object} obj
   * @param  {Object} ...objs
   * @return {Object}
   */
  static assign(t, ...r) {
    const n = t;
    let s, i;
    if (Object.assign)
      return Object.assign(t, ...r);
    for (s = 0, i = r.length; s < i; s += 1) {
      const o = r[s];
      typeof o == "object" && o !== null && Object.keys(o).forEach((c2) => {
        n[c2] = o[c2];
      });
    }
    return t;
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('Microsoft Edge') // edge
   *
   * @param  {string} browserName
   * @return {string}
   */
  static getBrowserAlias(t) {
    return P0[t];
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('edge') // Microsoft Edge
   *
   * @param  {string} browserAlias
   * @return {string}
   */
  static getBrowserTypeByAlias(t) {
    return pc[t] || "";
  }
};
var F = /version\/(\d+(\.?_?\d+)+)/i;
var O0 = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe(e) {
      const t = {
        name: "Googlebot"
      }, r = w.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e) || w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  /* Opera < 13.0 */
  {
    test: [/opera/i],
    describe(e) {
      const t = {
        name: "Opera"
      }, r = w.getFirstMatch(F, e) || w.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  /* Opera > 13.0 */
  {
    test: [/opr\/|opios/i],
    describe(e) {
      const t = {
        name: "Opera"
      }, r = w.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e) || w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe(e) {
      const t = {
        name: "Samsung Internet for Android"
      }, r = w.getFirstMatch(F, e) || w.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/Whale/i],
    describe(e) {
      const t = {
        name: "NAVER Whale Browser"
      }, r = w.getFirstMatch(F, e) || w.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/MZBrowser/i],
    describe(e) {
      const t = {
        name: "MZ Browser"
      }, r = w.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e) || w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/focus/i],
    describe(e) {
      const t = {
        name: "Focus"
      }, r = w.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e) || w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/swing/i],
    describe(e) {
      const t = {
        name: "Swing"
      }, r = w.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e) || w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/coast/i],
    describe(e) {
      const t = {
        name: "Opera Coast"
      }, r = w.getFirstMatch(F, e) || w.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(e) {
      const t = {
        name: "Opera Touch"
      }, r = w.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e) || w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/yabrowser/i],
    describe(e) {
      const t = {
        name: "Yandex Browser"
      }, r = w.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e) || w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/ucbrowser/i],
    describe(e) {
      const t = {
        name: "UC Browser"
      }, r = w.getFirstMatch(F, e) || w.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe(e) {
      const t = {
        name: "Maxthon"
      }, r = w.getFirstMatch(F, e) || w.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/epiphany/i],
    describe(e) {
      const t = {
        name: "Epiphany"
      }, r = w.getFirstMatch(F, e) || w.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/puffin/i],
    describe(e) {
      const t = {
        name: "Puffin"
      }, r = w.getFirstMatch(F, e) || w.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/sleipnir/i],
    describe(e) {
      const t = {
        name: "Sleipnir"
      }, r = w.getFirstMatch(F, e) || w.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/k-meleon/i],
    describe(e) {
      const t = {
        name: "K-Meleon"
      }, r = w.getFirstMatch(F, e) || w.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/micromessenger/i],
    describe(e) {
      const t = {
        name: "WeChat"
      }, r = w.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e) || w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/qqbrowser/i],
    describe(e) {
      const t = {
        name: /qqbrowserlite/i.test(e) ? "QQ Browser Lite" : "QQ Browser"
      }, r = w.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e) || w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/msie|trident/i],
    describe(e) {
      const t = {
        name: "Internet Explorer"
      }, r = w.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/\sedg\//i],
    describe(e) {
      const t = {
        name: "Microsoft Edge"
      }, r = w.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe(e) {
      const t = {
        name: "Microsoft Edge"
      }, r = w.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/vivaldi/i],
    describe(e) {
      const t = {
        name: "Vivaldi"
      }, r = w.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/seamonkey/i],
    describe(e) {
      const t = {
        name: "SeaMonkey"
      }, r = w.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/sailfish/i],
    describe(e) {
      const t = {
        name: "Sailfish"
      }, r = w.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/silk/i],
    describe(e) {
      const t = {
        name: "Amazon Silk"
      }, r = w.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/phantom/i],
    describe(e) {
      const t = {
        name: "PhantomJS"
      }, r = w.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/slimerjs/i],
    describe(e) {
      const t = {
        name: "SlimerJS"
      }, r = w.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(e) {
      const t = {
        name: "BlackBerry"
      }, r = w.getFirstMatch(F, e) || w.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(e) {
      const t = {
        name: "WebOS Browser"
      }, r = w.getFirstMatch(F, e) || w.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/bada/i],
    describe(e) {
      const t = {
        name: "Bada"
      }, r = w.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/tizen/i],
    describe(e) {
      const t = {
        name: "Tizen"
      }, r = w.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e) || w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/qupzilla/i],
    describe(e) {
      const t = {
        name: "QupZilla"
      }, r = w.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e) || w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe(e) {
      const t = {
        name: "Firefox"
      }, r = w.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/electron/i],
    describe(e) {
      const t = {
        name: "Electron"
      }, r = w.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe(e) {
      const t = {
        name: "Miui"
      }, r = w.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/chromium/i],
    describe(e) {
      const t = {
        name: "Chromium"
      }, r = w.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e) || w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe(e) {
      const t = {
        name: "Chrome"
      }, r = w.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  {
    test: [/GSA/i],
    describe(e) {
      const t = {
        name: "Google Search"
      }, r = w.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  /* Android Browser */
  {
    test(e) {
      const t = !e.test(/like android/i), r = e.test(/android/i);
      return t && r;
    },
    describe(e) {
      const t = {
        name: "Android Browser"
      }, r = w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  /* PlayStation 4 */
  {
    test: [/playstation 4/i],
    describe(e) {
      const t = {
        name: "PlayStation 4"
      }, r = w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  /* Safari */
  {
    test: [/safari|applewebkit/i],
    describe(e) {
      const t = {
        name: "Safari"
      }, r = w.getFirstMatch(F, e);
      return r && (t.version = r), t;
    }
  },
  /* Something else */
  {
    test: [/.*/i],
    describe(e) {
      const t = /^(.*)\/(.*) /, r = /^(.*)\/(.*)[ \t]\((.*)/, s = e.search("\\(") !== -1 ? r : t;
      return {
        name: w.getFirstMatch(s, e),
        version: w.getSecondMatch(s, e)
      };
    }
  }
];
var M0 = [
  /* Roku */
  {
    test: [/Roku\/DVP/],
    describe(e) {
      const t = w.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e);
      return {
        name: ue.Roku,
        version: t
      };
    }
  },
  /* Windows Phone */
  {
    test: [/windows phone/i],
    describe(e) {
      const t = w.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e);
      return {
        name: ue.WindowsPhone,
        version: t
      };
    }
  },
  /* Windows */
  {
    test: [/windows /i],
    describe(e) {
      const t = w.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e), r = w.getWindowsVersionName(t);
      return {
        name: ue.Windows,
        version: t,
        versionName: r
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(e) {
      const t = {
        name: ue.iOS
      }, r = w.getSecondMatch(/(Version\/)(\d[\d.]+)/, e);
      return r && (t.version = r), t;
    }
  },
  /* macOS */
  {
    test: [/macintosh/i],
    describe(e) {
      const t = w.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e).replace(/[_\s]/g, "."), r = w.getMacOSVersionName(t), n = {
        name: ue.MacOS,
        version: t
      };
      return r && (n.versionName = r), n;
    }
  },
  /* iOS */
  {
    test: [/(ipod|iphone|ipad)/i],
    describe(e) {
      const t = w.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e).replace(/[_\s]/g, ".");
      return {
        name: ue.iOS,
        version: t
      };
    }
  },
  /* Android */
  {
    test(e) {
      const t = !e.test(/like android/i), r = e.test(/android/i);
      return t && r;
    },
    describe(e) {
      const t = w.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e), r = w.getAndroidVersionName(t), n = {
        name: ue.Android,
        version: t
      };
      return r && (n.versionName = r), n;
    }
  },
  /* WebOS */
  {
    test: [/(web|hpw)[o0]s/i],
    describe(e) {
      const t = w.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e), r = {
        name: ue.WebOS
      };
      return t && t.length && (r.version = t), r;
    }
  },
  /* BlackBerry */
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(e) {
      const t = w.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e) || w.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e) || w.getFirstMatch(/\bbb(\d+)/i, e);
      return {
        name: ue.BlackBerry,
        version: t
      };
    }
  },
  /* Bada */
  {
    test: [/bada/i],
    describe(e) {
      const t = w.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e);
      return {
        name: ue.Bada,
        version: t
      };
    }
  },
  /* Tizen */
  {
    test: [/tizen/i],
    describe(e) {
      const t = w.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e);
      return {
        name: ue.Tizen,
        version: t
      };
    }
  },
  /* Linux */
  {
    test: [/linux/i],
    describe() {
      return {
        name: ue.Linux
      };
    }
  },
  /* Chrome OS */
  {
    test: [/CrOS/],
    describe() {
      return {
        name: ue.ChromeOS
      };
    }
  },
  /* Playstation 4 */
  {
    test: [/PlayStation 4/],
    describe(e) {
      const t = w.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e);
      return {
        name: ue.PlayStation4,
        version: t
      };
    }
  }
];
var I0 = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: "bot",
        vendor: "Google"
      };
    }
  },
  /* Huawei */
  {
    test: [/huawei/i],
    describe(e) {
      const t = w.getFirstMatch(/(can-l01)/i, e) && "Nova", r = {
        type: j.mobile,
        vendor: "Huawei"
      };
      return t && (r.model = t), r;
    }
  },
  /* Nexus Tablet */
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: j.tablet,
        vendor: "Nexus"
      };
    }
  },
  /* iPad */
  {
    test: [/ipad/i],
    describe() {
      return {
        type: j.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: j.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Amazon Kindle Fire */
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: j.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  /* Another Amazon Tablet with Silk */
  {
    test: [/silk/i],
    describe() {
      return {
        type: j.tablet,
        vendor: "Amazon"
      };
    }
  },
  /* Tablet */
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: j.tablet
      };
    }
  },
  /* iPod/iPhone */
  {
    test(e) {
      const t = e.test(/ipod|iphone/i), r = e.test(/like (ipod|iphone)/i);
      return t && !r;
    },
    describe(e) {
      const t = w.getFirstMatch(/(ipod|iphone)/i, e);
      return {
        type: j.mobile,
        vendor: "Apple",
        model: t
      };
    }
  },
  /* Nexus Mobile */
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: j.mobile,
        vendor: "Nexus"
      };
    }
  },
  /* Mobile */
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: j.mobile
      };
    }
  },
  /* BlackBerry */
  {
    test(e) {
      return e.getBrowserName(true) === "blackberry";
    },
    describe() {
      return {
        type: j.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  /* Bada */
  {
    test(e) {
      return e.getBrowserName(true) === "bada";
    },
    describe() {
      return {
        type: j.mobile
      };
    }
  },
  /* Windows Phone */
  {
    test(e) {
      return e.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: j.mobile,
        vendor: "Microsoft"
      };
    }
  },
  /* Android Tablet */
  {
    test(e) {
      const t = Number(String(e.getOSVersion()).split(".")[0]);
      return e.getOSName(true) === "android" && t >= 3;
    },
    describe() {
      return {
        type: j.tablet
      };
    }
  },
  /* Android Mobile */
  {
    test(e) {
      return e.getOSName(true) === "android";
    },
    describe() {
      return {
        type: j.mobile
      };
    }
  },
  /* desktop */
  {
    test(e) {
      return e.getOSName(true) === "macos";
    },
    describe() {
      return {
        type: j.desktop,
        vendor: "Apple"
      };
    }
  },
  /* Windows */
  {
    test(e) {
      return e.getOSName(true) === "windows";
    },
    describe() {
      return {
        type: j.desktop
      };
    }
  },
  /* Linux */
  {
    test(e) {
      return e.getOSName(true) === "linux";
    },
    describe() {
      return {
        type: j.desktop
      };
    }
  },
  /* PlayStation 4 */
  {
    test(e) {
      return e.getOSName(true) === "playstation 4";
    },
    describe() {
      return {
        type: j.tv
      };
    }
  },
  /* Roku */
  {
    test(e) {
      return e.getOSName(true) === "roku";
    },
    describe() {
      return {
        type: j.tv
      };
    }
  }
];
var F0 = [
  /* EdgeHTML */
  {
    test(e) {
      return e.getBrowserName(true) === "microsoft edge";
    },
    describe(e) {
      if (/\sedg\//i.test(e))
        return {
          name: $e.Blink
        };
      const r = w.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e);
      return {
        name: $e.EdgeHTML,
        version: r
      };
    }
  },
  /* Trident */
  {
    test: [/trident/i],
    describe(e) {
      const t = {
        name: $e.Trident
      }, r = w.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  /* Presto */
  {
    test(e) {
      return e.test(/presto/i);
    },
    describe(e) {
      const t = {
        name: $e.Presto
      }, r = w.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  /* Gecko */
  {
    test(e) {
      const t = e.test(/gecko/i), r = e.test(/like gecko/i);
      return t && !r;
    },
    describe(e) {
      const t = {
        name: $e.Gecko
      }, r = w.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  },
  /* Blink */
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: $e.Blink
      };
    }
  },
  /* WebKit */
  {
    test: [/(apple)?webkit/i],
    describe(e) {
      const t = {
        name: $e.WebKit
      }, r = w.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e);
      return r && (t.version = r), t;
    }
  }
];
var Bi = class {
  /**
   * Create instance of Parser
   *
   * @param {String} UA User-Agent string
   * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
   * improvements if you need to make a more particular parsing
   * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
   *
   * @throw {Error} in case of empty UA String
   *
   * @constructor
   */
  constructor(t, r = false) {
    if (t == null || t === "")
      throw new Error("UserAgent parameter can't be empty");
    this._ua = t, this.parsedResult = {}, r !== true && this.parse();
  }
  /**
   * Get UserAgent string of current Parser instance
   * @return {String} User-Agent String of the current <Parser> object
   *
   * @public
   */
  getUA() {
    return this._ua;
  }
  /**
   * Test a UA string for a regexp
   * @param {RegExp} regex
   * @return {Boolean}
   */
  test(t) {
    return t.test(this._ua);
  }
  /**
   * Get parsed browser object
   * @return {Object}
   */
  parseBrowser() {
    this.parsedResult.browser = {};
    const t = w.find(O0, (r) => {
      if (typeof r.test == "function")
        return r.test(this);
      if (r.test instanceof Array)
        return r.test.some((n) => this.test(n));
      throw new Error("Browser's test function is not valid");
    });
    return t && (this.parsedResult.browser = t.describe(this.getUA())), this.parsedResult.browser;
  }
  /**
   * Get parsed browser object
   * @return {Object}
   *
   * @public
   */
  getBrowser() {
    return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
  }
  /**
   * Get browser's name
   * @return {String} Browser's name or an empty string
   *
   * @public
   */
  getBrowserName(t) {
    return t ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
  }
  /**
   * Get browser's version
   * @return {String} version of browser
   *
   * @public
   */
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  /**
   * Get OS
   * @return {Object}
   *
   * @example
   * this.getOS();
   * {
   *   name: 'macOS',
   *   version: '10.11.12'
   * }
   */
  getOS() {
    return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
  }
  /**
   * Parse OS and save it to this.parsedResult.os
   * @return {*|{}}
   */
  parseOS() {
    this.parsedResult.os = {};
    const t = w.find(M0, (r) => {
      if (typeof r.test == "function")
        return r.test(this);
      if (r.test instanceof Array)
        return r.test.some((n) => this.test(n));
      throw new Error("Browser's test function is not valid");
    });
    return t && (this.parsedResult.os = t.describe(this.getUA())), this.parsedResult.os;
  }
  /**
   * Get OS name
   * @param {Boolean} [toLowerCase] return lower-cased value
   * @return {String} name of the OS  macOS, Windows, Linux, etc.
   */
  getOSName(t) {
    const { name: r } = this.getOS();
    return t ? String(r).toLowerCase() || "" : r || "";
  }
  /**
   * Get OS version
   * @return {String} full version with dots ('10.11.12', '5.6', etc)
   */
  getOSVersion() {
    return this.getOS().version;
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  getPlatform() {
    return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
  }
  /**
   * Get platform name
   * @param {Boolean} [toLowerCase=false]
   * @return {*}
   */
  getPlatformType(t = false) {
    const { type: r } = this.getPlatform();
    return t ? String(r).toLowerCase() || "" : r || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parsePlatform() {
    this.parsedResult.platform = {};
    const t = w.find(I0, (r) => {
      if (typeof r.test == "function")
        return r.test(this);
      if (r.test instanceof Array)
        return r.test.some((n) => this.test(n));
      throw new Error("Browser's test function is not valid");
    });
    return t && (this.parsedResult.platform = t.describe(this.getUA())), this.parsedResult.platform;
  }
  /**
   * Get parsed engine
   * @return {{}}
   */
  getEngine() {
    return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
  }
  /**
   * Get engines's name
   * @return {String} Engines's name or an empty string
   *
   * @public
   */
  getEngineName(t) {
    return t ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parseEngine() {
    this.parsedResult.engine = {};
    const t = w.find(F0, (r) => {
      if (typeof r.test == "function")
        return r.test(this);
      if (r.test instanceof Array)
        return r.test.some((n) => this.test(n));
      throw new Error("Browser's test function is not valid");
    });
    return t && (this.parsedResult.engine = t.describe(this.getUA())), this.parsedResult.engine;
  }
  /**
   * Parse full information about the browser
   * @returns {Parser}
   */
  parse() {
    return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
  }
  /**
   * Get parsed result
   * @return {ParsedResult}
   */
  getResult() {
    return w.assign({}, this.parsedResult);
  }
  /**
   * Check if parsed browser matches certain conditions
   *
   * @param {Object} checkTree It's one or two layered object,
   * which can include a platform or an OS on the first layer
   * and should have browsers specs on the bottom-laying layer
   *
   * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
   * Returns `undefined` when the browser is no described in the checkTree object.
   *
   * @example
   * const browser = Bowser.getParser(window.navigator.userAgent);
   * if (browser.satisfies({chrome: '>118.01.1322' }))
   * // or with os
   * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
   * // or with platforms
   * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
   */
  satisfies(t) {
    const r = {};
    let n = 0;
    const s = {};
    let i = 0;
    if (Object.keys(t).forEach((a) => {
      const c2 = t[a];
      typeof c2 == "string" ? (s[a] = c2, i += 1) : typeof c2 == "object" && (r[a] = c2, n += 1);
    }), n > 0) {
      const a = Object.keys(r), c2 = w.find(a, (l) => this.isOS(l));
      if (c2) {
        const l = this.satisfies(r[c2]);
        if (l !== void 0)
          return l;
      }
      const u = w.find(
        a,
        (l) => this.isPlatform(l)
      );
      if (u) {
        const l = this.satisfies(r[u]);
        if (l !== void 0)
          return l;
      }
    }
    if (i > 0) {
      const a = Object.keys(s), c2 = w.find(a, (u) => this.isBrowser(u, true));
      if (c2 !== void 0)
        return this.compareVersion(s[c2]);
    }
  }
  /**
   * Check if the browser name equals the passed string
   * @param browserName The string to compare with the browser name
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {boolean}
   */
  isBrowser(t, r = false) {
    const n = this.getBrowserName().toLowerCase();
    let s = t.toLowerCase();
    const i = w.getBrowserTypeByAlias(s);
    return r && i && (s = i.toLowerCase()), s === n;
  }
  compareVersion(t) {
    let r = [0], n = t, s = false;
    const i = this.getBrowserVersion();
    if (typeof i == "string")
      return t[0] === ">" || t[0] === "<" ? (n = t.substr(1), t[1] === "=" ? (s = true, n = t.substr(2)) : r = [], t[0] === ">" ? r.push(1) : r.push(-1)) : t[0] === "=" ? n = t.substr(1) : t[0] === "~" && (s = true, n = t.substr(1)), r.indexOf(
        w.compareVersions(i, n, s)
      ) > -1;
  }
  isOS(t) {
    return this.getOSName(true) === String(t).toLowerCase();
  }
  isPlatform(t) {
    return this.getPlatformType(true) === String(t).toLowerCase();
  }
  isEngine(t) {
    return this.getEngineName(true) === String(t).toLowerCase();
  }
  /**
   * Is anything? Check if the browser is called "anything",
   * the OS called "anything" or the platform called "anything"
   * @param {String} anything
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {Boolean}
   */
  is(t, r = false) {
    return this.isBrowser(t, r) || this.isOS(t) || this.isPlatform(t);
  }
  /**
   * Check if any of the given values satisfies this.is(anything)
   * @param {String[]} anythings
   * @returns {Boolean}
   */
  some(t = []) {
    return t.some((r) => this.is(r));
  }
};
var gc = class {
  /**
   * Creates a {@link Parser} instance
   *
   * @param {String} UA UserAgent string
   * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it
   * explicitly. Same as `skipParsing` for {@link Parser}.
   * @returns {Parser}
   * @throws {Error} when UA is not a String
   *
   * @example
   * const parser = Bowser.getParser(window.navigator.userAgent);
   * const result = parser.getResult();
   */
  static getParser(t, r = false) {
    if (typeof t != "string")
      throw new Error("UserAgent should be a string");
    return new Bi(t, r);
  }
  /**
   * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately
   *
   * @param UA
   * @return {ParsedResult}
   *
   * @example
   * const result = Bowser.parse(window.navigator.userAgent);
   */
  static parse(t) {
    return new Bi(t).getResult();
  }
  static get BROWSER_MAP() {
    return pc;
  }
  static get ENGINE_MAP() {
    return $e;
  }
  static get OS_MAP() {
    return ue;
  }
  static get PLATFORMS_MAP() {
    return j;
  }
};
var D0 = ({ serviceId: e, clientVersion: t }) => async () => {
  var s, i, o, a, c2;
  const r = typeof window < "u" && ((s = window == null ? void 0 : window.navigator) != null && s.userAgent) ? gc.parse(window.navigator.userAgent) : void 0, n = [
    ["aws-sdk-js", t],
    ["ua", "2.0"],
    [`os/${((i = r == null ? void 0 : r.os) == null ? void 0 : i.name) || "other"}`, (o = r == null ? void 0 : r.os) == null ? void 0 : o.version],
    ["lang/js"],
    ["md/browser", `${((a = r == null ? void 0 : r.browser) == null ? void 0 : a.name) ?? "unknown"}_${((c2 = r == null ? void 0 : r.browser) == null ? void 0 : c2.version) ?? "unknown"}`]
  ];
  return e && n.push([`api/${e}`, t]), n;
};
var Fr = {};
var Tt = {};
var ki;
function U0() {
  if (ki)
    return Tt;
  ki = 1, Object.defineProperty(Tt, "__esModule", { value: true }), Tt.AwsCrc32 = void 0;
  var e = _e, t = We(), r = mc(), n = (
    /** @class */
    function() {
      function s() {
        this.crc32 = new r.Crc32();
      }
      return s.prototype.update = function(i) {
        (0, t.isEmptyData)(i) || this.crc32.update((0, t.convertToBuffer)(i));
      }, s.prototype.digest = function() {
        return e.__awaiter(this, void 0, void 0, function() {
          return e.__generator(this, function(i) {
            return [2, (0, t.numToUint8)(this.crc32.digest())];
          });
        });
      }, s.prototype.reset = function() {
        this.crc32 = new r.Crc32();
      }, s;
    }()
  );
  return Tt.AwsCrc32 = n, Tt;
}
var Ni;
function mc() {
  return Ni || (Ni = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: true }), e.AwsCrc32 = e.Crc32 = e.crc32 = void 0;
    var t = _e, r = We();
    function n(c2) {
      return new s().update(c2).digest();
    }
    e.crc32 = n;
    var s = (
      /** @class */
      function() {
        function c2() {
          this.checksum = 4294967295;
        }
        return c2.prototype.update = function(u) {
          var l, h;
          try {
            for (var p = t.__values(u), g = p.next(); !g.done; g = p.next()) {
              var b = g.value;
              this.checksum = this.checksum >>> 8 ^ o[(this.checksum ^ b) & 255];
            }
          } catch (A) {
            l = { error: A };
          } finally {
            try {
              g && !g.done && (h = p.return) && h.call(p);
            } finally {
              if (l)
                throw l.error;
            }
          }
          return this;
        }, c2.prototype.digest = function() {
          return (this.checksum ^ 4294967295) >>> 0;
        }, c2;
      }()
    );
    e.Crc32 = s;
    var i = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ], o = (0, r.uint32ArrayFrom)(i), a = U0();
    Object.defineProperty(e, "AwsCrc32", { enumerable: true, get: function() {
      return a.AwsCrc32;
    } });
  }(Fr)), Fr;
}
var Jn = mc();
var It = class _It {
  constructor(t) {
    if (this.bytes = t, t.byteLength !== 8)
      throw new Error("Int64 buffers must be exactly 8 bytes");
  }
  static fromNumber(t) {
    if (t > 9223372036854776e3 || t < -9223372036854776e3)
      throw new Error(`${t} is too large (or, if negative, too small) to represent as an Int64`);
    const r = new Uint8Array(8);
    for (let n = 7, s = Math.abs(Math.round(t)); n > -1 && s > 0; n--, s /= 256)
      r[n] = s;
    return t < 0 && Pi(r), new _It(r);
  }
  valueOf() {
    const t = this.bytes.slice(0), r = t[0] & 128;
    return r && Pi(t), parseInt(he(t), 16) * (r ? -1 : 1);
  }
  toString() {
    return String(this.valueOf());
  }
};
function Pi(e) {
  for (let t = 0; t < 8; t++)
    e[t] ^= 255;
  for (let t = 7; t > -1 && (e[t]++, e[t] === 0); t--)
    ;
}
var $0 = class {
  constructor(t, r) {
    this.toUtf8 = t, this.fromUtf8 = r;
  }
  format(t) {
    const r = [];
    for (const i of Object.keys(t)) {
      const o = this.fromUtf8(i);
      r.push(Uint8Array.from([o.byteLength]), o, this.formatHeaderValue(t[i]));
    }
    const n = new Uint8Array(r.reduce((i, o) => i + o.byteLength, 0));
    let s = 0;
    for (const i of r)
      n.set(i, s), s += i.byteLength;
    return n;
  }
  formatHeaderValue(t) {
    switch (t.type) {
      case "boolean":
        return Uint8Array.from([t.value ? 0 : 1]);
      case "byte":
        return Uint8Array.from([2, t.value]);
      case "short":
        const r = new DataView(new ArrayBuffer(3));
        return r.setUint8(0, 3), r.setInt16(1, t.value, false), new Uint8Array(r.buffer);
      case "integer":
        const n = new DataView(new ArrayBuffer(5));
        return n.setUint8(0, 4), n.setInt32(1, t.value, false), new Uint8Array(n.buffer);
      case "long":
        const s = new Uint8Array(9);
        return s[0] = 5, s.set(t.value.bytes, 1), s;
      case "binary":
        const i = new DataView(new ArrayBuffer(3 + t.value.byteLength));
        i.setUint8(0, 6), i.setUint16(1, t.value.byteLength, false);
        const o = new Uint8Array(i.buffer);
        return o.set(t.value, 3), o;
      case "string":
        const a = this.fromUtf8(t.value), c2 = new DataView(new ArrayBuffer(3 + a.byteLength));
        c2.setUint8(0, 7), c2.setUint16(1, a.byteLength, false);
        const u = new Uint8Array(c2.buffer);
        return u.set(a, 3), u;
      case "timestamp":
        const l = new Uint8Array(9);
        return l[0] = 8, l.set(It.fromNumber(t.value.valueOf()).bytes, 1), l;
      case "uuid":
        if (!K0.test(t.value))
          throw new Error(`Invalid UUID received: ${t.value}`);
        const h = new Uint8Array(17);
        return h[0] = 9, h.set(zo(t.value.replace(/\-/g, "")), 1), h;
    }
  }
  parse(t) {
    const r = {};
    let n = 0;
    for (; n < t.byteLength; ) {
      const s = t.getUint8(n++), i = this.toUtf8(new Uint8Array(t.buffer, t.byteOffset + n, s));
      switch (n += s, t.getUint8(n++)) {
        case 0:
          r[i] = {
            type: Mi,
            value: true
          };
          break;
        case 1:
          r[i] = {
            type: Mi,
            value: false
          };
          break;
        case 2:
          r[i] = {
            type: L0,
            value: t.getInt8(n++)
          };
          break;
        case 3:
          r[i] = {
            type: H0,
            value: t.getInt16(n, false)
          }, n += 2;
          break;
        case 4:
          r[i] = {
            type: j0,
            value: t.getInt32(n, false)
          }, n += 4;
          break;
        case 5:
          r[i] = {
            type: z0,
            value: new It(new Uint8Array(t.buffer, t.byteOffset + n, 8))
          }, n += 8;
          break;
        case 6:
          const o = t.getUint16(n, false);
          n += 2, r[i] = {
            type: q0,
            value: new Uint8Array(t.buffer, t.byteOffset + n, o)
          }, n += o;
          break;
        case 7:
          const a = t.getUint16(n, false);
          n += 2, r[i] = {
            type: W0,
            value: this.toUtf8(new Uint8Array(t.buffer, t.byteOffset + n, a))
          }, n += a;
          break;
        case 8:
          r[i] = {
            type: G0,
            value: new Date(new It(new Uint8Array(t.buffer, t.byteOffset + n, 8)).valueOf())
          }, n += 8;
          break;
        case 9:
          const c2 = new Uint8Array(t.buffer, t.byteOffset + n, 16);
          n += 16, r[i] = {
            type: V0,
            value: `${he(c2.subarray(0, 4))}-${he(c2.subarray(4, 6))}-${he(c2.subarray(6, 8))}-${he(c2.subarray(8, 10))}-${he(c2.subarray(10))}`
          };
          break;
        default:
          throw new Error("Unrecognized header type tag");
      }
    }
    return r;
  }
};
var Oi;
(function(e) {
  e[e.boolTrue = 0] = "boolTrue", e[e.boolFalse = 1] = "boolFalse", e[e.byte = 2] = "byte", e[e.short = 3] = "short", e[e.integer = 4] = "integer", e[e.long = 5] = "long", e[e.byteArray = 6] = "byteArray", e[e.string = 7] = "string", e[e.timestamp = 8] = "timestamp", e[e.uuid = 9] = "uuid";
})(Oi || (Oi = {}));
var Mi = "boolean";
var L0 = "byte";
var H0 = "short";
var j0 = "integer";
var z0 = "long";
var q0 = "binary";
var W0 = "string";
var G0 = "timestamp";
var V0 = "uuid";
var K0 = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
var yc = 4;
var Le = yc * 2;
var Ke = 4;
var X0 = Le + Ke * 2;
function Z0({ byteLength: e, byteOffset: t, buffer: r }) {
  if (e < X0)
    throw new Error("Provided message too short to accommodate event stream message overhead");
  const n = new DataView(r, t, e), s = n.getUint32(0, false);
  if (e !== s)
    throw new Error("Reported message length does not match received message length");
  const i = n.getUint32(yc, false), o = n.getUint32(Le, false), a = n.getUint32(e - Ke, false), c2 = new Jn.Crc32().update(new Uint8Array(r, t, Le));
  if (o !== c2.digest())
    throw new Error(`The prelude checksum specified in the message (${o}) does not match the calculated CRC32 checksum (${c2.digest()})`);
  if (c2.update(new Uint8Array(r, t + Le, e - (Le + Ke))), a !== c2.digest())
    throw new Error(`The message checksum (${c2.digest()}) did not match the expected value of ${a}`);
  return {
    headers: new DataView(r, t + Le + Ke, i),
    body: new Uint8Array(r, t + Le + Ke + i, s - i - (Le + Ke + Ke))
  };
}
var Y0 = class {
  constructor(t, r) {
    this.headerMarshaller = new $0(t, r), this.messageBuffer = [], this.isEndOfStream = false;
  }
  feed(t) {
    this.messageBuffer.push(this.decode(t));
  }
  endOfStream() {
    this.isEndOfStream = true;
  }
  getMessage() {
    const t = this.messageBuffer.pop(), r = this.isEndOfStream;
    return {
      getMessage() {
        return t;
      },
      isEndOfStream() {
        return r;
      }
    };
  }
  getAvailableMessages() {
    const t = this.messageBuffer;
    this.messageBuffer = [];
    const r = this.isEndOfStream;
    return {
      getMessages() {
        return t;
      },
      isEndOfStream() {
        return r;
      }
    };
  }
  encode({ headers: t, body: r }) {
    const n = this.headerMarshaller.format(t), s = n.byteLength + r.byteLength + 16, i = new Uint8Array(s), o = new DataView(i.buffer, i.byteOffset, i.byteLength), a = new Jn.Crc32();
    return o.setUint32(0, s, false), o.setUint32(4, n.byteLength, false), o.setUint32(8, a.update(i.subarray(0, 8)).digest(), false), i.set(n, 12), i.set(r, n.byteLength + 12), o.setUint32(s - 4, a.update(i.subarray(8, s - 4)).digest(), false), i;
  }
  decode(t) {
    const { headers: r, body: n } = Z0(t);
    return { headers: this.headerMarshaller.parse(r), body: n };
  }
  formatHeaders(t) {
    return this.headerMarshaller.format(t);
  }
};
var Q0 = class {
  constructor(t) {
    this.options = t;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const t of this.options.inputStream)
      yield this.options.decoder.decode(t);
  }
};
var J0 = class {
  constructor(t) {
    this.options = t;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const t of this.options.messageStream)
      yield this.options.encoder.encode(t);
    this.options.includeEndFrame && (yield new Uint8Array(0));
  }
};
var em = class {
  constructor(t) {
    this.options = t;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const t of this.options.messageStream) {
      const r = await this.options.deserializer(t);
      r !== void 0 && (yield r);
    }
  }
};
var tm = class {
  constructor(t) {
    this.options = t;
  }
  [Symbol.asyncIterator]() {
    return this.asyncIterator();
  }
  async *asyncIterator() {
    for await (const t of this.options.inputStream)
      yield this.options.serializer(t);
  }
};
function rm(e) {
  let t = 0, r = 0, n = null, s = null;
  const i = (a) => {
    if (typeof a != "number")
      throw new Error("Attempted to allocate an event message where size was not a number: " + a);
    t = a, r = 4, n = new Uint8Array(a), new DataView(n.buffer).setUint32(0, a, false);
  }, o = async function* () {
    const a = e[Symbol.asyncIterator]();
    for (; ; ) {
      const { value: c2, done: u } = await a.next();
      if (u) {
        if (t)
          if (t === r)
            yield n;
          else
            throw new Error("Truncated event message received.");
        else
          return;
        return;
      }
      const l = c2.length;
      let h = 0;
      for (; h < l; ) {
        if (!n) {
          const g = l - h;
          s || (s = new Uint8Array(4));
          const b = Math.min(4 - r, g);
          if (s.set(c2.slice(h, h + b), r), r += b, h += b, r < 4)
            break;
          i(new DataView(s.buffer).getUint32(0, false)), s = null;
        }
        const p = Math.min(t - r, l - h);
        n.set(c2.slice(h, h + p), r), r += p, h += p, t && t === r && (yield n, n = null, t = 0, r = 0);
      }
    }
  };
  return {
    [Symbol.asyncIterator]: o
  };
}
function nm(e, t) {
  return async function(r) {
    const { value: n } = r.headers[":message-type"];
    if (n === "error") {
      const s = new Error(r.headers[":error-message"].value || "UnknownError");
      throw s.name = r.headers[":error-code"].value, s;
    } else if (n === "exception") {
      const s = r.headers[":exception-type"].value, i = { [s]: r }, o = await e(i);
      if (o.$unknown) {
        const a = new Error(t(r.body));
        throw a.name = s, a;
      }
      throw o[s];
    } else if (n === "event") {
      const s = {
        [r.headers[":event-type"].value]: r
      }, i = await e(s);
      return i.$unknown ? void 0 : i;
    } else
      throw Error(`Unrecognizable event type: ${r.headers[":event-type"].value}`);
  };
}
var sm = class {
  constructor({ utf8Encoder: t, utf8Decoder: r }) {
    this.eventStreamCodec = new Y0(t, r), this.utfEncoder = t;
  }
  deserialize(t, r) {
    const n = rm(t);
    return new em({
      messageStream: new Q0({ inputStream: n, decoder: this.eventStreamCodec }),
      deserializer: nm(r, this.utfEncoder)
    });
  }
  serialize(t, r) {
    return new J0({
      messageStream: new tm({ inputStream: t, serializer: r }),
      encoder: this.eventStreamCodec,
      includeEndFrame: true
    });
  }
};
var im = (e) => ({
  [Symbol.asyncIterator]: async function* () {
    const t = e.getReader();
    try {
      for (; ; ) {
        const { done: r, value: n } = await t.read();
        if (r)
          return;
        yield n;
      }
    } finally {
      t.releaseLock();
    }
  }
});
var om = (e) => {
  const t = e[Symbol.asyncIterator]();
  return new ReadableStream({
    async pull(r) {
      const { done: n, value: s } = await t.next();
      if (n)
        return r.close();
      r.enqueue(s);
    }
  });
};
var am = class {
  constructor({ utf8Encoder: t, utf8Decoder: r }) {
    this.universalMarshaller = new sm({
      utf8Decoder: r,
      utf8Encoder: t
    });
  }
  deserialize(t, r) {
    const n = cm(t) ? im(t) : t;
    return this.universalMarshaller.deserialize(n, r);
  }
  serialize(t, r) {
    const n = this.universalMarshaller.serialize(t, r);
    return typeof ReadableStream == "function" ? om(n) : n;
  }
};
var cm = (e) => typeof ReadableStream == "function" && e instanceof ReadableStream;
var um = (e) => new am(e);
function dm(e, t, r = 1024 * 1024) {
  return new Promise((n, s) => {
    const i = new FileReader();
    i.addEventListener("error", s), i.addEventListener("abort", s);
    const o = e.size;
    let a = 0;
    function c2() {
      if (a >= o) {
        n();
        return;
      }
      i.readAsArrayBuffer(e.slice(a, Math.min(o, a + r)));
    }
    i.addEventListener("load", (u) => {
      const l = u.target.result;
      t(new Uint8Array(l)), a += l.byteLength, c2();
    }), c2();
  });
}
var lm = async function(t, r) {
  const n = new t();
  return await dm(r, (s) => {
    n.update(s);
  }), n.digest();
};
var fm = (e) => () => Promise.reject(e);
var Fe = 64;
var hm = 16;
var pm = [1732584193, 4023233417, 2562383102, 271733878];
var gm = class {
  constructor() {
    this.reset();
  }
  update(t) {
    if (mm(t))
      return;
    if (this.finished)
      throw new Error("Attempted to update an already finished hash.");
    const r = ym(t);
    let n = 0, { byteLength: s } = r;
    for (this.bytesHashed += s; s > 0; )
      this.buffer.setUint8(this.bufferLength++, r[n++]), s--, this.bufferLength === Fe && (this.hashBuffer(), this.bufferLength = 0);
  }
  async digest() {
    if (!this.finished) {
      const { buffer: r, bufferLength: n, bytesHashed: s } = this, i = s * 8;
      if (r.setUint8(this.bufferLength++, 128), n % Fe >= Fe - 8) {
        for (let o = this.bufferLength; o < Fe; o++)
          r.setUint8(o, 0);
        this.hashBuffer(), this.bufferLength = 0;
      }
      for (let o = this.bufferLength; o < Fe - 8; o++)
        r.setUint8(o, 0);
      r.setUint32(Fe - 8, i >>> 0, true), r.setUint32(Fe - 4, Math.floor(i / 4294967296), true), this.hashBuffer(), this.finished = true;
    }
    const t = new DataView(new ArrayBuffer(hm));
    for (let r = 0; r < 4; r++)
      t.setUint32(r * 4, this.state[r], true);
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  }
  hashBuffer() {
    const { buffer: t, state: r } = this;
    let n = r[0], s = r[1], i = r[2], o = r[3];
    n = ne(n, s, i, o, t.getUint32(0, true), 7, 3614090360), o = ne(o, n, s, i, t.getUint32(4, true), 12, 3905402710), i = ne(i, o, n, s, t.getUint32(8, true), 17, 606105819), s = ne(s, i, o, n, t.getUint32(12, true), 22, 3250441966), n = ne(n, s, i, o, t.getUint32(16, true), 7, 4118548399), o = ne(o, n, s, i, t.getUint32(20, true), 12, 1200080426), i = ne(i, o, n, s, t.getUint32(24, true), 17, 2821735955), s = ne(s, i, o, n, t.getUint32(28, true), 22, 4249261313), n = ne(n, s, i, o, t.getUint32(32, true), 7, 1770035416), o = ne(o, n, s, i, t.getUint32(36, true), 12, 2336552879), i = ne(i, o, n, s, t.getUint32(40, true), 17, 4294925233), s = ne(s, i, o, n, t.getUint32(44, true), 22, 2304563134), n = ne(n, s, i, o, t.getUint32(48, true), 7, 1804603682), o = ne(o, n, s, i, t.getUint32(52, true), 12, 4254626195), i = ne(i, o, n, s, t.getUint32(56, true), 17, 2792965006), s = ne(s, i, o, n, t.getUint32(60, true), 22, 1236535329), n = se(n, s, i, o, t.getUint32(4, true), 5, 4129170786), o = se(o, n, s, i, t.getUint32(24, true), 9, 3225465664), i = se(i, o, n, s, t.getUint32(44, true), 14, 643717713), s = se(s, i, o, n, t.getUint32(0, true), 20, 3921069994), n = se(n, s, i, o, t.getUint32(20, true), 5, 3593408605), o = se(o, n, s, i, t.getUint32(40, true), 9, 38016083), i = se(i, o, n, s, t.getUint32(60, true), 14, 3634488961), s = se(s, i, o, n, t.getUint32(16, true), 20, 3889429448), n = se(n, s, i, o, t.getUint32(36, true), 5, 568446438), o = se(o, n, s, i, t.getUint32(56, true), 9, 3275163606), i = se(i, o, n, s, t.getUint32(12, true), 14, 4107603335), s = se(s, i, o, n, t.getUint32(32, true), 20, 1163531501), n = se(n, s, i, o, t.getUint32(52, true), 5, 2850285829), o = se(o, n, s, i, t.getUint32(8, true), 9, 4243563512), i = se(i, o, n, s, t.getUint32(28, true), 14, 1735328473), s = se(s, i, o, n, t.getUint32(48, true), 20, 2368359562), n = ie(n, s, i, o, t.getUint32(20, true), 4, 4294588738), o = ie(o, n, s, i, t.getUint32(32, true), 11, 2272392833), i = ie(i, o, n, s, t.getUint32(44, true), 16, 1839030562), s = ie(s, i, o, n, t.getUint32(56, true), 23, 4259657740), n = ie(n, s, i, o, t.getUint32(4, true), 4, 2763975236), o = ie(o, n, s, i, t.getUint32(16, true), 11, 1272893353), i = ie(i, o, n, s, t.getUint32(28, true), 16, 4139469664), s = ie(s, i, o, n, t.getUint32(40, true), 23, 3200236656), n = ie(n, s, i, o, t.getUint32(52, true), 4, 681279174), o = ie(o, n, s, i, t.getUint32(0, true), 11, 3936430074), i = ie(i, o, n, s, t.getUint32(12, true), 16, 3572445317), s = ie(s, i, o, n, t.getUint32(24, true), 23, 76029189), n = ie(n, s, i, o, t.getUint32(36, true), 4, 3654602809), o = ie(o, n, s, i, t.getUint32(48, true), 11, 3873151461), i = ie(i, o, n, s, t.getUint32(60, true), 16, 530742520), s = ie(s, i, o, n, t.getUint32(8, true), 23, 3299628645), n = oe(n, s, i, o, t.getUint32(0, true), 6, 4096336452), o = oe(o, n, s, i, t.getUint32(28, true), 10, 1126891415), i = oe(i, o, n, s, t.getUint32(56, true), 15, 2878612391), s = oe(s, i, o, n, t.getUint32(20, true), 21, 4237533241), n = oe(n, s, i, o, t.getUint32(48, true), 6, 1700485571), o = oe(o, n, s, i, t.getUint32(12, true), 10, 2399980690), i = oe(i, o, n, s, t.getUint32(40, true), 15, 4293915773), s = oe(s, i, o, n, t.getUint32(4, true), 21, 2240044497), n = oe(n, s, i, o, t.getUint32(32, true), 6, 1873313359), o = oe(o, n, s, i, t.getUint32(60, true), 10, 4264355552), i = oe(i, o, n, s, t.getUint32(24, true), 15, 2734768916), s = oe(s, i, o, n, t.getUint32(52, true), 21, 1309151649), n = oe(n, s, i, o, t.getUint32(16, true), 6, 4149444226), o = oe(o, n, s, i, t.getUint32(44, true), 10, 3174756917), i = oe(i, o, n, s, t.getUint32(8, true), 15, 718787259), s = oe(s, i, o, n, t.getUint32(36, true), 21, 3951481745), r[0] = n + r[0] & 4294967295, r[1] = s + r[1] & 4294967295, r[2] = i + r[2] & 4294967295, r[3] = o + r[3] & 4294967295;
  }
  reset() {
    this.state = Uint32Array.from(pm), this.buffer = new DataView(new ArrayBuffer(Fe)), this.bufferLength = 0, this.bytesHashed = 0, this.finished = false;
  }
};
function lr(e, t, r, n, s, i) {
  return t = (t + e & 4294967295) + (n + i & 4294967295) & 4294967295, (t << s | t >>> 32 - s) + r & 4294967295;
}
function ne(e, t, r, n, s, i, o) {
  return lr(t & r | ~t & n, e, t, s, i, o);
}
function se(e, t, r, n, s, i, o) {
  return lr(t & n | r & ~n, e, t, s, i, o);
}
function ie(e, t, r, n, s, i, o) {
  return lr(t ^ r ^ n, e, t, s, i, o);
}
function oe(e, t, r, n, s, i, o) {
  return lr(r ^ (t | ~n), e, t, s, i, o);
}
function mm(e) {
  return typeof e == "string" ? e.length === 0 : e.byteLength === 0;
}
function ym(e) {
  return typeof e == "string" ? Qe(e) : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(e);
}
var Ii = typeof TextEncoder == "function" ? new TextEncoder() : null;
var bm = (e) => {
  if (typeof e == "string") {
    if (Ii)
      return Ii.encode(e).byteLength;
    let t = e.length;
    for (let r = t - 1; r >= 0; r--) {
      const n = e.charCodeAt(r);
      n > 127 && n <= 2047 ? t++ : n > 2047 && n <= 65535 && (t += 2), n >= 56320 && n <= 57343 && r--;
    }
    return t;
  } else {
    if (typeof e.byteLength == "number")
      return e.byteLength;
    if (typeof e.size == "number")
      return e.size;
  }
  throw new Error(`Body Length computation failed for ${e}`);
};
var wm = {
  CrtSignerV4: null
};
var xm = class {
  constructor(t) {
    this.sigv4Signer = new Hd(t), this.signerOptions = t;
  }
  async sign(t, r = {}) {
    if (r.signingRegion === "*") {
      if (this.signerOptions.runtime !== "node")
        throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
      return this.getSigv4aSigner().sign(t, r);
    }
    return this.sigv4Signer.sign(t, r);
  }
  async signWithCredentials(t, r, n = {}) {
    if (n.signingRegion === "*") {
      if (this.signerOptions.runtime !== "node")
        throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
      return this.getSigv4aSigner().signWithCredentials(t, r, n);
    }
    return this.sigv4Signer.signWithCredentials(t, r, n);
  }
  async presign(t, r = {}) {
    if (r.signingRegion === "*") {
      if (this.signerOptions.runtime !== "node")
        throw new Error("This request requires signing with SigV4Asymmetric algorithm. It's only available in Node.js");
      return this.getSigv4aSigner().presign(t, r);
    }
    return this.sigv4Signer.presign(t, r);
  }
  async presignWithCredentials(t, r, n = {}) {
    if (n.signingRegion === "*")
      throw new Error("Method presignWithCredentials is not supported for [signingRegion=*].");
    return this.sigv4Signer.presignWithCredentials(t, r, n);
  }
  getSigv4aSigner() {
    if (!this.sigv4aSigner) {
      let t = null;
      try {
        if (t = wm.CrtSignerV4, typeof t != "function")
          throw new Error();
      } catch (r) {
        throw r.message = `${r.message}
Please check whether you have installed the "@aws-sdk/signature-v4-crt" package explicitly. 
You must also register the package by calling [require("@aws-sdk/signature-v4-crt");] or an ESM equivalent such as [import "@aws-sdk/signature-v4-crt";]. 
For more information please go to https://github.com/aws/aws-sdk-js-v3#functionality-requiring-aws-common-runtime-crt`, r;
      }
      this.sigv4aSigner = new t({
        ...this.signerOptions,
        signingAlgorithm: 1
      });
    }
    return this.sigv4aSigner;
  }
};
var es = "required";
var d = "type";
var f = "conditions";
var m = "fn";
var y = "argv";
var B = "ref";
var H = "assign";
var S = "url";
var C = "properties";
var bc = "backend";
var Te = "authSchemes";
var be = "disableDoubleEncoding";
var we = "signingName";
var Pe = "signingRegion";
var v = "headers";
var ts = "signingRegionSet";
var Em = false;
var Se = true;
var xe = "isSet";
var te = "booleanEquals";
var _ = "error";
var rr = "aws.partition";
var L = "stringEquals";
var z = "getAttr";
var ce = "name";
var Be = "substring";
var Fi = "bucketSuffix";
var wc = "parseURL";
var Di = "{url#scheme}://{url#authority}/{uri_encoded_bucket}{url#path}";
var E = "endpoint";
var x = "tree";
var xc = "aws.isVirtualHostableS3Bucket";
var Kt = "{url#scheme}://{Bucket}.{url#authority}{url#path}";
var ke = "not";
var Xt = "{url#scheme}://{url#authority}{url#path}";
var Ec = "hardwareType";
var Ac = "regionPrefix";
var Ui = "bucketAliasSuffix";
var Cn = "outpostId";
var Je = "isValidHostLabel";
var rs = "sigv4a";
var $t = "s3-outposts";
var ct = "s3";
var Sc = "{url#scheme}://{url#authority}{url#normalizedPath}{Bucket}";
var Cc = "https://{Bucket}.s3-accelerate.{partitionResult#dnsSuffix}";
var $i = "https://{Bucket}.s3.{partitionResult#dnsSuffix}";
var vc = "aws.parseArn";
var Rc = "bucketArn";
var _c = "arnType";
var nr = "";
var ns = "s3-object-lambda";
var Tc = "accesspoint";
var ss = "accessPointName";
var Li = "{url#scheme}://{accessPointName}-{bucketArn#accountId}.{url#authority}{url#path}";
var Hi = "mrapPartition";
var ji = "outpostType";
var zi = "arnPrefix";
var Bc = "{url#scheme}://{url#authority}{url#normalizedPath}{uri_encoded_bucket}";
var qi = "https://s3.{partitionResult#dnsSuffix}/{uri_encoded_bucket}";
var Wi = "https://s3.{partitionResult#dnsSuffix}";
var tt = { [es]: false, [d]: "String" };
var rt = { [es]: true, default: false, [d]: "Boolean" };
var Bt = { [es]: false, [d]: "Boolean" };
var Ce = { [m]: te, [y]: [{ [B]: "Accelerate" }, true] };
var U = { [m]: te, [y]: [{ [B]: "UseFIPS" }, true] };
var D = { [m]: te, [y]: [{ [B]: "UseDualStack" }, true] };
var W = { [m]: xe, [y]: [{ [B]: "Endpoint" }] };
var kc = { [m]: rr, [y]: [{ [B]: "Region" }], [H]: "partitionResult" };
var Gi = { [m]: L, [y]: [{ [m]: z, [y]: [{ [B]: "partitionResult" }, ce] }, "aws-cn"] };
var sr = { [m]: xe, [y]: [{ [B]: "Bucket" }] };
var le = { [B]: "Bucket" };
var de = { [m]: wc, [y]: [{ [B]: "Endpoint" }], [H]: "url" };
var Zt = { [m]: te, [y]: [{ [m]: z, [y]: [{ [B]: "url" }, "isIp"] }, true] };
var Nc = { [B]: "url" };
var Pc = { [m]: "uriEncode", [y]: [le], [H]: "uri_encoded_bucket" };
var Me = { [bc]: "S3Express", [Te]: [{ [be]: true, [ce]: "sigv4", [we]: "s3express", [Pe]: "{Region}" }] };
var k = {};
var Oc = { [m]: xc, [y]: [le, false] };
var Dr = { [_]: "S3Express bucket name is not a valid virtual hostable name.", [d]: _ };
var ir = { [bc]: "S3Express", [Te]: [{ [be]: true, [ce]: "sigv4-s3express", [we]: "s3express", [Pe]: "{Region}" }] };
var Vi = { [m]: xe, [y]: [{ [B]: "UseS3ExpressControlEndpoint" }] };
var Ki = { [m]: te, [y]: [{ [B]: "UseS3ExpressControlEndpoint" }, true] };
var N = { [m]: ke, [y]: [W] };
var Xi = { [_]: "Unrecognized S3Express bucket name format.", [d]: _ };
var Zi = { [m]: ke, [y]: [sr] };
var Yi = { [B]: Ec };
var Qi = { [f]: [N], [_]: "Expected a endpoint to be specified but no endpoint was found", [d]: _ };
var zt = { [Te]: [{ [be]: true, [ce]: rs, [we]: $t, [ts]: ["*"] }, { [be]: true, [ce]: "sigv4", [we]: $t, [Pe]: "{Region}" }] };
var Ur = { [m]: te, [y]: [{ [B]: "ForcePathStyle" }, false] };
var Am = { [B]: "ForcePathStyle" };
var q = { [m]: te, [y]: [{ [B]: "Accelerate" }, false] };
var K = { [m]: L, [y]: [{ [B]: "Region" }, "aws-global"] };
var Y = { [Te]: [{ [be]: true, [ce]: "sigv4", [we]: ct, [Pe]: "us-east-1" }] };
var M = { [m]: ke, [y]: [K] };
var Q = { [m]: te, [y]: [{ [B]: "UseGlobalEndpoint" }, true] };
var Ji = { [S]: "https://{Bucket}.s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [C]: { [Te]: [{ [be]: true, [ce]: "sigv4", [we]: ct, [Pe]: "{Region}" }] }, [v]: {} };
var V = { [Te]: [{ [be]: true, [ce]: "sigv4", [we]: ct, [Pe]: "{Region}" }] };
var J = { [m]: te, [y]: [{ [B]: "UseGlobalEndpoint" }, false] };
var O = { [m]: te, [y]: [{ [B]: "UseDualStack" }, false] };
var eo = { [S]: "https://{Bucket}.s3-fips.{Region}.{partitionResult#dnsSuffix}", [C]: V, [v]: {} };
var P = { [m]: te, [y]: [{ [B]: "UseFIPS" }, false] };
var to = { [S]: "https://{Bucket}.s3-accelerate.dualstack.{partitionResult#dnsSuffix}", [C]: V, [v]: {} };
var ro = { [S]: "https://{Bucket}.s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [C]: V, [v]: {} };
var $r = { [m]: te, [y]: [{ [m]: z, [y]: [Nc, "isIp"] }, false] };
var Lr = { [S]: Sc, [C]: V, [v]: {} };
var vn = { [S]: Kt, [C]: V, [v]: {} };
var no = { [E]: vn, [d]: E };
var Hr = { [S]: Cc, [C]: V, [v]: {} };
var so = { [S]: "https://{Bucket}.s3.{Region}.{partitionResult#dnsSuffix}", [C]: V, [v]: {} };
var qt = { [_]: "Invalid region: region was not a valid DNS name.", [d]: _ };
var pe = { [B]: Rc };
var Mc = { [B]: _c };
var jr = { [m]: z, [y]: [pe, "service"] };
var is = { [B]: ss };
var io = { [f]: [D], [_]: "S3 Object Lambda does not support Dual-stack", [d]: _ };
var oo = { [f]: [Ce], [_]: "S3 Object Lambda does not support S3 Accelerate", [d]: _ };
var ao = { [f]: [{ [m]: xe, [y]: [{ [B]: "DisableAccessPoints" }] }, { [m]: te, [y]: [{ [B]: "DisableAccessPoints" }, true] }], [_]: "Access points are not supported for this operation", [d]: _ };
var zr = { [f]: [{ [m]: xe, [y]: [{ [B]: "UseArnRegion" }] }, { [m]: te, [y]: [{ [B]: "UseArnRegion" }, false] }, { [m]: ke, [y]: [{ [m]: L, [y]: [{ [m]: z, [y]: [pe, "region"] }, "{Region}"] }] }], [_]: "Invalid configuration: region from ARN `{bucketArn#region}` does not match client region `{Region}` and UseArnRegion is `false`", [d]: _ };
var Ic = { [m]: z, [y]: [{ [B]: "bucketPartition" }, ce] };
var Fc = { [m]: z, [y]: [pe, "accountId"] };
var qr = { [Te]: [{ [be]: true, [ce]: "sigv4", [we]: ns, [Pe]: "{bucketArn#region}" }] };
var co = { [_]: "Invalid ARN: The access point name may only contain a-z, A-Z, 0-9 and `-`. Found: `{accessPointName}`", [d]: _ };
var Wr = { [_]: "Invalid ARN: The account id may only contain a-z, A-Z, 0-9 and `-`. Found: `{bucketArn#accountId}`", [d]: _ };
var Gr = { [_]: "Invalid region in ARN: `{bucketArn#region}` (invalid DNS name)", [d]: _ };
var Vr = { [_]: "Client was configured for partition `{partitionResult#name}` but ARN (`{Bucket}`) has `{bucketPartition#name}`", [d]: _ };
var uo = { [_]: "Invalid ARN: The ARN may only contain a single resource component after `accesspoint`.", [d]: _ };
var lo = { [_]: "Invalid ARN: Expected a resource of the format `accesspoint:<accesspoint name>` but no name was provided", [d]: _ };
var kt = { [Te]: [{ [be]: true, [ce]: "sigv4", [we]: ct, [Pe]: "{bucketArn#region}" }] };
var fo = { [Te]: [{ [be]: true, [ce]: rs, [we]: $t, [ts]: ["*"] }, { [be]: true, [ce]: "sigv4", [we]: $t, [Pe]: "{bucketArn#region}" }] };
var ho = { [m]: vc, [y]: [le] };
var po = { [S]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [C]: V, [v]: {} };
var go = { [S]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [C]: V, [v]: {} };
var mo = { [S]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [C]: V, [v]: {} };
var Kr = { [S]: Bc, [C]: V, [v]: {} };
var yo = { [S]: "https://s3.{Region}.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [C]: V, [v]: {} };
var bo = { [B]: "UseObjectLambdaEndpoint" };
var Xr = { [Te]: [{ [be]: true, [ce]: "sigv4", [we]: ns, [Pe]: "{Region}" }] };
var wo = { [S]: "https://s3-fips.dualstack.{Region}.{partitionResult#dnsSuffix}", [C]: V, [v]: {} };
var xo = { [S]: "https://s3-fips.{Region}.{partitionResult#dnsSuffix}", [C]: V, [v]: {} };
var Eo = { [S]: "https://s3.dualstack.{Region}.{partitionResult#dnsSuffix}", [C]: V, [v]: {} };
var Zr = { [S]: Xt, [C]: V, [v]: {} };
var Ao = { [S]: "https://s3.{Region}.{partitionResult#dnsSuffix}", [C]: V, [v]: {} };
var Yr = [{ [B]: "Region" }];
var Sm = [{ [B]: "Endpoint" }];
var Cm = [le];
var Qr = [D];
var Wt = [Ce];
var Ve = [W, de];
var So = [{ [m]: xe, [y]: [{ [B]: "DisableS3ExpressSessionAuth" }] }, { [m]: te, [y]: [{ [B]: "DisableS3ExpressSessionAuth" }, true] }];
var Co = [Zt];
var Jr = [Pc];
var en = [Oc];
var nt = [U];
var vo = [{ [m]: Be, [y]: [le, 6, 14, true], [H]: "s3expressAvailabilityZoneId" }, { [m]: Be, [y]: [le, 14, 16, true], [H]: "s3expressAvailabilityZoneDelim" }, { [m]: L, [y]: [{ [B]: "s3expressAvailabilityZoneDelim" }, "--"] }];
var Ro = [{ [f]: [U], [E]: { [S]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [C]: Me, [v]: {} }, [d]: E }, { [E]: { [S]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [C]: Me, [v]: {} }, [d]: E }];
var _o = [{ [m]: Be, [y]: [le, 6, 15, true], [H]: "s3expressAvailabilityZoneId" }, { [m]: Be, [y]: [le, 15, 17, true], [H]: "s3expressAvailabilityZoneDelim" }, { [m]: L, [y]: [{ [B]: "s3expressAvailabilityZoneDelim" }, "--"] }];
var To = [{ [f]: [U], [E]: { [S]: "https://{Bucket}.s3express-fips-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [C]: ir, [v]: {} }, [d]: E }, { [E]: { [S]: "https://{Bucket}.s3express-{s3expressAvailabilityZoneId}.{Region}.amazonaws.com", [C]: ir, [v]: {} }, [d]: E }];
var vm = [sr];
var Bo = [{ [m]: Je, [y]: [{ [B]: Cn }, false] }];
var ko = [{ [m]: L, [y]: [{ [B]: Ac }, "beta"] }];
var Rm = ["*"];
var De = [kc];
var No = [{ [m]: Je, [y]: [{ [B]: "Region" }, false] }];
var Ue = [{ [m]: L, [y]: [{ [B]: "Region" }, "us-east-1"] }];
var tn = [{ [m]: L, [y]: [Mc, Tc] }];
var Po = [{ [m]: z, [y]: [pe, "resourceId[1]"], [H]: ss }, { [m]: ke, [y]: [{ [m]: L, [y]: [is, nr] }] }];
var _m = [pe, "resourceId[1]"];
var rn = [{ [m]: ke, [y]: [{ [m]: L, [y]: [{ [m]: z, [y]: [pe, "region"] }, nr] }] }];
var Oo = [{ [m]: ke, [y]: [{ [m]: xe, [y]: [{ [m]: z, [y]: [pe, "resourceId[2]"] }] }] }];
var Tm = [pe, "resourceId[2]"];
var nn = [{ [m]: rr, [y]: [{ [m]: z, [y]: [pe, "region"] }], [H]: "bucketPartition" }];
var Mo = [{ [m]: L, [y]: [Ic, { [m]: z, [y]: [{ [B]: "partitionResult" }, ce] }] }];
var sn = [{ [m]: Je, [y]: [{ [m]: z, [y]: [pe, "region"] }, true] }];
var on = [{ [m]: Je, [y]: [Fc, false] }];
var Io = [{ [m]: Je, [y]: [is, false] }];
var Fo = [{ [m]: Je, [y]: [{ [B]: "Region" }, true] }];
var Bm = { version: "1.0", parameters: { Bucket: tt, Region: tt, UseFIPS: rt, UseDualStack: rt, Endpoint: tt, ForcePathStyle: rt, Accelerate: rt, UseGlobalEndpoint: rt, UseObjectLambdaEndpoint: Bt, Key: tt, Prefix: tt, CopySource: tt, DisableAccessPoints: Bt, DisableMultiRegionAccessPoints: rt, UseArnRegion: Bt, UseS3ExpressControlEndpoint: Bt, DisableS3ExpressSessionAuth: Bt }, rules: [{ [f]: [{ [m]: xe, [y]: Yr }], rules: [{ [f]: [Ce, U], error: "Accelerate cannot be used with FIPS", [d]: _ }, { [f]: [D, W], error: "Cannot set dual-stack in combination with a custom endpoint.", [d]: _ }, { [f]: [W, U], error: "A custom endpoint cannot be combined with FIPS", [d]: _ }, { [f]: [W, Ce], error: "A custom endpoint cannot be combined with S3 Accelerate", [d]: _ }, { [f]: [U, kc, Gi], error: "Partition does not support FIPS", [d]: _ }, { [f]: [sr, { [m]: Be, [y]: [le, 0, 6, Se], [H]: Fi }, { [m]: L, [y]: [{ [B]: Fi }, "--x-s3"] }], rules: [{ [f]: Qr, error: "S3Express does not support Dual-stack.", [d]: _ }, { [f]: Wt, error: "S3Express does not support S3 Accelerate.", [d]: _ }, { [f]: Ve, rules: [{ [f]: So, rules: [{ [f]: Co, rules: [{ [f]: Jr, rules: [{ endpoint: { [S]: Di, [C]: Me, [v]: k }, [d]: E }], [d]: x }], [d]: x }, { [f]: en, rules: [{ endpoint: { [S]: Kt, [C]: Me, [v]: k }, [d]: E }], [d]: x }, Dr], [d]: x }, { [f]: Co, rules: [{ [f]: Jr, rules: [{ endpoint: { [S]: Di, [C]: ir, [v]: k }, [d]: E }], [d]: x }], [d]: x }, { [f]: en, rules: [{ endpoint: { [S]: Kt, [C]: ir, [v]: k }, [d]: E }], [d]: x }, Dr], [d]: x }, { [f]: [Vi, Ki], rules: [{ [f]: [Pc, N], rules: [{ [f]: nt, endpoint: { [S]: "https://s3express-control-fips.{Region}.amazonaws.com/{uri_encoded_bucket}", [C]: Me, [v]: k }, [d]: E }, { endpoint: { [S]: "https://s3express-control.{Region}.amazonaws.com/{uri_encoded_bucket}", [C]: Me, [v]: k }, [d]: E }], [d]: x }], [d]: x }, { [f]: en, rules: [{ [f]: So, rules: [{ [f]: vo, rules: Ro, [d]: x }, { [f]: _o, rules: Ro, [d]: x }, Xi], [d]: x }, { [f]: vo, rules: To, [d]: x }, { [f]: _o, rules: To, [d]: x }, Xi], [d]: x }, Dr], [d]: x }, { [f]: [Zi, Vi, Ki], rules: [{ [f]: Ve, endpoint: { [S]: Xt, [C]: Me, [v]: k }, [d]: E }, { [f]: nt, endpoint: { [S]: "https://s3express-control-fips.{Region}.amazonaws.com", [C]: Me, [v]: k }, [d]: E }, { endpoint: { [S]: "https://s3express-control.{Region}.amazonaws.com", [C]: Me, [v]: k }, [d]: E }], [d]: x }, { [f]: [sr, { [m]: Be, [y]: [le, 49, 50, Se], [H]: Ec }, { [m]: Be, [y]: [le, 8, 12, Se], [H]: Ac }, { [m]: Be, [y]: [le, 0, 7, Se], [H]: Ui }, { [m]: Be, [y]: [le, 32, 49, Se], [H]: Cn }, { [m]: rr, [y]: Yr, [H]: "regionPartition" }, { [m]: L, [y]: [{ [B]: Ui }, "--op-s3"] }], rules: [{ [f]: Bo, rules: [{ [f]: [{ [m]: L, [y]: [Yi, "e"] }], rules: [{ [f]: ko, rules: [Qi, { [f]: Ve, endpoint: { [S]: "https://{Bucket}.ec2.{url#authority}", [C]: zt, [v]: k }, [d]: E }], [d]: x }, { endpoint: { [S]: "https://{Bucket}.ec2.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [C]: zt, [v]: k }, [d]: E }], [d]: x }, { [f]: [{ [m]: L, [y]: [Yi, "o"] }], rules: [{ [f]: ko, rules: [Qi, { [f]: Ve, endpoint: { [S]: "https://{Bucket}.op-{outpostId}.{url#authority}", [C]: zt, [v]: k }, [d]: E }], [d]: x }, { endpoint: { [S]: "https://{Bucket}.op-{outpostId}.s3-outposts.{Region}.{regionPartition#dnsSuffix}", [C]: zt, [v]: k }, [d]: E }], [d]: x }, { error: 'Unrecognized hardware type: "Expected hardware type o or e but got {hardwareType}"', [d]: _ }], [d]: x }, { error: "Invalid ARN: The outpost Id must only contain a-z, A-Z, 0-9 and `-`.", [d]: _ }], [d]: x }, { [f]: vm, rules: [{ [f]: [W, { [m]: ke, [y]: [{ [m]: xe, [y]: [{ [m]: wc, [y]: Sm }] }] }], error: "Custom endpoint `{Endpoint}` was not a valid URI", [d]: _ }, { [f]: [Ur, Oc], rules: [{ [f]: De, rules: [{ [f]: No, rules: [{ [f]: [Ce, Gi], error: "S3 Accelerate cannot be used in this region", [d]: _ }, { [f]: [D, U, q, N, K], endpoint: { [S]: "https://{Bucket}.s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [C]: Y, [v]: k }, [d]: E }, { [f]: [D, U, q, N, M, Q], rules: [{ endpoint: Ji, [d]: E }], [d]: x }, { [f]: [D, U, q, N, M, J], endpoint: Ji, [d]: E }, { [f]: [O, U, q, N, K], endpoint: { [S]: "https://{Bucket}.s3-fips.us-east-1.{partitionResult#dnsSuffix}", [C]: Y, [v]: k }, [d]: E }, { [f]: [O, U, q, N, M, Q], rules: [{ endpoint: eo, [d]: E }], [d]: x }, { [f]: [O, U, q, N, M, J], endpoint: eo, [d]: E }, { [f]: [D, P, Ce, N, K], endpoint: { [S]: "https://{Bucket}.s3-accelerate.dualstack.us-east-1.{partitionResult#dnsSuffix}", [C]: Y, [v]: k }, [d]: E }, { [f]: [D, P, Ce, N, M, Q], rules: [{ endpoint: to, [d]: E }], [d]: x }, { [f]: [D, P, Ce, N, M, J], endpoint: to, [d]: E }, { [f]: [D, P, q, N, K], endpoint: { [S]: "https://{Bucket}.s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [C]: Y, [v]: k }, [d]: E }, { [f]: [D, P, q, N, M, Q], rules: [{ endpoint: ro, [d]: E }], [d]: x }, { [f]: [D, P, q, N, M, J], endpoint: ro, [d]: E }, { [f]: [O, P, q, W, de, Zt, K], endpoint: { [S]: Sc, [C]: Y, [v]: k }, [d]: E }, { [f]: [O, P, q, W, de, $r, K], endpoint: { [S]: Kt, [C]: Y, [v]: k }, [d]: E }, { [f]: [O, P, q, W, de, Zt, M, Q], rules: [{ [f]: Ue, endpoint: Lr, [d]: E }, { endpoint: Lr, [d]: E }], [d]: x }, { [f]: [O, P, q, W, de, $r, M, Q], rules: [{ [f]: Ue, endpoint: vn, [d]: E }, no], [d]: x }, { [f]: [O, P, q, W, de, Zt, M, J], endpoint: Lr, [d]: E }, { [f]: [O, P, q, W, de, $r, M, J], endpoint: vn, [d]: E }, { [f]: [O, P, Ce, N, K], endpoint: { [S]: Cc, [C]: Y, [v]: k }, [d]: E }, { [f]: [O, P, Ce, N, M, Q], rules: [{ [f]: Ue, endpoint: Hr, [d]: E }, { endpoint: Hr, [d]: E }], [d]: x }, { [f]: [O, P, Ce, N, M, J], endpoint: Hr, [d]: E }, { [f]: [O, P, q, N, K], endpoint: { [S]: $i, [C]: Y, [v]: k }, [d]: E }, { [f]: [O, P, q, N, M, Q], rules: [{ [f]: Ue, endpoint: { [S]: $i, [C]: V, [v]: k }, [d]: E }, { endpoint: so, [d]: E }], [d]: x }, { [f]: [O, P, q, N, M, J], endpoint: so, [d]: E }], [d]: x }, qt], [d]: x }], [d]: x }, { [f]: [W, de, { [m]: L, [y]: [{ [m]: z, [y]: [Nc, "scheme"] }, "http"] }, { [m]: xc, [y]: [le, Se] }, Ur, P, O, q], rules: [{ [f]: De, rules: [{ [f]: No, rules: [no], [d]: x }, qt], [d]: x }], [d]: x }, { [f]: [Ur, { [m]: vc, [y]: Cm, [H]: Rc }], rules: [{ [f]: [{ [m]: z, [y]: [pe, "resourceId[0]"], [H]: _c }, { [m]: ke, [y]: [{ [m]: L, [y]: [Mc, nr] }] }], rules: [{ [f]: [{ [m]: L, [y]: [jr, ns] }], rules: [{ [f]: tn, rules: [{ [f]: Po, rules: [io, oo, { [f]: rn, rules: [ao, { [f]: Oo, rules: [zr, { [f]: nn, rules: [{ [f]: De, rules: [{ [f]: Mo, rules: [{ [f]: sn, rules: [{ [f]: [{ [m]: L, [y]: [Fc, nr] }], error: "Invalid ARN: Missing account id", [d]: _ }, { [f]: on, rules: [{ [f]: Io, rules: [{ [f]: Ve, endpoint: { [S]: Li, [C]: qr, [v]: k }, [d]: E }, { [f]: nt, endpoint: { [S]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [C]: qr, [v]: k }, [d]: E }, { endpoint: { [S]: "https://{accessPointName}-{bucketArn#accountId}.s3-object-lambda.{bucketArn#region}.{bucketPartition#dnsSuffix}", [C]: qr, [v]: k }, [d]: E }], [d]: x }, co], [d]: x }, Wr], [d]: x }, Gr], [d]: x }, Vr], [d]: x }], [d]: x }], [d]: x }, uo], [d]: x }, { error: "Invalid ARN: bucket ARN is missing a region", [d]: _ }], [d]: x }, lo], [d]: x }, { error: "Invalid ARN: Object Lambda ARNs only support `accesspoint` arn types, but found: `{arnType}`", [d]: _ }], [d]: x }, { [f]: tn, rules: [{ [f]: Po, rules: [{ [f]: rn, rules: [{ [f]: tn, rules: [{ [f]: rn, rules: [ao, { [f]: Oo, rules: [zr, { [f]: nn, rules: [{ [f]: De, rules: [{ [f]: [{ [m]: L, [y]: [Ic, "{partitionResult#name}"] }], rules: [{ [f]: sn, rules: [{ [f]: [{ [m]: L, [y]: [jr, ct] }], rules: [{ [f]: on, rules: [{ [f]: Io, rules: [{ [f]: Wt, error: "Access Points do not support S3 Accelerate", [d]: _ }, { [f]: [U, D], endpoint: { [S]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [C]: kt, [v]: k }, [d]: E }, { [f]: [U, O], endpoint: { [S]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint-fips.{bucketArn#region}.{bucketPartition#dnsSuffix}", [C]: kt, [v]: k }, [d]: E }, { [f]: [P, D], endpoint: { [S]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.dualstack.{bucketArn#region}.{bucketPartition#dnsSuffix}", [C]: kt, [v]: k }, [d]: E }, { [f]: [P, O, W, de], endpoint: { [S]: Li, [C]: kt, [v]: k }, [d]: E }, { [f]: [P, O], endpoint: { [S]: "https://{accessPointName}-{bucketArn#accountId}.s3-accesspoint.{bucketArn#region}.{bucketPartition#dnsSuffix}", [C]: kt, [v]: k }, [d]: E }], [d]: x }, co], [d]: x }, Wr], [d]: x }, { error: "Invalid ARN: The ARN was not for the S3 service, found: {bucketArn#service}", [d]: _ }], [d]: x }, Gr], [d]: x }, Vr], [d]: x }], [d]: x }], [d]: x }, uo], [d]: x }], [d]: x }], [d]: x }, { [f]: [{ [m]: Je, [y]: [is, Se] }], rules: [{ [f]: Qr, error: "S3 MRAP does not support dual-stack", [d]: _ }, { [f]: nt, error: "S3 MRAP does not support FIPS", [d]: _ }, { [f]: Wt, error: "S3 MRAP does not support S3 Accelerate", [d]: _ }, { [f]: [{ [m]: te, [y]: [{ [B]: "DisableMultiRegionAccessPoints" }, Se] }], error: "Invalid configuration: Multi-Region Access Point ARNs are disabled.", [d]: _ }, { [f]: [{ [m]: rr, [y]: Yr, [H]: Hi }], rules: [{ [f]: [{ [m]: L, [y]: [{ [m]: z, [y]: [{ [B]: Hi }, ce] }, { [m]: z, [y]: [pe, "partition"] }] }], rules: [{ endpoint: { [S]: "https://{accessPointName}.accesspoint.s3-global.{mrapPartition#dnsSuffix}", [C]: { [Te]: [{ [be]: Se, name: rs, [we]: ct, [ts]: Rm }] }, [v]: k }, [d]: E }], [d]: x }, { error: "Client was configured for partition `{mrapPartition#name}` but bucket referred to partition `{bucketArn#partition}`", [d]: _ }], [d]: x }], [d]: x }, { error: "Invalid Access Point Name", [d]: _ }], [d]: x }, lo], [d]: x }, { [f]: [{ [m]: L, [y]: [jr, $t] }], rules: [{ [f]: Qr, error: "S3 Outposts does not support Dual-stack", [d]: _ }, { [f]: nt, error: "S3 Outposts does not support FIPS", [d]: _ }, { [f]: Wt, error: "S3 Outposts does not support S3 Accelerate", [d]: _ }, { [f]: [{ [m]: xe, [y]: [{ [m]: z, [y]: [pe, "resourceId[4]"] }] }], error: "Invalid Arn: Outpost Access Point ARN contains sub resources", [d]: _ }, { [f]: [{ [m]: z, [y]: _m, [H]: Cn }], rules: [{ [f]: Bo, rules: [zr, { [f]: nn, rules: [{ [f]: De, rules: [{ [f]: Mo, rules: [{ [f]: sn, rules: [{ [f]: on, rules: [{ [f]: [{ [m]: z, [y]: Tm, [H]: ji }], rules: [{ [f]: [{ [m]: z, [y]: [pe, "resourceId[3]"], [H]: ss }], rules: [{ [f]: [{ [m]: L, [y]: [{ [B]: ji }, Tc] }], rules: [{ [f]: Ve, endpoint: { [S]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.{url#authority}", [C]: fo, [v]: k }, [d]: E }, { endpoint: { [S]: "https://{accessPointName}-{bucketArn#accountId}.{outpostId}.s3-outposts.{bucketArn#region}.{bucketPartition#dnsSuffix}", [C]: fo, [v]: k }, [d]: E }], [d]: x }, { error: "Expected an outpost type `accesspoint`, found {outpostType}", [d]: _ }], [d]: x }, { error: "Invalid ARN: expected an access point name", [d]: _ }], [d]: x }, { error: "Invalid ARN: Expected a 4-component resource", [d]: _ }], [d]: x }, Wr], [d]: x }, Gr], [d]: x }, Vr], [d]: x }], [d]: x }], [d]: x }, { error: "Invalid ARN: The outpost Id may only contain a-z, A-Z, 0-9 and `-`. Found: `{outpostId}`", [d]: _ }], [d]: x }, { error: "Invalid ARN: The Outpost Id was not set", [d]: _ }], [d]: x }, { error: "Invalid ARN: Unrecognized format: {Bucket} (type: {arnType})", [d]: _ }], [d]: x }, { error: "Invalid ARN: No ARN type specified", [d]: _ }], [d]: x }, { [f]: [{ [m]: Be, [y]: [le, 0, 4, Em], [H]: zi }, { [m]: L, [y]: [{ [B]: zi }, "arn:"] }, { [m]: ke, [y]: [{ [m]: xe, [y]: [ho] }] }], error: "Invalid ARN: `{Bucket}` was not a valid ARN", [d]: _ }, { [f]: [{ [m]: te, [y]: [Am, Se] }, ho], error: "Path-style addressing cannot be used with ARN buckets", [d]: _ }, { [f]: Jr, rules: [{ [f]: De, rules: [{ [f]: [q], rules: [{ [f]: [D, N, U, K], endpoint: { [S]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [C]: Y, [v]: k }, [d]: E }, { [f]: [D, N, U, M, Q], rules: [{ endpoint: po, [d]: E }], [d]: x }, { [f]: [D, N, U, M, J], endpoint: po, [d]: E }, { [f]: [O, N, U, K], endpoint: { [S]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [C]: Y, [v]: k }, [d]: E }, { [f]: [O, N, U, M, Q], rules: [{ endpoint: go, [d]: E }], [d]: x }, { [f]: [O, N, U, M, J], endpoint: go, [d]: E }, { [f]: [D, N, P, K], endpoint: { [S]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}/{uri_encoded_bucket}", [C]: Y, [v]: k }, [d]: E }, { [f]: [D, N, P, M, Q], rules: [{ endpoint: mo, [d]: E }], [d]: x }, { [f]: [D, N, P, M, J], endpoint: mo, [d]: E }, { [f]: [O, W, de, P, K], endpoint: { [S]: Bc, [C]: Y, [v]: k }, [d]: E }, { [f]: [O, W, de, P, M, Q], rules: [{ [f]: Ue, endpoint: Kr, [d]: E }, { endpoint: Kr, [d]: E }], [d]: x }, { [f]: [O, W, de, P, M, J], endpoint: Kr, [d]: E }, { [f]: [O, N, P, K], endpoint: { [S]: qi, [C]: Y, [v]: k }, [d]: E }, { [f]: [O, N, P, M, Q], rules: [{ [f]: Ue, endpoint: { [S]: qi, [C]: V, [v]: k }, [d]: E }, { endpoint: yo, [d]: E }], [d]: x }, { [f]: [O, N, P, M, J], endpoint: yo, [d]: E }], [d]: x }, { error: "Path-style addressing cannot be used with S3 Accelerate", [d]: _ }], [d]: x }], [d]: x }], [d]: x }, { [f]: [{ [m]: xe, [y]: [bo] }, { [m]: te, [y]: [bo, Se] }], rules: [{ [f]: De, rules: [{ [f]: Fo, rules: [io, oo, { [f]: Ve, endpoint: { [S]: Xt, [C]: Xr, [v]: k }, [d]: E }, { [f]: nt, endpoint: { [S]: "https://s3-object-lambda-fips.{Region}.{partitionResult#dnsSuffix}", [C]: Xr, [v]: k }, [d]: E }, { endpoint: { [S]: "https://s3-object-lambda.{Region}.{partitionResult#dnsSuffix}", [C]: Xr, [v]: k }, [d]: E }], [d]: x }, qt], [d]: x }], [d]: x }, { [f]: [Zi], rules: [{ [f]: De, rules: [{ [f]: Fo, rules: [{ [f]: [U, D, N, K], endpoint: { [S]: "https://s3-fips.dualstack.us-east-1.{partitionResult#dnsSuffix}", [C]: Y, [v]: k }, [d]: E }, { [f]: [U, D, N, M, Q], rules: [{ endpoint: wo, [d]: E }], [d]: x }, { [f]: [U, D, N, M, J], endpoint: wo, [d]: E }, { [f]: [U, O, N, K], endpoint: { [S]: "https://s3-fips.us-east-1.{partitionResult#dnsSuffix}", [C]: Y, [v]: k }, [d]: E }, { [f]: [U, O, N, M, Q], rules: [{ endpoint: xo, [d]: E }], [d]: x }, { [f]: [U, O, N, M, J], endpoint: xo, [d]: E }, { [f]: [P, D, N, K], endpoint: { [S]: "https://s3.dualstack.us-east-1.{partitionResult#dnsSuffix}", [C]: Y, [v]: k }, [d]: E }, { [f]: [P, D, N, M, Q], rules: [{ endpoint: Eo, [d]: E }], [d]: x }, { [f]: [P, D, N, M, J], endpoint: Eo, [d]: E }, { [f]: [P, O, W, de, K], endpoint: { [S]: Xt, [C]: Y, [v]: k }, [d]: E }, { [f]: [P, O, W, de, M, Q], rules: [{ [f]: Ue, endpoint: Zr, [d]: E }, { endpoint: Zr, [d]: E }], [d]: x }, { [f]: [P, O, W, de, M, J], endpoint: Zr, [d]: E }, { [f]: [P, O, N, K], endpoint: { [S]: Wi, [C]: Y, [v]: k }, [d]: E }, { [f]: [P, O, N, M, Q], rules: [{ [f]: Ue, endpoint: { [S]: Wi, [C]: V, [v]: k }, [d]: E }, { endpoint: Ao, [d]: E }], [d]: x }, { [f]: [P, O, N, M, J], endpoint: Ao, [d]: E }], [d]: x }, qt], [d]: x }], [d]: x }], [d]: x }, { error: "A region must be set when sending requests to S3.", [d]: _ }] };
var km = Bm;
var Nm = (e, t = {}) => Cl(km, {
  endpointParams: e,
  logger: t.logger
});
er.aws = ya;
var Pm = (e) => ({
  apiVersion: "2006-03-01",
  base64Decoder: (e == null ? void 0 : e.base64Decoder) ?? Bn,
  base64Encoder: (e == null ? void 0 : e.base64Encoder) ?? Nn,
  disableHostPrefix: (e == null ? void 0 : e.disableHostPrefix) ?? false,
  endpointProvider: (e == null ? void 0 : e.endpointProvider) ?? Nm,
  extensions: (e == null ? void 0 : e.extensions) ?? [],
  getAwsChunkedEncodingStream: (e == null ? void 0 : e.getAwsChunkedEncodingStream) ?? lu,
  logger: (e == null ? void 0 : e.logger) ?? new Tn(),
  sdkStreamMixin: (e == null ? void 0 : e.sdkStreamMixin) ?? wu,
  serviceId: (e == null ? void 0 : e.serviceId) ?? "S3",
  signerConstructor: (e == null ? void 0 : e.signerConstructor) ?? xm,
  signingEscapePath: (e == null ? void 0 : e.signingEscapePath) ?? false,
  urlParser: (e == null ? void 0 : e.urlParser) ?? tr,
  useArnRegion: (e == null ? void 0 : e.useArnRegion) ?? false,
  utf8Decoder: (e == null ? void 0 : e.utf8Decoder) ?? Qe,
  utf8Encoder: (e == null ? void 0 : e.utf8Encoder) ?? kn
});
var Om = ["in-region", "cross-region", "mobile", "standard", "legacy"];
var Mm = ({ defaultsMode: e } = {}) => aa(async () => {
  const t = typeof e == "function" ? await e() : e;
  switch (t == null ? void 0 : t.toLowerCase()) {
    case "auto":
      return Promise.resolve(Im() ? "mobile" : "standard");
    case "mobile":
    case "in-region":
    case "cross-region":
    case "standard":
    case "legacy":
      return Promise.resolve(t == null ? void 0 : t.toLocaleLowerCase());
    case void 0:
      return Promise.resolve("legacy");
    default:
      throw new Error(`Invalid parameter for "defaultsMode", expect ${Om.join(", ")}, got ${t}`);
  }
});
var Im = () => {
  var r, n;
  const e = typeof window < "u" && ((r = window == null ? void 0 : window.navigator) != null && r.userAgent) ? gc.parse(window.navigator.userAgent) : void 0, t = (n = e == null ? void 0 : e.platform) == null ? void 0 : n.type;
  return t === "tablet" || t === "mobile";
};
var Fm = (e) => {
  const t = Mm(e), r = () => t().then(qu), n = Pm(e);
  return {
    ...n,
    ...e,
    runtime: "browser",
    defaultsMode: t,
    bodyLengthChecker: (e == null ? void 0 : e.bodyLengthChecker) ?? bm,
    credentialDefaultProvider: (e == null ? void 0 : e.credentialDefaultProvider) ?? ((s) => () => Promise.reject(new Error("Credential is missing"))),
    defaultUserAgentProvider: (e == null ? void 0 : e.defaultUserAgentProvider) ?? D0({ serviceId: n.serviceId, clientVersion: $g.version }),
    eventStreamSerdeProvider: (e == null ? void 0 : e.eventStreamSerdeProvider) ?? um,
    maxAttempts: (e == null ? void 0 : e.maxAttempts) ?? $n,
    md5: (e == null ? void 0 : e.md5) ?? gm,
    region: (e == null ? void 0 : e.region) ?? fm("Region is missing"),
    requestHandler: Pn.create((e == null ? void 0 : e.requestHandler) ?? r),
    retryMode: (e == null ? void 0 : e.retryMode) ?? (async () => (await r()).retryMode || of),
    sha1: (e == null ? void 0 : e.sha1) ?? tc.Sha1,
    sha256: (e == null ? void 0 : e.sha256) ?? uc.Sha256,
    streamCollector: (e == null ? void 0 : e.streamCollector) ?? Ho,
    streamHasher: (e == null ? void 0 : e.streamHasher) ?? lm,
    useDualstackEndpoint: (e == null ? void 0 : e.useDualstackEndpoint) ?? (() => Promise.resolve(Fl)),
    useFipsEndpoint: (e == null ? void 0 : e.useFipsEndpoint) ?? (() => Promise.resolve(Dl))
  };
};
var Dm = (e) => {
  let t = async () => {
    if (e.region === void 0)
      throw new Error("Region is missing from runtimeConfig");
    const r = e.region;
    return typeof r == "string" ? r : r();
  };
  return {
    setRegion(r) {
      t = r;
    },
    region() {
      return t;
    }
  };
};
var Um = (e) => ({
  region: e.region()
});
var an = (e) => e;
var $m = (e, t) => {
  const r = {
    ...an(Dm(e)),
    ...an(Xu(e)),
    ...an(qc(e))
  };
  return t.forEach((n) => n.configure(r)), {
    ...e,
    ...Um(r),
    ...Zu(r),
    ...Wc(r)
  };
};
var Lm = class extends au {
  constructor(...[t]) {
    const r = Fm(t || {}), n = Ff(r), s = Ul(n), i = sf(s), o = Tf(i), a = o, c2 = Jd(a), u = Wd(c2, { session: [() => this, xg] }), l = il(u), h = $l(l), p = $m(h, (t == null ? void 0 : t.extensions) || []);
    super(p), this.config = p, this.middlewareStack.use(Mf(this.config)), this.middlewareStack.use(jl(this.config)), this.middlewareStack.use(Qc(this.config)), this.middlewareStack.use(tu(this.config)), this.middlewareStack.use(ou(this.config)), this.middlewareStack.use(sl(this.config)), this.middlewareStack.use(Yd(this.config)), this.middlewareStack.use(Xc(this.config)), this.middlewareStack.use(ld(this.config)), this.middlewareStack.use(qd(this.config)), this.middlewareStack.use(Il(this.config));
  }
  destroy() {
    super.destroy();
  }
};
function Hm(e) {
  return (t) => async (r) => {
    const n = { ...r.input }, s = [
      {
        target: "SSECustomerKey",
        hash: "SSECustomerKeyMD5"
      },
      {
        target: "CopySourceSSECustomerKey",
        hash: "CopySourceSSECustomerKeyMD5"
      }
    ];
    for (const i of s) {
      const o = n[i.target];
      if (o) {
        let a;
        typeof o == "string" ? qm(o, e) ? a = e.base64Decoder(o) : (a = e.utf8Decoder(o), n[i.target] = e.base64Encoder(a)) : (a = ArrayBuffer.isView(o) ? new Uint8Array(o.buffer, o.byteOffset, o.byteLength) : new Uint8Array(o), n[i.target] = e.base64Encoder(a));
        const c2 = new e.md5();
        c2.update(a), n[i.hash] = e.base64Encoder(await c2.digest());
      }
    }
    return t({
      ...r,
      input: n
    });
  };
}
var jm = {
  name: "ssecMiddleware",
  step: "initialize",
  tags: ["SSE"],
  override: true
};
var zm = (e) => ({
  applyToStack: (t) => {
    t.add(Hm(e), jm);
  }
});
function qm(e, t) {
  if (!/^(?:[A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e))
    return false;
  try {
    return t.base64Decoder(e).length === 32;
  } catch {
    return false;
  }
}
var ee;
(function(e) {
  e.MD5 = "MD5", e.CRC32 = "CRC32", e.CRC32C = "CRC32C", e.SHA1 = "SHA1", e.SHA256 = "SHA256";
})(ee || (ee = {}));
var Do;
(function(e) {
  e.HEADER = "header", e.TRAILER = "trailer";
})(Do || (Do = {}));
var Wm = ee.MD5;
var Gm = ee.CRC32;
var Rn = [
  ee.CRC32,
  ee.CRC32C,
  ee.SHA1,
  ee.SHA256
];
var Vm = [
  ee.CRC32,
  ee.CRC32C,
  ee.SHA1,
  ee.SHA256
];
var Km = (e, { requestChecksumRequired: t, requestAlgorithmMember: r }, n) => {
  const s = n ? Gm : Wm;
  if (!r || !e[r])
    return t ? s : void 0;
  const i = e[r];
  if (!Rn.includes(i))
    throw new Error(`The checksum algorithm "${i}" is not supported by the client. Select one of ${Rn}.`);
  return i;
};
var os = (e) => e === ee.MD5 ? "content-md5" : `x-amz-checksum-${e.toLowerCase()}`;
var Xm = (e, t) => {
  const r = e.toLowerCase();
  for (const n of Object.keys(t))
    if (r === n.toLowerCase())
      return true;
  return false;
};
var as = (e) => e !== void 0 && typeof e != "string" && !ArrayBuffer.isView(e) && !sa(e);
var cn = {};
var Nt = {};
var Uo;
function Zm() {
  if (Uo)
    return Nt;
  Uo = 1, Object.defineProperty(Nt, "__esModule", { value: true }), Nt.AwsCrc32c = void 0;
  var e = _e, t = We(), r = Dc(), n = (
    /** @class */
    function() {
      function s() {
        this.crc32c = new r.Crc32c();
      }
      return s.prototype.update = function(i) {
        (0, t.isEmptyData)(i) || this.crc32c.update((0, t.convertToBuffer)(i));
      }, s.prototype.digest = function() {
        return e.__awaiter(this, void 0, void 0, function() {
          return e.__generator(this, function(i) {
            return [2, (0, t.numToUint8)(this.crc32c.digest())];
          });
        });
      }, s.prototype.reset = function() {
        this.crc32c = new r.Crc32c();
      }, s;
    }()
  );
  return Nt.AwsCrc32c = n, Nt;
}
var $o;
function Dc() {
  return $o || ($o = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: true }), e.AwsCrc32c = e.Crc32c = e.crc32c = void 0;
    var t = _e, r = We();
    function n(c2) {
      return new s().update(c2).digest();
    }
    e.crc32c = n;
    var s = (
      /** @class */
      function() {
        function c2() {
          this.checksum = 4294967295;
        }
        return c2.prototype.update = function(u) {
          var l, h;
          try {
            for (var p = t.__values(u), g = p.next(); !g.done; g = p.next()) {
              var b = g.value;
              this.checksum = this.checksum >>> 8 ^ o[(this.checksum ^ b) & 255];
            }
          } catch (A) {
            l = { error: A };
          } finally {
            try {
              g && !g.done && (h = p.return) && h.call(p);
            } finally {
              if (l)
                throw l.error;
            }
          }
          return this;
        }, c2.prototype.digest = function() {
          return (this.checksum ^ 4294967295) >>> 0;
        }, c2;
      }()
    );
    e.Crc32c = s;
    var i = [
      0,
      4067132163,
      3778769143,
      324072436,
      3348797215,
      904991772,
      648144872,
      3570033899,
      2329499855,
      2024987596,
      1809983544,
      2575936315,
      1296289744,
      3207089363,
      2893594407,
      1578318884,
      274646895,
      3795141740,
      4049975192,
      51262619,
      3619967088,
      632279923,
      922689671,
      3298075524,
      2592579488,
      1760304291,
      2075979607,
      2312596564,
      1562183871,
      2943781820,
      3156637768,
      1313733451,
      549293790,
      3537243613,
      3246849577,
      871202090,
      3878099393,
      357341890,
      102525238,
      4101499445,
      2858735121,
      1477399826,
      1264559846,
      3107202533,
      1845379342,
      2677391885,
      2361733625,
      2125378298,
      820201905,
      3263744690,
      3520608582,
      598981189,
      4151959214,
      85089709,
      373468761,
      3827903834,
      3124367742,
      1213305469,
      1526817161,
      2842354314,
      2107672161,
      2412447074,
      2627466902,
      1861252501,
      1098587580,
      3004210879,
      2688576843,
      1378610760,
      2262928035,
      1955203488,
      1742404180,
      2511436119,
      3416409459,
      969524848,
      714683780,
      3639785095,
      205050476,
      4266873199,
      3976438427,
      526918040,
      1361435347,
      2739821008,
      2954799652,
      1114974503,
      2529119692,
      1691668175,
      2005155131,
      2247081528,
      3690758684,
      697762079,
      986182379,
      3366744552,
      476452099,
      3993867776,
      4250756596,
      255256311,
      1640403810,
      2477592673,
      2164122517,
      1922457750,
      2791048317,
      1412925310,
      1197962378,
      3037525897,
      3944729517,
      427051182,
      170179418,
      4165941337,
      746937522,
      3740196785,
      3451792453,
      1070968646,
      1905808397,
      2213795598,
      2426610938,
      1657317369,
      3053634322,
      1147748369,
      1463399397,
      2773627110,
      4215344322,
      153784257,
      444234805,
      3893493558,
      1021025245,
      3467647198,
      3722505002,
      797665321,
      2197175160,
      1889384571,
      1674398607,
      2443626636,
      1164749927,
      3070701412,
      2757221520,
      1446797203,
      137323447,
      4198817972,
      3910406976,
      461344835,
      3484808360,
      1037989803,
      781091935,
      3705997148,
      2460548119,
      1623424788,
      1939049696,
      2180517859,
      1429367560,
      2807687179,
      3020495871,
      1180866812,
      410100952,
      3927582683,
      4182430767,
      186734380,
      3756733383,
      763408580,
      1053836080,
      3434856499,
      2722870694,
      1344288421,
      1131464017,
      2971354706,
      1708204729,
      2545590714,
      2229949006,
      1988219213,
      680717673,
      3673779818,
      3383336350,
      1002577565,
      4010310262,
      493091189,
      238226049,
      4233660802,
      2987750089,
      1082061258,
      1395524158,
      2705686845,
      1972364758,
      2279892693,
      2494862625,
      1725896226,
      952904198,
      3399985413,
      3656866545,
      731699698,
      4283874585,
      222117402,
      510512622,
      3959836397,
      3280807620,
      837199303,
      582374963,
      3504198960,
      68661723,
      4135334616,
      3844915500,
      390545967,
      1230274059,
      3141532936,
      2825850620,
      1510247935,
      2395924756,
      2091215383,
      1878366691,
      2644384480,
      3553878443,
      565732008,
      854102364,
      3229815391,
      340358836,
      3861050807,
      4117890627,
      119113024,
      1493875044,
      2875275879,
      3090270611,
      1247431312,
      2660249211,
      1828433272,
      2141937292,
      2378227087,
      3811616794,
      291187481,
      34330861,
      4032846830,
      615137029,
      3603020806,
      3314634738,
      939183345,
      1776939221,
      2609017814,
      2295496738,
      2058945313,
      2926798794,
      1545135305,
      1330124605,
      3173225534,
      4084100981,
      17165430,
      307568514,
      3762199681,
      888469610,
      3332340585,
      3587147933,
      665062302,
      2042050490,
      2346497209,
      2559330125,
      1793573966,
      3190661285,
      1279665062,
      1595330642,
      2910671697
    ], o = (0, r.uint32ArrayFrom)(i), a = Zm();
    Object.defineProperty(e, "AwsCrc32c", { enumerable: true, get: function() {
      return a.AwsCrc32c;
    } });
  }(cn)), cn;
}
var Ym = Dc();
var Uc = (e, t) => ({
  [ee.MD5]: t.md5,
  [ee.CRC32]: Jn.AwsCrc32,
  [ee.CRC32C]: Ym.AwsCrc32c,
  [ee.SHA1]: t.sha1,
  [ee.SHA256]: t.sha256
})[e];
var $c = (e, t) => {
  const r = new e();
  return r.update(ot(t || "")), r.digest();
};
var Qm = {
  name: "flexibleChecksumsMiddleware",
  step: "build",
  tags: ["BODY_CHECKSUM"],
  override: true
};
var Jm = (e, t) => (r, n) => async (s) => {
  if (!ge.isInstance(s.request))
    return r(s);
  const { request: i } = s, { body: o, headers: a } = i, { base64Encoder: c2, streamHasher: u } = e, { input: l, requestChecksumRequired: h, requestAlgorithmMember: p } = t, g = Km(l, {
    requestChecksumRequired: h,
    requestAlgorithmMember: p
  }, !!n.isS3ExpressBucket);
  let b = o, A = a;
  if (g) {
    const T = os(g), I = Uc(g, e);
    if (as(o)) {
      const { getAwsChunkedEncodingStream: $, bodyLengthChecker: X } = e;
      b = $(o, {
        base64Encoder: c2,
        bodyLengthChecker: X,
        checksumLocationName: T,
        checksumAlgorithmFn: I,
        streamHasher: u
      }), A = {
        ...a,
        "content-encoding": a["content-encoding"] ? `${a["content-encoding"]},aws-chunked` : "aws-chunked",
        "transfer-encoding": "chunked",
        "x-amz-decoded-content-length": a["content-length"],
        "x-amz-content-sha256": "STREAMING-UNSIGNED-PAYLOAD-TRAILER",
        "x-amz-trailer": T
      }, delete A["content-length"];
    } else if (!Xm(T, a)) {
      const $ = await $c(I, o);
      A = {
        ...a,
        [T]: c2($)
      };
    }
  }
  return await r({
    ...s,
    request: {
      ...i,
      headers: A,
      body: b
    }
  });
};
var Lc = (e = []) => {
  const t = [];
  for (const r of Vm)
    !e.includes(r) || !Rn.includes(r) || t.push(r);
  return t;
};
var ey = (e) => {
  const t = e.lastIndexOf("-");
  if (t !== -1) {
    const r = e.slice(t + 1);
    if (!r.startsWith("0")) {
      const n = parseInt(r, 10);
      if (!isNaN(n) && n >= 1 && n <= 1e4)
        return true;
    }
  }
  return false;
};
function Lo(e) {
  return new Blob([e]).stream();
}
var ty = async (e, { streamHasher: t, checksumAlgorithmFn: r, base64Encoder: n }) => {
  const s = as(e) ? t(r, e) : $c(r, e);
  return n(await s);
};
var ry = async (e, { config: t, responseAlgorithms: r }) => {
  const n = Lc(r), { body: s, headers: i } = e;
  for (const o of n) {
    const a = os(o), c2 = i[a];
    if (c2) {
      const u = Uc(o, t), { streamHasher: l, base64Encoder: h } = t, p = await ty(s, { streamHasher: l, checksumAlgorithmFn: u, base64Encoder: h });
      if (p === c2)
        break;
      throw new Error(`Checksum mismatch: expected "${p}" but received "${c2}" in response header "${a}".`);
    }
  }
};
var ny = {
  name: "flexibleChecksumsResponseMiddleware",
  toMiddleware: "deserializerMiddleware",
  relation: "after",
  tags: ["BODY_CHECKSUM"],
  override: true
};
var sy = (e, t) => (r, n) => async (s) => {
  if (!ge.isInstance(s.request))
    return r(s);
  const i = s.input, o = await r(s), a = o.response;
  let c2;
  const { requestValidationModeMember: u, responseAlgorithms: l } = t;
  if (u && i[u] === "ENABLED") {
    const { clientName: h, commandName: p } = n;
    if (h === "S3Client" && p === "GetObjectCommand" && Lc(l).every((A) => {
      const R = os(A), T = a.headers[R];
      return !T || ey(T);
    }))
      return o;
    const b = as(a.body);
    b && (c2 = await e.streamCollector(a.body), a.body = Lo(c2)), await ry(o.response, {
      config: e,
      responseAlgorithms: l
    }), b && c2 && (a.body = Lo(c2));
  }
  return o;
};
var iy = (e, t) => ({
  applyToStack: (r) => {
    r.add(Jm(e, t), Qm), r.addRelativeTo(sy(e, t), ny);
  }
});
var oy = class extends On.classBuilder().ep({
  ...Ta,
  Bucket: { type: "contextParams", name: "Bucket" },
  Key: { type: "contextParams", name: "Key" }
}).m(function(t, r, n, s) {
  return [
    xa(n, this.serialize, this.deserialize),
    Aa(n, t.getEndpointParameterInstructions()),
    od(),
    zm(n),
    iy(n, {
      input: this.input,
      requestAlgorithmMember: "ChecksumAlgorithm",
      requestChecksumRequired: false
    })
  ];
}).s("AmazonS3", "PutObject", {}).n("S3Client", "PutObjectCommand").f(ip, sp).ser(ap).de(up).build() {
};
var ay = axios_default.create({});
async function cy(e, t, r) {
  return e.getSignedUrl || console.error("uploader.getSignedUrlurl"), await e.getSignedUrl(e.bucket, t, e, r);
}
async function uy(e, t) {
  const { file: r, onProgress: n, options: s } = e, o = await cy(s, t, "put"), a = decodeURIComponent(o);
  return await ay.put(a, r, {
    onUploadProgress: (c2) => {
      const { loaded: u, total: l } = c2;
      n({ percent: Math.round(u * 100 / l) });
    }
  });
}
async function dy(e) {
  const { file: t, fileName: r, onProgress: n, options: s } = e, i = s, o = new Lm({
    ...(i == null ? void 0 : i.sdkOpts) || {}
  }), a = await _9(t, r, i);
  async function c2() {
    const u = { url: i.sdkOpts.endpoint + "/" + i.bucket + "/" + a, key: a };
    return i.successHandle ? await i.successHandle(u) : u;
  }
  if (i.getSignedUrl)
    await uy(e, a);
  else {
    const u = {
      Bucket: i.bucket,
      Key: a
      // The name of the object. For example, 'sample_upload.txt'.
    };
    await o.send(new oy({ Body: t, ...u }));
  }
  return await c2();
}
async function Ey(e) {
  const { getConfig: t } = w9(), r = t("s3"), n = e.options, s = lodash_default_default.merge(lodash_default_default.cloneDeep(r), n);
  return e.options = s, await dy(e);
}
export {
  cy as buildSignedUrl,
  Ey as upload,
  uy as uploadUsingSignedUrl
};
/*! Bundled license information:

@fast-crud/fast-extends/dist/uploader-s3-f214a8a0.mjs:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)
  (*!
   * Bowser - a browser detector
   * https://github.com/lancedikson/bowser
   * MIT License | (c) Dustin Diaz 2012-2015
   * MIT License | (c) Denis Demchenko 2015-2019
   *)
*/
//# sourceMappingURL=uploader-s3-f214a8a0-HUQ5MOLL.js.map
